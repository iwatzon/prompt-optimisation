{"task_id": "HumanEval/163", "completion": ""}
{"task_id": "HumanEval/28", "completion": ""}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    \n    def count_levels(s: str) -> int:\n        \"\"\" Helper function to calculate the deepest level of nesting for a single group of parentheses. \"\"\"\n        \n        # Initialize counters\n        levels = 0\n        max_level = 0\n        \n        # Iterate over each character in the string\n        for char in s:\n            if char == '(':\n                levels += 1\n                max_level = max(max_level, levels)\n            elif char == ')':\n                levels -= 1\n        \n        return max_level\n    \n    # Split the input string into groups of parentheses and apply count_levels to each group\n    return [count_levels(group) for group in paren_string.split()]"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    \n    # If the list is empty, return it as it is\n    if not lst:\n        return lst\n    \n    # Initialize the result list with the minimum value from the input list\n    result = [min(lst)]\n    \n    # Remove the minimum value from the input list\n    lst.remove(min(lst))\n    \n    # While the input list is not empty\n    while lst:\n        # Find the maximum value in the remaining list\n        max_val = max(lst)\n        \n        # Add the maximum value to the result list\n        result.append(max_val)\n        \n        # Remove the maximum value from the input list\n        lst.remove(max_val)\n    \n    return result\n\n# Test cases\nprint(strange_sort_list([1, 2, 3, 4])) == [1, 4, 2, 3]\nprint(strange_sort_list([5, 5, 5, 5])) == [5, 5, 5, 5]\nprint(strange_sort_list([])) == []"}
{"task_id": "HumanEval/62", "completion": ""}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    \n    # Check if the list is empty or has only one element\n    if len(l) < 2:\n        return True\n    \n    # Initialize a flag to indicate whether the list is increasing or decreasing\n    is_increasing = l[0] <= l[-1]\n    \n    # Iterate over the list from the second element to the second last element\n    for i in range(1, len(l) - 1):\n        # If we find an element that breaks the monotonicity, return False\n        if (is_increasing and l[i] > l[i + 1]) or (not is_increasing and l[i] < l[i + 1]):\n            return False\n    \n    # If we have checked all elements and haven't returned False, the list is monotonically increasing or decreasing\n    return True"}
{"task_id": "HumanEval/35", "completion": ""}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n     [1, 3, 4]\n    \"\"\"\n    \n    # Create an empty dictionary to store unique numbers and their counts\n    num_counts = {}\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # If the number is already in the dictionary, increment its count\n        if num in num_counts:\n            num_counts[num] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            num_counts[num] = 1\n    \n    # Create an empty list to store unique numbers\n    unique_numbers = []\n    \n    # Iterate over each number and its count in the dictionary\n    for num, count in num_counts.items():\n        # If the count is 1, add the number to the list of unique numbers\n        if count == 1:\n            unique_numbers.append(num)\n    \n    # Return the list of unique numbers\n    return unique_numbers\n\n# Test the function\nprint(remove_duplicates([1, 2, 3, 2, 4]))  # Output: [1, 3, 4]"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n       brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n       where n > 0\n\n       For example:\n       >>> special_factorial(4)\n       288\n\n       The function will receive an integer as input and should return the special\n       factorial of this integer.\n    \"\"\"\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    \n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \n    :param values: A list of any python values\n    :return: A list of integers from the input list\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    \n    Parameters:\n    lst (list): A list of numbers\n    \n    Returns:\n    int: The sum of squares of odd integers in the list\n    '''\n    # Initialize a variable to store the sum of squares of odd integers\n    total = 0\n    \n    # Iterate over each number in the input list\n    for num in lst:\n        # Check if the number is an integer and not negative\n        if isinstance(num, int) and num >= 0:\n            # Check if the number is odd by using the modulus operator\n            if num % 2 != 0:\n                # If the number is odd, add its square to the total\n                total += num ** 2\n    \n    # Return the total sum of squares of odd integers\n    return total"}
{"task_id": "HumanEval/108", "completion": ""}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    \n    # Initialize the sum and product variables to 0 and 1 respectively\n    total_sum = 0\n    total_product = 1\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # Add the current number to the total sum\n        total_sum += num\n        \n        # Multiply the current number with the total product\n        total_product *= num\n    \n    # Return a tuple containing the total sum and the total product\n    return total_sum, total_product\n\n# Test the function\nprint(sum_product([1, 2, 3, 4]))  # Output: (10, 24)"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": ""}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"}
{"task_id": "HumanEval/59", "completion": ""}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct). You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j]. It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n    \n    # Get the number of rows and columns in the grid\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n    \n    # Initialize a visited set to keep track of visited cells\n    visited = set()\n    \n    # Define the possible movements (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Function to perform DFS from a given cell\n    def dfs(row, col, k, path):\n        # If the current path length is equal to k, return the path\n        if len(path) == k:\n            return path\n        \n        # Mark the current cell as visited\n        visited.add((row, col))\n        \n        # Initialize the minimum path and its value\n        min_path = None\n        min_value = float('inf')\n        \n        # Explore all possible movements from the current cell\n        for dr, dc in movements:\n            nr, nc = row + dr, col + dc\n            \n            # Check if the new cell is within the grid boundaries and not visited\n            if 0 <= nr < num_rows and 0 <= nc < num_cols and (nr, nc) not in visited:\n                # Get the value of the new cell\n                value = grid[nr][nc]\n                \n                # Recursively perform DFS from the new cell\n                new_path = dfs(nr, nc, k, path + [value])\n                \n                # If a path is found and its value is less than the current minimum value, update the minimum path and value\n                if new_path and (not min_path or new_path < min_path):\n                    min_path = new_path\n                    min_value = min(min_value, int(''.join(map(str, new_path))))\n        \n        # If a minimum path is found, return it; otherwise, return None\n        return min_path if min_value != float('inf') else None\n    \n    # Initialize the minimum path and its value\n    min_path = None\n    min_value = float('inf')\n    \n    # Perform DFS from each cell in the grid\n    for row in range(num_rows):\n        for col in range(num_cols):\n            # Get the value of the current cell\n            value = grid[row][col]\n            \n            # Recursively perform DFS from the current cell\n            new_path = dfs(row, col, k, [value])\n            \n            # If a path is found and its value is less than the current minimum value, update the minimum path and value\n            if new_path and (not min_path or new_path < min_path):\n                min_path = new_path\n                min_value = int(''.join(map(str, new_path)))\n    \n    # Return the minimum path\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    This function takes a string s as input and returns the modified string.\n    If the string contains letters, it reverses their case. If the string contains no letters, it reverses the string itself.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    \n    # Initialize an empty list to store the characters of the modified string\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is a letter\n        if char.isalpha():\n            # If it's a letter, reverse its case and add it to the result list\n            result.append(char.swapcase())\n        else:\n            # If it's not a letter, just add it to the result list as it is\n            result.append(char)\n    \n    # Join the characters in the result list into a string and return it\n    return ''.join(result)\n\n# Test cases\nprint(solve(\"12\"))  # Output: \"21\"\nprint(solve(\"ab\"))  # Output: \"AB\"\nprint(solve(\"#a@C\"))  # Output: \"#A@c\""}
{"task_id": "HumanEval/143", "completion": ""}
{"task_id": "HumanEval/50", "completion": ""}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (2, 1)\n    \"\"\"\n    num = abs(num)  # Take the absolute value to handle negative numbers\n    even_count = 0\n    odd_count = 0\n\n    for digit in str(num):  # Convert the number to a string to easily iterate over each digit\n        if int(digit) % 2 == 0:  # Check if the digit is even (i.e., it's divisible by 2)\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return even_count, odd_count"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        tuple: A tuple containing two integers. The first element is the count of even integer palindromes,\n               and the second element is the count of odd integer palindromes.\n\n    Examples:\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n            Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n            Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n\n    for i in range(1, n + 1):\n        # Convert the number to a string to check if it's a palindrome\n        str_i = str(i)\n        \n        # Check if the string is equal to its reverse\n        if str_i == str_i[::-1]:\n            # If it's a palindrome, increment the corresponding count\n            if i % 2 == 0:\n                count_even += 1\n            else:\n                count_odd += 1\n\n    return (count_even, count_odd)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"Return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    \n    # Initialize counters for opening and closing brackets\n    open_count = 0\n    close_count = 0\n    \n    # Iterate over each character in the string\n    for char in brackets:\n        # If the character is an opening bracket, increment the counter\n        if char == \"<\":\n            open_count += 1\n        # If the character is a closing bracket, increment the counter\n        elif char == \">\":\n            close_count += 1\n    \n    # Check if the counts are equal; if so, return True\n    # Otherwise, return False\n    return open_count == close_count"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array \n    of nums.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        int: The minimum sum of any non-empty sub-array of nums.\n    \"\"\"\n    min_sum = float('inf')  # Initialize with positive infinity\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num  # Calculate the sum of the current sub-array\n        min_sum = min(min_sum, current_sum)  # Update the minimum sum if necessary\n        \n        # If the current sum is negative, reset it to zero and continue\n        if current_sum < 0:\n            current_sum = 0\n    \n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Check if the three sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter of the triangle\n        s = (a + b + c) / 2\n        \n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        \n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    \n    # If the three sides do not form a valid triangle, return -1\n    else:\n        return -1"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. \n    Your goal is to separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n     >>> separate_paren_groups('( ) (( )) (( )( ))')\n     ['()', '(())', '(()())']\n    \"\"\"\n    \n    # Initialize an empty list to store the separated paren groups\n    paren_groups = []\n    \n    # Initialize a counter to keep track of the current group's depth\n    depth = 0\n    \n    # Initialize an empty string to build the current group\n    current_group = ''\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        \n        # If the character is an open parenthesis, increment the depth and add it to the current group\n        if char == '(':\n            depth += 1\n            current_group += char\n        \n        # If the character is a close parenthesis, decrement the depth and add it to the current group\n        elif char == ')':\n            depth -= 1\n            current_group += char\n            \n            # If the depth is zero, it means we've reached the end of a paren group, so add it to the list and reset the current group\n            if depth == 0:\n                paren_groups.append(current_group)\n                current_group = ''\n    \n    # Return the list of separated paren groups\n    return paren_groups"}
{"task_id": "HumanEval/40", "completion": ""}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    \n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    Args:\n        game (list): A list of scores\n        guess (list): A list of guesses\n    \n    Returns:\n        list: A list of differences between each guess and its corresponding score\n    \"\"\"\n    return [abs(g - s) for g, s in zip(guess, game)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([[\n       [1,2,3,4,5,6],\n       [1,2,3,4,1,6],\n       [1,2,3,4,5,1]\n     ]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    Returns:\n        list[tuple[int, int]]: A list of tuples containing the coordinates\n            where x is found in each row.\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        if x in row:\n            # Find the indices of x in the row and sort them in descending order\n            indices = sorted(range(len(row)), key=lambda k: row[k], reverse=True)\n            # Add the coordinates to the result list\n            result.extend((i, j) for j in indices if row[j] == x)\n    return result"}
