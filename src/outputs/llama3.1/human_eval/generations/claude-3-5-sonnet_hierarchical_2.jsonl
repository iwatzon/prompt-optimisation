{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n\n    Args:\n        a (int): The lower bound of the range.\n        b (int): The upper bound of the range.\n\n    Returns:\n        list: A list of even integers between a and b, in ascending order.\n    \"\"\"\n    \n    # Ensure that both inputs are positive integers\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both 'a' and 'b' must be integers.\")\n    if a <= 0 or b <= 0:\n        raise ValueError(\"'a' and 'b' must be positive.\")\n\n    # Generate even numbers between a and b\n    even_numbers = [i for i in range(a, b + 1) if i % 2 == 0]\n\n    return even_numbers"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string\n    \n    Args:\n        strings (List[str]): A list of strings to be concatenated.\n    \n    Returns:\n        str: The concatenated string.\n    \n    Examples:\n        >>> concatenate([])\n        ''\n        >>> concatenate(['a', 'b', 'c'])\n        'abc'\n    \"\"\"\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n\n    :param paren_string: A string containing multiple groups of nested parentheses separated by spaces.\n    :return: A list of integers representing the deepest level of nesting for each group of parentheses.\n    \"\"\"\n    \n    # Split the input string into individual groups of parentheses\n    groups = paren_string.split()\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over each group of parentheses\n    for group in groups:\n        # Initialize a counter to track the current nesting level\n        nesting_level = 0\n        \n        # Iterate over each character in the group\n        for char in group:\n            # If the character is an opening parenthesis, increment the nesting level\n            if char == '(':\n                nesting_level += 1\n            # If the character is a closing parenthesis, decrement the nesting level\n            elif char == ')':\n                nesting_level -= 1\n        \n        # Append the deepest nesting level for the current group to the result list\n        result.append(nesting_level)\n    \n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    \n    # Handle edge case where the list is empty\n    if not lst:\n        return []\n\n    # Initialize result list with minimum value from the input list\n    result = [min(lst)]\n    \n    # Remove the minimum value from the input list\n    lst.remove(min(lst))\n    \n    # Continue adding maximum and minimum values to the result list\n    while lst:\n        # Add maximum value from the remaining list to the result list\n        result.append(max(lst))\n        \n        # If there's more than one element left in the list, remove the maximum value\n        if len(lst) > 1:\n            lst.remove(max(lst))\n            \n        # If there's only one element left in the list, add it to the result list and break the loop\n        else:\n            result.append(lst[0])\n            break\n    \n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\" xs represent coefficients of a polynomial.\n        xs[0] + xs[1] * x + xs[2] * x^2 + ....\n        Return derivative of this polynomial in the same form.\n        >>> derivative([3, 1, 2, 4, 5])\n        [1, 4, 12, 20]\n        >>> derivative([1, 2, 3])\n        [2, 6]\n    \"\"\"\n    # Check if input list is empty\n    if not xs:\n        return []\n\n    # Initialize result list with the coefficient of x^0 (which is always 0)\n    result = [0]\n\n    # Iterate over coefficients starting from the second one (index 1)\n    for i in range(1, len(xs)):\n        # For each coefficient, multiply it by its index and add to the result\n        result.append(i * xs[i])\n\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n    \n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    # Check if the list is empty or has only one element (trivially monotonic)\n    if len(l) < 2:\n        return True\n    \n    # Compare each pair of adjacent elements in the list\n    for i in range(len(l) - 1):\n        # If we find a pair where the first element is greater than the second, \n        # and we've already seen an increasing sequence, then the list isn't monotonic\n        if l[i] > l[i + 1]:\n            return False\n        \n        # If we find a pair where the first element is less than the second, \n        # and we've already seen a decreasing sequence, then the list isn't monotonic\n        elif l[i] < l[i + 1]:\n            if any(l[j] > l[j + 1] for j in range(i)):\n                return False\n    \n    # If we've checked all pairs without returning False, then the list is monotonic\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    \n    # Check if the list is empty\n    if not l:\n        raise ValueError(\"List cannot be empty\")\n        \n    # Initialize max_element with the first element of the list\n    max_element = l[0]\n    \n    # Iterate through the rest of the list to find the maximum element\n    for i in range(1, len(l)):\n        # If a larger element is found, update max_element\n        if l[i] > max_element:\n            max_element = l[i]\n            \n    return max_element"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n            \n    return result"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        int: The special factorial of the input integer.\n\n    Raises:\n        ValueError: If the input is not a positive integer.\n    \"\"\"\n    \n    # Check if input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize result with 1 (since 1! = 1)\n    result = 1\n    \n    # Calculate the special factorial from 2 to n (inclusive)\n    for i in range(2, n + 1):\n        # Multiply the current number's factorial to the result\n        result *= math.factorial(i)\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    \n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    \n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Parameters:\n    lst (list): A list of numbers\n    \n    Returns:\n    int: The sum of squares of the odd numbers in the list\n    \n    Examples:\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    \n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over each number in the list\n    for num in lst:\n        # Check if the number is an integer and not negative\n        if isinstance(num, int) and num >= 0:\n            # If the number is odd, add its square to the sum\n            if num % 2 != 0:\n                total_sum += num ** 2\n    \n    # Return the sum of squares of the odd numbers\n    return total_sum"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Count numbers in an array with sum of digits > 0.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The number of elements which has a sum of digits > 0.\n    \"\"\"\n    def sum_of_digits(n):\n        \"\"\"Calculate the sum of digits for a given integer.\"\"\"\n        return sum(int(digit) for digit in str(abs(n)))\n\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n\n    return count"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n\n    Args:\n        numbers: A list of integers\n\n    Returns:\n        A tuple containing the sum and product of all integers in the list\n    \"\"\"\n    # Initialize sum and product to 0 and 1 respectively\n    total_sum = 0\n    total_product = 1\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # Add the current number to the total sum\n        total_sum += num\n        \n        # Multiply the current number with the total product\n        total_product *= num\n    \n    # Return a tuple containing the total sum and total product\n    return total_sum, total_product"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    \n    Args:\n        strings (List[str]): A list of strings to be filtered.\n        substring (str): The substring to search for in the strings.\n    \n    Returns:\n        List[str]: A new list containing only the strings from the input list\n            that contain the given substring.\n    \n    Examples:\n        >>> filter_by_substring([], 'a')\n        []\n        >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n        ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"Return length of given string.\n\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string.\")\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    \n    # Edge case: If n is 1 or less, return 1 as per problem statement.\n    if n <= 1:\n        return 1\n    \n    # Initialize variables to store previous two Fibonacci numbers.\n    a, b = 1, 1\n    \n    # Calculate the nth Fibonacci number iteratively.\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    # Return the calculated nth Fibonacci number.\n    return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13**195)\n       29\n    >>> largest_prime_factor(20**48)\n       2\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if num is a prime number.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    max_prime_factor = -1\n    for possible_prime_factor in range(int(n ** 0.5), 1, -1):\n        while n % possible_prime_factor == 0 and is_prime(possible_prime_factor):\n            max_prime_factor = possible_prime_factor\n            n //= possible_prime_factor\n    if n > 1:\n        max_prime_factor = n\n\n    return max_prime_factor"}
{"task_id": "HumanEval/129", "completion": "from collections import deque\n\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct). You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j]. It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    # Get the number of rows and columns in the grid\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n\n    # Initialize a queue for BFS with the starting cell (assuming it's the top-left corner)\n    start_cell = (0, 0, [grid[0][0]])\n    queue = deque([start_cell])\n\n    # Initialize a set to keep track of visited cells\n    visited = {start_cell[:2]}\n\n    while queue:\n        row, col, path = queue.popleft()\n\n        # If the current path has reached the desired length k, return it\n        if len(path) == k:\n            return path\n\n        # Explore neighbors in all four directions (up, down, left, right)\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = row + dr, col + dc\n\n            # Check if the neighbor is within the grid boundaries\n            if 0 <= nr < num_rows and 0 <= nc < num_cols:\n                # Create a new path by appending the neighbor's value to the current path\n                new_path = path + [grid[nr][nc]]\n\n                # If the new path has not been visited before, mark it as visited and add it to the queue\n                if (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc, new_path))\n\n    # If no path of length k is found, return an empty list\n    return []"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    This function takes a string s, reverses the case of letters in it,\n    and if the string contains no letters, it reverses the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n\n    # Initialize an empty list to store the characters of the result\n    result = []\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is a letter\n        if char.isalpha():\n            # If it's a letter, reverse its case and add it to the result\n            result.append(char.swapcase())\n        else:\n            # If it's not a letter, just add it to the result as it is\n            result.append(char)\n\n    # Join the characters in the result list into a string\n    modified_string = ''.join(result)\n\n    # Check if the original string contained no letters\n    if s.isalpha():\n        # If it didn't contain any letters, reverse the modified string\n        return modified_string[::-1]\n    else:\n        # Otherwise, just return the modified string as it is\n        return modified_string\n\n# Test cases\nprint(solve(\"12\"))  # Expected output: \"21\"\nprint(solve(\"ab\"))  # Expected output: \"AB\"\nprint(solve(\"#a@C\"))  # Expected output: \"#A@c\""}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing the words from the original sentence,\n    whose lengths are prime numbers, in the same order.\n\n    Args:\n        sentence (str): A string representing a sentence with some words separated by spaces.\n\n    Returns:\n        str: A string containing the words from the original sentence,\n             whose lengths are prime numbers, in the same order.\n    \"\"\"\n    \n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    words = sentence.split()\n    result = ' '.join([word for word in words if is_prime(len(word))])\n    \n    # If the original sentence was empty or contained no prime-length words,\n    # return an empty string instead of a single space.\n    return result if result else ''"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    \n    Parameters:\n    s (str): The input string to be encoded.\n    \n    Returns:\n    str: The encoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) + 5) % 26) + ord(\"a\") for ch in s])\n\ndef decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n    \n    Parameters:\n    s (str): The input string to be decoded.\n    \n    Returns:\n    str: The decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5) % 26) + ord(\"a\") for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        tuple: A tuple containing two integers. The first element is the count of even digits,\n               and the second element is the count of odd digits.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (2, 1)\n    \"\"\"\n    \n    # Convert the integer to a string to easily iterate over each digit\n    num_str = str(abs(num))  # Use abs() to handle negative numbers\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate over each character (digit) in the string\n    for digit in num_str:\n        # Convert the character back to an integer\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd and increment the corresponding counter\n        if int_digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return a tuple with the counts of even and odd digits\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        tuple: A tuple containing the count of even and odd integer palindromes.\n\n    Examples:\n        >>> even_odd_palindrome(3)\n        (1, 2)\n        >>> even_odd_palindrome(12)\n        (4, 6)\n    \"\"\"\n    \n    # Initialize counters for even and odd palindromes\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        \n        # Convert the number to a string to check if it's a palindrome\n        str_i = str(i)\n        \n        # Check if the number is a palindrome\n        if str_i == str_i[::-1]:\n            \n            # If the number is even, increment the even counter\n            if i % 2 == 0:\n                even_count += 1\n                \n            # Otherwise, increment the odd counter\n            else:\n                odd_count += 1\n                \n    # Return a tuple containing the counts of even and odd palindromes\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"Return True if every opening bracket has a corresponding closing bracket.\n\n    Args:\n        brackets (str): A string of \"<\" and \">\" characters.\n\n    Returns:\n        bool: Whether all opening brackets have matching closing brackets.\n    \"\"\"\n    \n    # Initialize counters for opening and closing brackets\n    open_count = 0\n    close_count = 0\n    \n    # Iterate through the input string\n    for bracket in brackets:\n        # If we encounter an opening bracket, increment the counter\n        if bracket == \"<\":\n            open_count += 1\n        # If we encounter a closing bracket, increment the counter\n        elif bracket == \">\":\n            close_count += 1\n    \n    # Check if the counts match; return True if they do, False otherwise\n    return open_count == close_count"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array \n    of nums.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        int: The minimum sum of any non-empty sub-array of nums.\n    \"\"\"\n    # Initialize minimum sum as infinity\n    min_sum = float('inf')\n    \n    # Iterate over all possible sub-arrays\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            \n            # Update minimum sum if current sum is smaller\n            min_sum = min(min_sum, current_sum)\n    \n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Check if three sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter of the triangle\n        s = (a + b + c) / 2\n        \n        # Use Heron's formula to calculate the area of the triangle\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        \n        # Round the area to 2 decimal points and return it\n        return round(area, 2)\n    \n    # If three sides do not form a valid triangle, return -1\n    else:\n        return -1\n\n# Test cases\nprint(triangle_area(3, 4, 5))  # Expected output: 6.00\nprint(triangle_area(1, 2, 10))  # Expected output: -1"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Input to this function is a string containing multiple groups of nested parentheses.\n    Your goal is to separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n\n    Args:\n        paren_string: str\n\n    Returns:\n        List[str]: A list of strings, where each string represents a group of balanced parentheses.\n\n    Raises:\n        ValueError: If the input string contains unbalanced or nested groups of parentheses.\n    \"\"\"\n    \n    # Remove leading and trailing spaces from the input string\n    paren_string = paren_string.strip()\n    \n    # Initialize an empty stack to keep track of opening parentheses\n    stack = []\n    \n    # Initialize an empty list to store the separate groups of parentheses\n    groups = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If the character is an opening parenthesis, push it onto the stack\n        if char == '(':\n            stack.append(char)\n        # If the character is a closing parenthesis, pop the corresponding opening parenthesis from the stack\n        elif char == ')':\n            if not stack:  # Check if the stack is empty (i.e., there's no matching opening parenthesis)\n                raise ValueError(\"Unbalanced or nested groups of parentheses\")\n            stack.pop()\n        \n        # If the stack is empty at this point, it means we've encountered a separate group of parentheses\n        elif not stack:\n            groups.append(paren_string[paren_string.index(char):])\n    \n    return groups\n\n# Example usage:\nprint(separate_paren_groups('( ) (( )) (( )( ))'))"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n\n    # Check if the list has at least three elements\n    if len(l) < 3:\n        return False\n\n    # Sort the list in ascending order to make it easier to find triplets that sum to zero\n    l.sort()\n\n    # Iterate over the list with three nested loops to check all possible triplets\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                # Check if the current triplet sums to zero and is distinct (i.e., not the same element three times)\n                if l[i] + l[j] + l[k] == 0 and l[i] != l[j] and l[j] != l[k]:\n                    return True\n\n    # If no triplets that sum to zero are found, return False\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    This function compares the scores of a game with the guesses made by a player.\n\n    Args:\n        game (list): A list of actual scores.\n        guess (list): A list of guessed scores.\n\n    Returns:\n        list: A list where each element is the absolute difference between the corresponding score and guess. If the guess was correct, the value is 0.\n\n    Raises:\n        ValueError: If the lengths of game and guess do not match.\n    \"\"\"\n    \n    # Check if the lengths of game and guess are equal\n    if len(game) != len(guess):\n        raise ValueError(\"The lengths of game and guess must be equal.\")\n        \n    # Use a list comprehension to calculate the absolute difference between each score and guess\n    return [abs(score - guess_i) for score, guess_i in zip(game, guess)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([ \n       [1,2,3,4,5,6], \n       [1,2,3,4,1,6], \n       [1,2,3,4,5,1] \n     ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n     \"\"\"\n\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the input list\n    for i, row in enumerate(lst):\n        # Check if x is in the current row\n        if x in row:\n            # If x is found, iterate over the row in reverse order (to sort by columns in descending order)\n            for j in range(len(row) - 1, -1, -1):\n                # Check if the current element is equal to x\n                if row[j] == x:\n                    # If x is found, append the coordinate (row index, column index) to the list\n                    coordinates.append((i, j))\n\n    # Sort the coordinates by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n\n    return coordinates"}
