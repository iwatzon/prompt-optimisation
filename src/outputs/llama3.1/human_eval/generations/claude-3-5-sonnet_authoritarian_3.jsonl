{"task_id": "HumanEval/163", "completion": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    Args:\n    a (int): The start of the range (inclusive)\n    b (int): The end of the range (inclusive)\n\n    Returns:\n    List[int]: A list of even integers between a and b, in ascending order\n    \"\"\"\n    result = []\n    for num in range(a, b + 1):\n        if num % 2 == 0:  # Check if the number is even\n            result.append(num)\n    return result"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate list of strings into a single string\n    \n    Args:\n    strings (List[str]): A list of strings\n    \n    Returns:\n    str: The concatenated string\n    \"\"\"\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n\n    Args:\n        paren_string (str): A string with multiple groups of nested parentheses separated by spaces\n\n    Returns:\n        List[int]: A list of integers representing the deepest level of nesting for each group\n    \"\"\"\n    result = []\n    groups = paren_string.split()\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result\n\n# Example usage:\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Args:\n        lst (List[int]): A list of integers\n\n    Returns:\n        List[int]: The input list sorted in a \"strange\" order\n    \"\"\"\n    if not lst:  # edge case: empty list\n        return []\n\n    result = [min(lst)]  # start with the minimum value\n    lst.remove(min(lst))  # remove the minimum value from the original list\n\n    while lst:\n        max_val = max(lst)  # find the maximum of the remaining integers\n        result.append(max_val)  # add it to the result\n        lst.remove(max_val)  # remove the maximum value from the original list\n\n        if lst:  # if there are still values in the list\n            min_val = min(lst)  # find the minimum of the remaining integers\n            result.append(min_val)  # add it to the result\n            lst.remove(min_val)  # remove the minimum value from the original list\n\n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if len(xs) == 0:\n        return []\n    \n    result = [i * xs[i] for i in range(1, len(xs))]\n    \n    # Handle edge case where input list has only one element\n    if len(result) == 0:\n        result.append(0)\n    \n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n    \n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if len(l) < 2:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(l)):\n        if l[i] > l[i-1]:\n            increasing = True\n        elif l[i] < l[i-1]:\n            decreasing = True\n        else:\n            increasing = decreasing = False\n            break\n    \n    return increasing or decreasing"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    \"\"\"\n    Return maximum element in the list.\n    \n    Args:\n    l (list): A list of integers\n    \n    Returns:\n    int: The maximum element in the list\n    \"\"\"\n    if not l:\n        raise ValueError(\"List is empty\")\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        List[int]: A new list with duplicates removed\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n            \n    return result"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n     >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter given list of any python values only for integers\n    \n    Args:\n    values (List[Any]): A list of any Python values\n    \n    Returns:\n    List[int]: A new list with only integer values\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers \n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Args:\n    lst (List[int]): A list of integers\n    \n    Returns:\n    int: The sum of squares of odd numbers\n    \"\"\"\n    result = 0\n    for num in lst:\n        if isinstance(num, int) and num % 2 != 0:\n            result += num ** 2\n    return result"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns \n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative: \n    e.g. -123 has signed digits -1, 2, and 3.\n\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    \n    Args:\n    numbers (List[int]): A list of integers\n    \n    Returns:\n    Tuple[int, int]: A tuple with two integers: the sum and the product\n    \"\"\"\n    # Initialize variables to store the sum and product\n    total_sum = 0\n    total_product = 1\n\n    # Iterate through each number in the input list\n    for num in numbers:\n        # Add the current number to the sum\n        total_sum += num\n        \n        # Multiply the current number with the product\n        total_product *= num\n    \n    # Return a tuple with the calculated sum and product\n    return total_sum, total_product"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that contain given substring\n    \n    Args:\n    strings (List[str]): A list of strings\n    substring (str): The substring to search for\n    \n    Returns:\n    List[str]: A new list with strings containing the substring\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string\n    \n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"\n    Return n-th Fibonacci number.\n    \n    Args:\n    n (int): The position of the Fibonacci number to return\n    \n    Returns:\n    int: The n-th Fibonacci number\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n == 1:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13**2*5)\n    13\n    >>> largest_prime_factor(20**2*8)\n    5\n    \"\"\"\n    \n    # Initialize the largest prime factor to 1\n    largest_prime = 1\n    \n    # Start checking from 2, which is the smallest prime number\n    i = 2\n    \n    # Continue checking until the square root of n (since a larger factor would have already been found)\n    while i * i <= n:\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Update the largest prime factor if necessary\n            largest_prime = max(largest_prime, i)\n            \n            # Continue checking for other factors of n that are multiples of i\n            while n % i == 0:\n                n //= i\n    \n    # If n is a prime number greater than 1 (which we assumed), it will be the largest prime factor\n    if n > 1:\n        largest_prime = max(largest_prime, n)\n    \n    return largest_prime"}
{"task_id": "HumanEval/129", "completion": "from collections import deque\n\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with your current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct). You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j]. It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Args:\n        grid (List[List[int]]): A 2D grid with integers\n        k (int): The length of the path\n\n    Returns:\n        List[int]: The minimum path of length k\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    min_path = []\n    queue = deque([(grid[0][0], [(grid[0][0])])])\n\n    while queue:\n        val, path = queue.popleft()\n\n        if len(path) == k + 1:\n            # If the current path has length k+1, it means we've visited all cells\n            # in the grid. We need to find the minimum path among all paths of length k+1.\n            # Since there's only one minimum path (guaranteed by the problem statement),\n            # this will be our answer.\n            min_path = path[:-1]  # Remove the last cell (which is val)\n            break\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            r, c = divmod(val - 1, cols) + (dr, dc)\n\n            if 0 <= r < rows and 0 <= c < cols and val not in visited:\n                # If the new cell is within the grid boundaries and hasn't been visited,\n                # add it to the queue with its value and the updated path.\n                queue.append((grid[r][c], path + [grid[r][c]]))\n                visited.add(val)\n\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s: str) -> str:\n    \"\"\"\n    If s[i] is a letter, reverse its case from lower to upper or vice versa,\n    otherwise keep it as it is. If the string contains no letters, reverse the string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str: The modified string\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Check if the character is uppercase or lowercase and convert it to the opposite case\n            result += 'A' if char.islower() else 'a'\n        else:\n            # If the character is not a letter, keep it as it is\n            result += char\n    return result[::-1]"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence: str) -> str:\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Args:\n        sentence (str): A string representing a sentence\n\n    Returns:\n        str: A string containing words with prime lengths\n    \"\"\"\n    \n    def is_prime(n: int) -> bool:\n        \"\"\"Check if a number is prime\"\"\"\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    words = sentence.split()  # Split the sentence into words\n    result = \"\"  # Initialize an empty string to store the result\n    \n    for word in words:  # Iterate through each word\n        if is_prime(len(word)):  # Check if the length of the word is prime\n            result += word + \" \"  # If it's prime, add the word to the result\n    \n    return result.strip()  # Remove trailing space and return the result"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n    \n    Args:\n    s (str): The encoded string\n    \n    Returns:\n    str: The decoded string\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num: int) -> Tuple[int, int]:\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Args:\n        num (int): An integer\n\n    Returns:\n        Tuple[int, int]: A tuple with two integers representing the count of even and odd digits\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Convert the integer to a string to easily iterate over each digit\n    for digit in str(abs(num)):  # Use abs() to handle negative numbers\n        # Convert the digit back to an integer for comparison\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd and increment the corresponding count\n        if int_digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return even_count, odd_count"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n (int): A positive integer\n\n    Returns:\n        Tuple[int, int]: A tuple with two integers representing the count of even and odd palindromes respectively.\n    \"\"\"\n    result = [0, 0]\n    \n    for i in range(1, n + 1):\n        # Convert the number to a string to check if it's a palindrome\n        str_i = str(i)\n        \n        # Check if the string is equal to its reverse\n        if str_i == str_i[::-1]:\n            # If it's a palindrome, increment either even or odd count based on the last digit\n            result[int(str_i[-1] in '02468')] += 1\n    \n    return tuple(result)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Check if every opening bracket has a corresponding closing bracket.\n\n    Args:\n    brackets (str): A string of \"<\" and \">\"\n\n    Returns:\n    bool: True if every opening bracket has a corresponding closing bracket, False otherwise\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    \n    Args:\n    nums (List[int]): A list of integers\n    \n    Returns:\n    int: The minimum sum of any non-empty sub-array\n    \"\"\"\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n\n        if current_sum < 0:\n            current_sum = 0\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a: float, b: float, c: float) -> float:\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area of \n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \n    Args:\n    a (float): The length of one side of the triangle\n    b (float): The length of another side of the triangle\n    c (float): The length of the remaining side of the triangle\n    \n    Returns:\n    float: The area of the triangle if valid, otherwise -1\n    \"\"\"\n    \n    # Check if the three sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter of the triangle\n        s = (a + b + c) / 2\n        \n        # Use Heron's formula to calculate the area of the triangle\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        \n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # If the three sides do not form a valid triangle, return -1\n        return -1"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Separate groups of nested parentheses in a string into individual strings.\n\n    Args:\n    paren_string (str): A string containing multiple groups of nested parentheses.\n\n    Returns:\n    List[str]: A list of strings, each representing a group of balanced parentheses.\n    \"\"\"\n    result = []\n    current_group = ''\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n            current_group += char\n        elif char == ')':\n            depth -= 1\n            current_group += char\n            if depth == 0:  # balanced group found\n                result.append(current_group)\n                current_group = ''\n        else:\n            pass  # ignore non-parenthesis characters\n\n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    # Sort the list to make it easier to find three distinct elements that sum to zero\n    l.sort()\n    \n    # Iterate through each element in the list\n    for i in range(len(l)):\n        # Initialize two pointers, one at the start and one at the end of the remaining list\n        left = i + 1\n        right = len(l) - 1\n        \n        # While the two pointers haven't crossed each other\n        while left < right:\n            # Calculate the sum of the three elements\n            total = l[i] + l[left] + l[right]\n            \n            # If the sum is zero, return True\n            if total == 0:\n                return True\n            \n            # If the sum is less than zero, move the left pointer to the right\n            elif total < 0:\n                left += 1\n            \n            # If the sum is greater than zero, move the right pointer to the left\n            else:\n                right -= 1\n    \n    # If no three distinct elements that sum to zero are found, return False\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game: List[int], guess: List[int]) -> List[int]:\n    \"\"\"\n    Compare a list of game scores with corresponding guesses.\n\n    Args:\n    game (List[int]): A list of game scores.\n    guess (List[int]): A list of corresponding guesses.\n\n    Returns:\n    List[int]: A list of absolute differences between each score and its corresponding guess.\n    \"\"\"\n    return [abs(score - guess[i]) for i, score in enumerate(game)]"}
{"task_id": "HumanEval/87", "completion": "from typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Args:\n        lst (List[List[int]]): A list of lists containing integers\n        x (int): The integer to find in each sublist\n\n    Returns:\n        List[Tuple[int, int]]: A list of tuples representing the coordinates where x is found\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each sublist in the input list\n    for i, sub_list in enumerate(lst):\n        # Check if the integer x exists in the current sublist\n        if x in sub_list:\n            # If x is found, create a tuple with the row index and column indices where x was found\n            # The column indices are sorted in descending order\n            coordinates.append((i, sorted([j for j, val in enumerate(sub_list) if val == x], reverse=True)))\n    \n    # Sort the coordinates by row index in ascending order\n    coordinates.sort(key=lambda x: x[0])\n    \n    return coordinates\n\n# Test cases\nprint(get_row([\n       [1,2,3,4,5,6],\n       [1,2,3,4,1,6],\n       [1,2,3,4,5,1]\n     ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nprint(get_row([], 1) == [])\nprint(get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)])"}
