{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    Args:\n        a (int): The start of the range.\n        b (int): The end of the range.\n\n    Returns:\n        list: A list of even integers between a and b, inclusive.\n\n    Raises:\n        ValueError: If either a or b is not a positive integer.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both a and b must be integers.\")\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Both a and b must be positive.\")\n\n    # Generate even numbers between a and b\n    even_numbers = [i for i in range(a, b + 1) if i % 2 == 0]\n\n    return even_numbers"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate list of strings into a single string.\n\n    Args:\n        strings (List[str]): A list of strings to be concatenated.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n\n    # Check if the input is a list\n    if not isinstance(strings, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each string in the list\n    for s in strings:\n        # Check if each item in the list is a string\n        if not isinstance(s, str):\n            raise ValueError(\"All items in the list must be strings\")\n\n        # Concatenate the current string to the result\n        result += s\n\n    return result"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n\n    Args:\n        paren_string (str): A string containing multiple groups of nested parentheses separated by spaces.\n\n    Returns:\n        List[int]: A list of integers representing the maximum depth of nesting for each group of parentheses.\n\n    Raises:\n        ValueError: If the input string is empty or contains invalid characters.\n    \"\"\"\n\n    # Split the input string into individual groups of parentheses\n    groups = paren_string.split()\n\n    # Initialize an empty list to store the results\n    max_depths = []\n\n    # Iterate over each group of parentheses\n    for group in groups:\n        # Check if the group is valid (i.e., it contains only '(', ')', and spaces)\n        if not all(c in ' ()' for c in group):\n            raise ValueError(\"Invalid character in input string\")\n\n        # Initialize a stack to keep track of the current nesting depth\n        depth = 0\n\n        # Iterate over each character in the group\n        for char in group:\n            # If the character is an opening parenthesis, increment the depth\n            if char == '(':\n                depth += 1\n            # If the character is a closing parenthesis, decrement the depth\n            elif char == ')':\n                depth -= 1\n\n            # If the depth becomes negative, reset it to 0 (this can happen when there are more closing parentheses than opening ones)\n            if depth < 0:\n                depth = 0\n\n        # Append the maximum depth of nesting for this group to the result list\n        max_depths.append(depth)\n\n    return max_depths"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n    if not lst:  # edge case: empty list\n        return []\n\n    sorted_lst = sorted(lst)  # sort the list in ascending order\n    result = []  # initialize an empty list to store the final result\n\n    while sorted_lst:  # loop until all elements are processed\n        min_val = min(sorted_lst)  # find the minimum value\n        max_val = max(sorted_lst)  # find the maximum value of the remaining integers\n        result.append(min_val)  # append the minimum value to the result list\n        sorted_lst.remove(min_val)  # remove the minimum value from the sorted list\n        if sorted_lst:  # check if there are still elements in the list\n            result.append(max(sorted_lst))  # append the maximum value of the remaining integers\n            sorted_lst.remove(max(sorted_lst))  # remove the maximum value from the sorted list\n\n    return result  # return the final result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n\n    :param xs: coefficients of a polynomial\n    :return: coefficients of the derivative\n    \"\"\"\n    if not xs:\n        raise ValueError(\"Input list cannot be empty\")\n\n    # The derivative of x^n is n*x^(n-1)\n    # So we multiply each coefficient by its index (starting from 0) and subtract 1 from it\n    return [i * coeff for i, coeff in enumerate(xs[:-1])]"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n    \n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if len(l) < 2:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(l)):\n        if l[i] > l[i-1]:\n            increasing = True\n        elif l[i] < l[i-1]:\n            decreasing = True\n        else:\n            return False\n    \n    return increasing or decreasing"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"\n    Return maximum element in the list.\n\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:  # edge case: empty list\n        raise ValueError(\"List is empty\")\n    \n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        List[int]: The list with duplicates removed.\n\n    Example:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        int: The special factorial of the input number.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be a non-negative integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter given list of any python values only for integers.\n\n    Args:\n        values (List[Any]): A list containing any type of Python objects.\n\n    Returns:\n        List[int]: A new list containing only the integers from the input.\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers \n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Args:\n        lst (list): A list of numbers\n    \n    Returns:\n        int: The sum of squares of the odd numbers in the list\n    \"\"\"\n    # Initialize a variable to store the sum of squares of odd numbers\n    total = 0\n    \n    # Iterate over each number in the list\n    for num in lst:\n        # Check if the number is an integer and not negative\n        if isinstance(num, int) and num >= 0:\n            # Check if the number is odd\n            if num % 2 != 0:\n                # Add the square of the odd number to the total\n                total += num ** 2\n    \n    # Return the total sum of squares of odd numbers\n    return total"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Count numbers with sum of digits > 0.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The number of elements which has a sum of digits > 0.\n    \"\"\"\n    def sum_of_digits(n):\n        \"\"\"Calculate the sum of signed digits in a number.\"\"\"\n        return sum(int(d) if d else -int(d[1:]) for d in str(abs(n)))\n\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n\n    return count"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n    \n    Returns:\n        Tuple[int, int]: A tuple containing the sum and product of the input list.\n    \"\"\"\n    \n    # Initialize sum and product to 0 and 1 respectively\n    total_sum = 0\n    total_product = 1\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # Add the current number to the total sum\n        total_sum += num\n        \n        # Multiply the current number with the total product\n        total_product *= num\n    \n    # Return a tuple containing the total sum and total product\n    return total_sum, total_product\n\n# Example usage:\nprint(sum_product([]))  # Output: (0, 1)\nprint(sum_product([1, 2, 3, 4]))  # Output: (10, 24)"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that contain given substring.\n\n    Args:\n        strings (List[str]): The list of strings to be filtered.\n        substring (str): The substring to search for in the strings.\n\n    Returns:\n        List[str]: A new list containing only the strings from `strings` that contain `substring`.\n    \"\"\"\n    # Initialize an empty list to store the filtered strings\n    filtered_strings = []\n\n    # Iterate over each string in the input list\n    for string in strings:\n        # Check if the substring is present in the current string\n        if substring in string:\n            # If it's present, add the string to the filtered list\n            filtered_strings.append(string)\n\n    # Return the filtered list of strings\n    return filtered_strings"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"Return length of given string\"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    \"\"\"\n    Return n-th Fibonacci number.\n\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    # Handle edge case where n is less than or equal to 0\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Handle edge case where n is 1 (base case of Fibonacci sequence)\n    elif n == 1:\n        return 1\n\n    # Initialize variables for the first two numbers in the Fibonacci sequence\n    a, b = 1, 1\n\n    # Calculate the nth Fibonacci number using a loop\n    for _ in range(2, n):\n        # Update 'a' and 'b' to be the last two numbers in the sequence\n        a, b = b, a + b\n\n    # Return the nth Fibonacci number (which is now stored in 'b')\n    return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    \n    Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13**195)\n    29\n    >>> largest_prime_factor(20**48)\n    2\n    \"\"\"\n\n    # Edge case: if n is less than or equal to 1, return None (or any other value that makes sense in your context)\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n\n    # Start from the largest possible factor (which is sqrt(n))\n    max_factor = int(n ** 0.5) + 1\n\n    # Iterate over all numbers from max_factor down to 2\n    for i in range(max_factor, 1, -1):\n        # Check if i is a factor of n\n        while n % i == 0:\n            # If it's a prime factor (i.e., it has no other factors), return it\n            if all(j % i != 0 for j in range(2, int(i ** 0.5) + 1)):\n                return i\n            # Otherwise, divide n by i and continue checking the remaining value\n            n //= i\n\n    # If we've reached this point, it means that n itself is a prime number (since all its factors have been checked)\n    return n"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with your current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct). You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j]. It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    # Get the number of rows and columns in the grid\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n\n    # Initialize a dictionary to store the minimum path for each cell\n    min_paths = {}\n\n    # Define the possible movements (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(row, col, k):\n        # If we've reached the target length, return the current path\n        if k == 0:\n            return [grid[row][col]]\n\n        # Initialize a list to store the minimum path for this cell\n        min_path = None\n\n        # Explore all possible movements from this cell\n        for dr, dc in movements:\n            nr, nc = row + dr, col + dc\n\n            # Check if we're within the grid boundaries\n            if 0 <= nr < num_rows and 0 <= nc < num_cols:\n                # Get the minimum path for the new cell\n                path = dfs(nr, nc, k - 1)\n\n                # If this is the first path or it's lexicographically smaller than the current min_path\n                if min_path is None or (path + [grid[row][col]]) < (min_path + [grid[nr][nc]]):\n                    min_path = path + [grid[row][col]]\n\n        # Store the minimum path for this cell and return it\n        min_paths[(row, col)] = min_path\n        return min_path\n\n    # Start the DFS from each cell in the grid\n    for row in range(num_rows):\n        for col in range(num_cols):\n            dfs(row, col, k)\n\n    # Find the minimum path among all cells and return it\n    min_path = None\n    for (row, col), path in min_paths.items():\n        if min_path is None or path < min_path:\n            min_path = path\n\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    This function takes a string s as input and returns the modified string.\n    \n    If the string contains letters, it reverses their case from lower to upper or vice versa.\n    If the string contains no letters, it reverses the string.\n    \n    Parameters:\n    s (str): The input string\n    \n    Returns:\n    str: The modified string\n    \"\"\"\n    result = \"\"\n    is_reversed = False  # Flag to track if the string needs to be reversed\n\n    for char in s:\n        # Check if the character is a letter\n        if char.isalpha():\n            # If it's a letter, toggle its case\n            result += char.swapcase()\n        else:\n            # If it's not a letter, add it as it is\n            result += char\n            # Set the flag to True so we can reverse the string at the end\n            is_reversed = True\n\n    # If the string contains no letters, reverse the string\n    if is_reversed:\n        return result[::-1]\n    else:\n        return result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing the words from the original sentence,\n    whose lengths are prime numbers.\n\n    Args:\n        sentence (str): A string representing a sentence.\n\n    Returns:\n        str: A string containing the words with prime lengths.\n    \"\"\"\n\n    # Split the sentence into individual words\n    words = sentence.split()\n\n    # Initialize an empty list to store the words with prime lengths\n    prime_words = []\n\n    # Define a helper function to check if a number is prime\n    def is_prime(n):\n        \"\"\"\n        Checks if a number is prime.\n\n        Args:\n            n (int): The number to check.\n\n        Returns:\n            bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    # Iterate over each word and check its length\n    for word in words:\n        # Check if the word's length is prime\n        if is_prime(len(word)):\n            # If it's prime, add it to the list of prime words\n            prime_words.append(word)\n\n    # Join the prime words back into a string separated by spaces\n    result = ' '.join(prime_words)\n\n    return result"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n\n    :param s: The input string to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n\n    :param s: The input string to be decoded.\n    :return: The decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        tuple: A tuple containing two integers representing the count of even and odd digits.\n    \"\"\"\n\n    # Handle edge case where num is 0\n    if num == 0:\n        return (1, 0)  # There's one digit '0' which is even\n\n    # Convert the integer to a string to easily iterate over each digit\n    num_str = str(abs(num))  # Use abs() to handle negative numbers\n\n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n\n    # Iterate over each character (digit) in the string representation of num\n    for digit in num_str:\n        # Convert the character back to an integer\n        int_digit = int(digit)\n\n        # Check if the digit is even or odd and increment the corresponding counter\n        if int_digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Return a tuple containing the counts of even and odd digits\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n (int): A positive integer\n\n    Returns:\n        tuple: A tuple containing the count of even and odd integer palindromes\n\n    Raises:\n        ValueError: If input is not a positive integer\n    \"\"\"\n    \n    # Check if input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    # Initialize counters for even and odd palindromes\n    even_pal = 0\n    odd_pal = 0\n\n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Convert number to string to check if it's a palindrome\n        str_i = str(i)\n        \n        # Check if the number is a palindrome\n        if str_i == str_i[::-1]:\n            # If the number is even, increment the even counter\n            if i % 2 == 0:\n                even_pal += 1\n            # Otherwise, increment the odd counter\n            else:\n                odd_pal += 1\n\n    # Return a tuple with the counts of even and odd palindromes\n    return (even_pal, odd_pal)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Checks if every opening bracket has a corresponding closing bracket.\n\n    Args:\n        brackets (str): A string containing only \"<\" and \">\" characters.\n\n    Returns:\n        bool: True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n\n    # Initialize an empty stack to store the opening brackets\n    stack = []\n\n    # Iterate over each character in the input string\n    for bracket in brackets:\n        # If the current character is an opening bracket, push it onto the stack\n        if bracket == \"<\":\n            stack.append(bracket)\n        # If the current character is a closing bracket, check if the stack is empty or its top element doesn't match\n        elif bracket == \">\":\n            if not stack or (stack and stack.pop() != \"<\"):\n                return False\n\n    # After iterating over the entire string, if the stack is empty, it means every opening bracket had a corresponding closing bracket\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array \n    of nums.\n    \n    Args:\n        nums (list): A list of integers.\n    \n    Returns:\n        int: The minimum sum of any non-empty sub-array of nums.\n    \"\"\"\n    # Handle edge case where input is empty\n    if not nums:\n        return 0\n    \n    # Initialize minimum sum and current window sum to the first element\n    min_sum = max_sum = current_sum = nums[0]\n    \n    # Iterate through the rest of the array\n    for num in nums[1:]:\n        # Update current window sum\n        current_sum = min(num, current_sum + num)\n        \n        # Update minimum sum if necessary\n        min_sum = min(min_sum, current_sum)\n        \n        # Update maximum window sum (not used but included for completeness)\n        max_sum = max(max_sum, current_sum)\n    \n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle.\n    Return the area of the triangle rounded to 2 decimal points \n    if the three sides form a valid triangle. Otherwise return -1.\n\n    Args:\n        a (float): The length of side a\n        b (float): The length of side b\n        c (float): The length of side c\n\n    Returns:\n        float: The area of the triangle or -1 if it's not a valid triangle\n    \"\"\"\n    \n    # Check if the three sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1  # Return -1 if it's not a valid triangle\n\n    # Calculate the semi-perimeter of the triangle\n    s = (a + b + c) / 2\n    \n    # Use Heron's formula to calculate the area of the triangle\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    # Round the area to 2 decimal points and return it\n    return round(area, 2)"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Separate groups of nested parentheses from a given string.\n\n    Args:\n        paren_string (str): A string containing multiple groups of nested parentheses.\n\n    Returns:\n        List[str]: A list of strings, each representing a group of balanced parentheses.\n    \"\"\"\n\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n\n    # Initialize an empty list to store the separated groups\n    groups = []\n\n    # Initialize an empty stack to keep track of opening parentheses\n    stack = []\n\n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If the character is an opening parenthesis, push it onto the stack\n        if char == \"(\":\n            stack.append(char)\n        # If the character is a closing parenthesis, pop the corresponding opening parenthesis from the stack\n        elif char == \")\":\n            if stack:  # Check if the stack is not empty before popping\n                stack.pop()\n            else:\n                # If there's no matching opening parenthesis, it means we've encountered an unbalanced group\n                # In this case, we'll start a new group by pushing an opening parenthesis onto the stack\n                stack.append(\"(\")\n        # If the character is neither an opening nor closing parenthesis, ignore it\n\n    # After iterating over all characters, if there are any remaining opening parentheses in the stack,\n    # it means they don't have matching closing parentheses and should be ignored\n    while stack:\n        stack.pop()\n\n    # Now that we've processed all parentheses, let's construct the groups of balanced parentheses\n    group = \"\"\n    for char in paren_string:\n        if char == \"(\":\n            group += char\n        elif char == \")\":\n            group += char\n            groups.append(group)\n            group = \"\"\n\n    return groups"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    This function checks if there are three distinct elements in a given list that sum to zero.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        bool: True if there are three distinct elements that sum to zero, False otherwise.\n    \"\"\"\n\n    # Edge case: If the list has less than 3 elements, it's impossible for three distinct elements to sum to zero\n    if len(l) < 3:\n        return False\n\n    # Sort the list in ascending order\n    l.sort()\n\n    # Iterate over the list with three nested loops to check all possible combinations of three numbers\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                # Check if the current combination sums to zero and all elements are distinct\n                if l[i] + l[j] + l[k] == 0 and l[i] != l[j] and l[i] != l[k] and l[j] != l[k]:\n                    return True\n\n    # If no such combination is found, return False\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(scores, guesses):\n    \"\"\"\n    Compare a list of scores with corresponding guesses.\n\n    Args:\n        scores (list): A list of scores.\n        guesses (list): A list of guesses corresponding to the scores.\n\n    Returns:\n        list: A list of absolute differences between each guess and score.\n\n    Raises:\n        ValueError: If the lengths of scores and guesses do not match.\n    \"\"\"\n    if len(scores) != len(guesses):\n        raise ValueError(\"Scores and guesses must be of equal length\")\n\n    return [abs(score - guess) for score, guess in zip(scores, guesses)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([...], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the input list\n    for i, row in enumerate(lst):\n        # Check if x is present in the current row\n        if x in row:\n            # If x is found, iterate over the row from right to left (descending order)\n            for j in range(len(row) - 1, -1, -1):\n                # Check if the current element matches x\n                if row[j] == x:\n                    # Append the coordinate (row index, column index) to the list\n                    coordinates.append((i, j))\n    \n    # Sort the coordinates by row index in ascending order and then by column index in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    \n    return coordinates"}
