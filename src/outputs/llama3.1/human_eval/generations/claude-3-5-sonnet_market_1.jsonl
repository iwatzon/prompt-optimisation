{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n\n    Args:\n        a (int): The start of the range.\n        b (int): The end of the range.\n\n    Returns:\n        list: A list of even integers between a and b, in ascending order.\n    \"\"\"\n    \n    # Check if inputs are positive integers\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Inputs must be integers.\")\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Inputs must be positive.\")\n\n    # Generate even digits between a and b\n    even_digits = [i for i in range(a, b + 1) if i % 2 == 0]\n    \n    return even_digits"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string.\n\n    Args:\n        strings (List[str]): A list of strings to be concatenated.\n\n    Returns:\n        str: The concatenated string.\n\n    Raises:\n        TypeError: If the input is not a list of strings.\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(strings, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Check if all elements in the list are strings\n    if not all(isinstance(s, str) for s in strings):\n        raise TypeError(\"All elements in the list must be strings\")\n\n    # Use join to concatenate the strings\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    \n    # Split the input string into groups by spaces\n    groups = paren_string.split()\n    \n    # Initialize an empty list to store the deepest level of nesting for each group\n    deepest_levels = []\n    \n    # Iterate over each group\n    for group in groups:\n        # Initialize a counter to track the current level of nesting\n        level = 0\n        \n        # Initialize a flag to indicate whether we are currently inside parentheses\n        inside_parens = False\n        \n        # Iterate over each character in the group\n        for char in group:\n            # If the character is an opening parenthesis, increment the level and set the flag\n            if char == '(':\n                level += 1\n                inside_parens = True\n            \n            # If the character is a closing parenthesis, decrement the level and reset the flag\n            elif char == ')':\n                level -= 1\n                inside_parens = False\n            \n            # If we are not inside parentheses, reset the level and flag\n            if not inside_parens:\n                level = 0\n        \n        # Append the deepest level of nesting for the current group to the list\n        deepest_levels.append(level)\n    \n    # Return the list of deepest levels\n    return deepest_levels"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    \n    # Check if the list is empty\n    if not lst:\n        return []\n\n    # Initialize result list with minimum value from the input list\n    result = [min(lst)]\n    \n    # Remove the minimum value from the input list\n    lst.remove(min(lst))\n    \n    # Alternate between maximum and minimum values from the remaining list\n    while lst:\n        # Append maximum value to the result list\n        result.append(max(lst))\n        \n        # If there's more than one element left, remove the maximum value\n        if len(lst) > 1:\n            lst.remove(max(lst))\n            \n        # If there's only one element left, append it and break the loop\n        else:\n            result.append(lst[0])\n            break\n    \n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n        xs[0] + xs[1] * x + xs[2] * x^2 + ....\n        Return derivative of this polynomial in the same form.\n        >>> derivative([3, 1, 2, 4, 5])\n        [1, 4, 12, 20]\n        >>> derivative([1, 2, 3])\n        [2, 6]\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(xs, list):\n        raise TypeError(\"Input must be a list of coefficients.\")\n        \n    # Check if list contains at least one element (i.e., the constant term)\n    if len(xs) < 1:\n        raise ValueError(\"List must contain at least one coefficient.\")\n    \n    # Initialize an empty list to store the derivative's coefficients\n    deriv = [0] * (len(xs) - 1)\n    \n    # Calculate the derivative's coefficients using the power rule of differentiation\n    for i in range(len(deriv)):\n        # The power rule states that if f(x) = x^n, then f'(x) = n*x^(n-1)\n        deriv[i] = (len(xs) - 1 - i) * xs[i + 1]\n    \n    return deriv"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\"\"\"\n    \n    # Check if the list has less than 2 elements, in which case it's considered monotonic\n    if len(l) < 2:\n        return True\n    \n    # Initialize a flag to indicate whether the list is increasing or not\n    is_increasing = l[0] <= l[-1]\n    \n    # Iterate over the list from the second element to the second last element\n    for i in range(1, len(l) - 1):\n        # If we find an element that's out of order with its neighbors, return False\n        if (is_increasing and l[i] > l[i + 1]) or (not is_increasing and l[i] < l[i + 1]):\n            return False\n    \n    # If we've iterated over the entire list without returning False, it's monotonic\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    \n    # Check if the list is empty\n    if not l:\n        raise ValueError(\"List cannot be empty\")\n        \n    # Use built-in max function to find the maximum element\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    \n    # Create an empty dictionary to store unique numbers and their counts\n    num_counts = {}\n    \n    # Iterate over the list of numbers\n    for num in numbers:\n        # If the number is already in the dictionary, increment its count\n        if num in num_counts:\n            num_counts[num] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            num_counts[num] = 1\n    \n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate over the original list again\n    for num in numbers:\n        # If the number's count is 1, add it to the result list\n        if num_counts[num] == 1:\n            result.append(num)\n    \n    return result"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n    \"\"\"\n    \n    # Check if input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n        \n    # Initialize result with 1 (multiplicative identity)\n    result = 1\n    \n    # Calculate Brazilian factorial using a loop\n    for i in range(1, n + 1):\n        # Multiply current number's factorial to the result\n        result *= math.factorial(i)\n    \n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    \n    Args:\n        values (List[Any]): A list containing any type of Python objects.\n    \n    Returns:\n        List[int]: A list containing only the integers from the input list.\n    \n    Examples:\n        >>> filter_integers(['a', 3.14, 5])\n        [5]\n        >>> filter_integers([1, 2, 3, 'abc', {}, []])\n        [1, 2, 3]\n    \"\"\"\n    # Use a list comprehension to create a new list containing only integers\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Parameters:\n    lst (list): A list of numbers\n    \n    Returns:\n    int: The sum of squares of the odd numbers in the list\n    \n    Examples:\n    double_the_difference([1, 3, 2, 0]) == 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    \n    # Initialize sum to 0\n    total = 0\n    \n    # Iterate over each number in the list\n    for num in lst:\n        # Check if the number is odd and an integer (not negative)\n        if isinstance(num, int) and num >= 0 and num % 2 != 0:\n            # Add the square of the odd number to the total\n            total += num ** 2\n    \n    # Return the total sum\n    return total"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Count numbers with sum of digits > 0 in an array.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The number of elements which has a sum of digits > 0.\n    \"\"\"\n    def sum_of_digits(n):\n        # Calculate the sum of digits for a given number\n        return sum(int(digit) for digit in str(abs(n)))\n\n    count = 0\n    for num in arr:\n        try:\n            # Check if the number has a sum of digits > 0\n            if sum_of_digits(num) > 0:\n                count += 1\n        except ValueError:\n            # Handle invalid input (e.g., non-integer)\n            pass\n\n    return count"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        Tuple[int, int]: A tuple containing the sum and product of the input list.\n\n    Examples:\n        >>> sum_product([])\n        (0, 1)\n        >>> sum_product([1, 2, 3, 4])\n        (10, 24)\n    \"\"\"\n    \n    # Initialize sum and product to 0 and 1 respectively\n    total_sum = 0\n    total_product = 1\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # Add the current number to the sum\n        total_sum += num\n        \n        # Multiply the current number with the product\n        total_product *= num\n    \n    # Return a tuple containing the sum and product\n    return total_sum, total_product"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    \n    Args:\n        strings (List[str]): The list of strings to be filtered.\n        substring (str): The substring to search for in the strings.\n    \n    Returns:\n        List[str]: A new list containing only the strings from the input list that have the substring.\n    \n    Raises:\n        TypeError: If either of the inputs is not a list or string respectively.\n    \"\"\"\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise TypeError(\"Input 'strings' must be a list of strings.\")\n    if not isinstance(substring, str):\n        raise TypeError(\"Input 'substring' must be a string.\")\n\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"Return length of given string.\n\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    # Check if input is a string (not necessary in Python, but added for clarity)\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Use built-in len function to get length of string\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    \n    # Check for negative input and return 0 in that case\n    if n < 1:\n        return 0\n    \n    # Initialize base cases\n    a, b = 1, 1\n    \n    # Calculate Fibonacci numbers up to the nth number\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    # Return the nth Fibonacci number\n    return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    \n    # Start from the smallest possible prime factor (2) and go up to sqrt(n)\n    for i in range(2, int(n ** 0.5) + 1):\n        # If i is a factor of n, check if it's a prime\n        while n % i == 0:\n            # If i is a prime, return it as the largest prime factor\n            is_prime = True\n            for j in range(2, int(i ** 0.5) + 1):\n                if i % j == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                n //= i  # Divide n by i to remove this prime factor\n                return i\n    \n    # If no prime factors are found (i.e., n itself is a prime), return n\n    return n"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct). You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j]. \n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n    \n    # Get the number of rows and columns in the grid\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n    \n    # Initialize a dictionary to store the minimum path for each cell\n    min_paths = {}\n    \n    # Define a helper function to perform DFS\n    def dfs(row, col, k):\n        # If we've reached the target length, return the current path\n        if k == 0:\n            return [grid[row-1][col-1]]\n        \n        # Initialize the minimum path for this cell\n        min_path = None\n        \n        # Check all four directions (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = row + dr, col + dc\n            \n            # If the new cell is within bounds\n            if 0 <= nr < num_rows and 0 <= nc < num_cols:\n                # Get the minimum path for the new cell\n                path = min_paths.get((nr, nc), [])\n                \n                # If this path is shorter than the current minimum path, update it\n                if not min_path or len(path) + k < len(min_path):\n                    min_path = path + dfs(nr, nc, k-1)\n        \n        # Store the minimum path for this cell\n        min_paths[(row, col)] = min_path\n        \n        # Return the minimum path for this cell\n        return min_path\n    \n    # Find the minimum path starting from each cell and with length k\n    min_path = None\n    for row in range(1, num_rows+1):\n        for col in range(1, num_cols+1):\n            path = dfs(row, col, k)\n            \n            # If this path is shorter than the current minimum path, update it\n            if not min_path or len(path) < len(min_path):\n                min_path = path\n    \n    # Return the minimum path\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    This function takes a string s and returns the modified string.\n    If the string contains letters, it reverses their case from lower to upper or vice versa.\n    If the string contains no letters, it reverses the string.\n    \n    Parameters:\n    s (str): The input string\n    \n    Returns:\n    str: The modified string\n    \"\"\"\n    # Initialize an empty list to store the characters of the modified string\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is a letter\n        if char.isalpha():\n            # If it's a letter, reverse its case and add it to the result list\n            result.append(char.swapcase())\n        else:\n            # If it's not a letter, just add it to the result list as it is\n            result.append(char)\n    \n    # Join the characters in the result list into a string and return it\n    return ''.join(result)\n\n# Test cases\nprint(solve(\"12\"))  # Output: \"21\"\nprint(solve(\"ab\"))  # Output: \"Ab\"\nprint(solve(\"#a@C\"))  # Output: \"#A@c\""}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Initialize an empty list to store prime length words\n    prime_length_words = []\n\n    # Iterate over each word in the sentence\n    for word in words:\n        # Check if the word's length is a prime number\n        if is_prime(len(word)):\n            # If it's prime, add it to the list of prime length words\n            prime_length_words.append(word)\n\n    # Join the prime length words back into a string separated by spaces\n    result = ' '.join(prime_length_words)\n\n    return result\n\n\ndef is_prime(n):\n    \"\"\"\n    Helper function to check if a number is prime.\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    \"\"\"\n    # Check if n is less than or equal to 1 (not prime)\n    if n <= 1:\n        return False\n\n    # Check if n is 2 (smallest prime)\n    if n == 2:\n        return True\n\n    # Check if n is divisible by any number up to its square root\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    # If no divisors found, n is prime\n    return True\n\n\n# Test the function\nprint(words_in_sentence(\"This is a test\"))  # Output: \"is\"\nprint(words_in_sentence(\"lets go for swimming\"))  # Output: \"go for\""}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):  # type: str -> str\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n\n    :param s: The input string to be encoded.\n    :return: The encoded string.\n    \"\"\"\n    result = \"\"\n    for ch in s:\n        if 'a' <= ch <= 'z':  # Check if char is a lowercase letter\n            shifted_char = chr((ord(ch) - ord('a') + 5) % 26 + ord('a'))  # Shift by 5, wrap around alphabet if necessary\n            result += shifted_char\n        elif 'A' <= ch <= 'Z':  # Check if char is an uppercase letter\n            shifted_char = chr((ord(ch) - ord('A') + 5) % 26 + ord('A'))  # Shift by 5, wrap around alphabet if necessary\n            result += shifted_char\n        else:  # If char is not a letter, leave it as is\n            result += ch\n    return result\n\ndef decode_shift(s: str):  # type: str -> str\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n\n    :param s: The input string to be decoded.\n    :return: The decoded string.\n    \"\"\"\n    result = \"\"\n    for ch in s:\n        if 'a' <= ch <= 'z':  # Check if char is a lowercase letter\n            shifted_char = chr((ord(ch) - ord('a') - 5) % 26 + ord('a'))  # Shift by -5, wrap around alphabet if necessary\n            result += shifted_char\n        elif 'A' <= ch <= 'Z':  # Check if char is an uppercase letter\n            shifted_char = chr((ord(ch) - ord('A') - 5) % 26 + ord('A'))  # Shift by -5, wrap around alphabet if necessary\n            result += shifted_char\n        else:  # If char is not a letter, leave it as is\n            result += ch\n    return result"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        tuple: A tuple containing two integers. The first integer is the count of even digits,\n               and the second integer is the count of odd digits.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (2, 1)\n    \"\"\"\n    \n    # Check if input is an integer\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer.\")\n        \n    # Convert absolute value of num to string for easy iteration over digits\n    num_str = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate over each digit in the number\n    for digit in num_str:\n        # Convert current digit back to integer for comparison\n        int_digit = int(digit)\n        \n        # Check if digit is even or odd\n        if int_digit % 2 == 0:\n            # If even, increment even_count\n            even_count += 1\n        else:\n            # If odd, increment odd_count\n            odd_count += 1\n            \n    # Return a tuple containing the counts of even and odd digits\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        tuple: A tuple containing the count of even and odd integer palindromes in the range 1 to n.\n\n    Examples:\n        >>> even_odd_palindrome(3)\n        (1, 2)\n        >>> even_odd_palindrome(12)\n        (4, 6)\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    \n    # Initialize counters for even and odd palindromes\n    even_pal = 0\n    odd_pal = 0\n    \n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Convert the number to a string to check if it's a palindrome\n        str_i = str(i)\n        \n        # Check if the number is a palindrome\n        if str_i == str_i[::-1]:\n            # If the number is even, increment the even_pal counter\n            if i % 2 == 0:\n                even_pal += 1\n            # Otherwise, increment the odd_pal counter\n            else:\n                odd_pal += 1\n                \n    # Return a tuple containing the counts of even and odd palindromes\n    return (even_pal, odd_pal)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    \"\"\"Return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    \n    # Initialize counters for opening and closing brackets\n    open_count = 0\n    close_count = 0\n    \n    # Iterate over the string of brackets\n    for bracket in brackets:\n        # If we encounter an opening bracket, increment the counter\n        if bracket == \"<\":\n            open_count += 1\n        # If we encounter a closing bracket, increment the counter\n        elif bracket == \">\":\n            close_count += 1\n    \n    # Check if the counts are equal; if not, return False\n    if open_count != close_count:\n        return False\n    \n    # If we've reached this point, all brackets were correctly paired\n    return True"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array \n    of nums.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The minimum sum of any non-empty sub-array of nums.\n\n    Raises:\n        ValueError: If the input is not a list or if the list contains non-integer values.\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(nums, list):\n        raise ValueError(\"Input must be a list\")\n        \n    # Check if all elements in the list are integers\n    if not all(isinstance(num, int) for num in nums):\n        raise ValueError(\"All elements in the list must be integers\")\n\n    # Initialize minimum sum and current window sum to the first element of the list\n    min_sum = max_sum = nums[0]\n    \n    # Iterate over the rest of the list\n    for num in nums[1:]:\n        \n        # Update current window sum\n        max_sum = max(num, max_sum + num)\n        \n        # Update minimum sum\n        min_sum = min(min_sum, max_sum)\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Check if three sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter of the triangle\n        s = (a + b + c) / 2\n        \n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        \n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    \n    # If three sides do not form a valid triangle, return -1\n    else:\n        return -1"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Input to this function is a string containing multiple groups of nested parentheses.\n    Your goal is to separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    \n    # Remove leading/trailing spaces from the input string\n    paren_string = paren_string.strip()\n    \n    # Initialize an empty list to store the separated groups\n    groups: List[str] = []\n    \n    # Initialize a counter to keep track of the current group's depth\n    depth: int = 0\n    \n    # Initialize an empty string to build the current group\n    group: str = ''\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If the character is an open parenthesis, increment the depth and add it to the group\n        if char == '(':\n            depth += 1\n            group += char\n        \n        # If the character is a close parenthesis, decrement the depth and add it to the group\n        elif char == ')':\n            depth -= 1\n            group += char\n            \n            # If the depth is zero, it means we've reached the end of a group, so add it to the list and reset the group\n            if depth == 0:\n                groups.append(group)\n                group = ''\n    \n    # Return the list of separated groups\n    return groups"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        bool: Whether there are three distinct elements in the list that sum to zero.\n\n    Examples:\n        >>> triples_sum_to_zero([1, 3, 5, 0])\n        False\n        >>> triples_sum_to_zero([1, 3, -2, 1])\n        True\n        >>> triples_sum_to_zero([1, 2, 3, 7])\n        False\n        >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n        True\n        >>> triples_sum_to_zero([1])\n        False\n    \"\"\"\n    \n    # Check if the list has at least three elements\n    if len(l) < 3:\n        return False\n    \n    # Sort the list in ascending order\n    l.sort()\n    \n    # Iterate over the list with three pointers\n    for i in range(len(l) - 2):\n        \n        # Initialize two pointers, one starting from the next element of the current pointer and one at the end of the list\n        left = i + 1\n        right = len(l) - 1\n        \n        # Move the pointers based on the sum of the elements at the current pointers\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            \n            # If the sum is zero, return True\n            if total == 0:\n                return True\n            \n            # If the sum is less than zero, move the left pointer to the right\n            elif total < 0:\n                left += 1\n            \n            # If the sum is greater than zero, move the right pointer to the left\n            else:\n                right -= 1\n    \n    # If no three elements that sum to zero are found, return False\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    This function compares a person's guesses with actual game scores.\n\n    Args:\n        game (list): A list of actual game scores.\n        guess (list): A list of guessed scores corresponding to the games in 'game'.\n\n    Returns:\n        list: A list where each element is the absolute difference between the guess and the score for that game. If the guess was correct, the value is 0.\n\n    Raises:\n        ValueError: If the lengths of 'game' and 'guess' do not match.\n    \"\"\"\n    \n    # Check if both lists have the same length\n    if len(game) != len(guess):\n        raise ValueError(\"Both lists must be of equal length.\")\n        \n    # Use list comprehension to create a new list with the absolute differences\n    return [abs(g - g_) for g, g_ in zip(game, guess)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([ \n       [1,2,3,4,5,6], \n       [1,2,3,4,1,6], \n       [1,2,3,4,5,1] \n     ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \n    :param lst: A list of lists\n    :param x: An integer to search for in the list\n    :return: A list of tuples representing coordinates (row, column)\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates\n    coords = []\n    \n    # Iterate over each row in the list\n    for i, row in enumerate(lst):\n        # Check if x is in the current row\n        if x in row:\n            # If x is found, iterate over the row in reverse order (to get descending column order)\n            for j in range(len(row) - 1, -1, -1):\n                # Check if the current element is equal to x\n                if row[j] == x:\n                    # If it's equal, append the coordinate (row index, column index) to the list\n                    coords.append((i, j))\n    \n    # Return the list of coordinates\n    return coords"}
