{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    \n    # Generate a list of integers from a to b\n    numbers = range(a, b + 1)\n    \n    # Filter out only the even numbers\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    \n    # Sort the list in ascending order\n    sorted_even_numbers = sorted(even_numbers)\n    \n    return sorted_even_numbers"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string\n    \n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \n    \"\"\"\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def max_nesting(s: str) -> int:\n        \"\"\"Return the deepest level of nesting for a single group of parentheses.\"\"\"\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif c == ')':\n                depth -= 1\n        return max_depth\n\n    groups = paren_string.split()\n    return [max_nesting(group) for group in groups]"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    \n    # If the list is empty, return it as it's already sorted\n    if not lst:\n        return []\n\n    result = []\n    min_val = max_val = lst[0]\n\n    for num in lst[1:]:\n        # Update minimum and maximum values\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n\n    # Add the first element (minimum) to the result list\n    result.append(min_val)\n\n    # Alternate between adding minimum and maximum values to the result list\n    while lst:\n        # Remove minimum value from the list\n        if min_val in lst:\n            lst.remove(min_val)\n        \n        # If there are still elements left, add maximum value to the result list\n        if lst:\n            max_val = max(lst)\n            result.append(max_val)\n            \n            # Remove maximum value from the list\n            lst.remove(max_val)\n\n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if len(xs) == 0:\n        return []\n    elif len(xs) == 1:\n        return []\n    else:\n        return [i * xs[i] for i in range(1, len(xs))]"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    \n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    return all(l[i] <= l[i+1] for i in range(len(l)-1))"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n     >>> max_element([1, 2, 3])\n    3\n     >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n     \"\"\"\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    \n    # Create an empty dictionary to store unique numbers and their counts\n    num_counts = {}\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # If the number is already in the dictionary, increment its count\n        if num in num_counts:\n            num_counts[num] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            num_counts[num] = 1\n    \n    # Create an empty list to store unique numbers\n    unique_numbers = []\n    \n    # Iterate over each number and its count in the dictionary\n    for num, count in num_counts.items():\n        # If the count is 1, add the number to the list of unique numbers\n        if count == 1:\n            unique_numbers.append(num)\n    \n    # Return the list of unique numbers\n    return unique_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 2, 4]\nprint(remove_duplicates(numbers))  # Output: [1, 3, 4]"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n        \n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    \n    # Initialize sum to 0\n    total = 0\n    \n    # Iterate over each number in the list\n    for num in lst:\n        # Check if the number is odd and an integer (i.e., not negative)\n        if num % 2 != 0 and isinstance(num, int):\n            # If it's odd, add its square to the total\n            total += num ** 2\n    \n    # Return the total sum of squares\n    return total"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    \n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    return sum(1 for num in arr if sum_of_digits(num) > 0)"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n\n    \"\"\"\n    total_sum = 0\n    total_product = 1\n    \n    for num in numbers:\n        total_sum += num\n        total_product *= num\n        \n    return total_sum, total_product"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    \n    # Base cases for the recursion\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    \n    # Recursive case\n    else:\n        return fib(n-1) + fib(n-2)"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    \n    def is_prime(num: int) -> bool:\n        \"\"\"Check if num is a prime number.\"\"\"\n        \n        if num < 2:\n            return False\n        \n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        \n        return True\n    \n    # Start from the largest possible factor (n itself)\n    for i in range(n, 1, -1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # If i is a prime number and it's a factor of n, then it's the largest prime factor\n            if is_prime(i):\n                return i\n    \n    # If no prime factors are found, return 1 (this should not happen according to the problem statement)\n    return 1"}
{"task_id": "HumanEval/129", "completion": "from collections import deque\n\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct). You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j]. It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    min_path = []\n\n    # Define the possible movements (up, down, left, right)\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def bfs(start_row, start_col):\n        queue = deque([(start_row, start_col, [grid[start_row][start_col]])])\n        visited[start_row][start_col] = True\n\n        while queue:\n            row, col, path = queue.popleft()\n            if len(path) == k:\n                # If the current path has reached the desired length, update min_path\n                if not min_path or path < min_path:\n                    min_path = path\n                continue\n\n            for dr, dc in movements:\n                nr, nc = row + dr, col + dc\n                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]:\n                    queue.append((nr, nc, path + [grid[nr][nc]]))\n                    visited[nr][nc] = True\n\n    # Start BFS from each cell in the grid\n    for i in range(rows):\n        for j in range(cols):\n            bfs(i, j)\n\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    You are given a string s.\n    If s[i] is a letter, reverse its case from lower to upper or vice versa,\n    otherwise keep it as it is. If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"BA\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # If the character is a letter, reverse its case\n            result += char.swapcase()\n        else:\n            # If the character is not a letter, keep it as it is\n            result += char\n    return result[::-1]"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n         * sentence contains only letters\n\n    Returns:\n        A string containing the words from the original sentence,\n        whose lengths are prime numbers.\n    \"\"\"\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    words = sentence.split()\n    result = ''\n    for word in words:\n        if is_prime(len(word)):\n            result += word + ' '\n    return result.strip()"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    # Since the encoding process shifts by 5, we need to shift back by 5\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (2, 1)\n    \"\"\"\n    \n    # Convert the absolute value of num to string to easily iterate over each digit\n    num_str = str(abs(num))\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate over each character (digit) in the string representation of num\n    for digit in num_str:\n        # Convert the current digit back to integer to check if it's even or odd\n        int_digit = int(digit)\n        \n        # Check if the digit is even or odd and increment the corresponding counter\n        if int_digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return a tuple with the counts of even and odd digits respectively\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n    \n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        tuple: A tuple containing the count of even and odd integer palindromes respectively.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        # Convert the number to a string to easily check if it's a palindrome\n        str_i = str(i)\n        \n        # Check if the number is equal to its reverse\n        if str_i == str_i[::-1]:\n            # If it's a palindrome, increment either even or odd counter depending on whether i is even or odd\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n                \n    return (even_count, odd_count)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"brackets is a string of \"<\" and \">\". \n    Return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    \n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n    \n    left = 0\n    current_sum = max_sum = nums[0]\n    \n    for right in range(1, len(nums)):\n        current_sum += nums[right]\n        \n        # Update the maximum sum and minimum sum\n        max_sum = min(max_sum, current_sum)\n        current_sum = max(current_sum, 0)\n        \n        # Update the minimum sum if it's smaller than the current minimum sum\n        left = right + 1\n        while left < len(nums) and nums[left] <= max_sum:\n            left += 1\n        \n        min_sum = min(min_sum if min_sum != float('inf') else max_sum, current_sum)\n    \n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Check if three sides form a valid triangle\n    if (a + b > c) and (b + c > a) and (c + a > b):\n        # Calculate the semi-perimeter of the triangle\n        s = (a + b + c) / 2\n        \n        # Use Heron's formula to calculate the area of the triangle\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        \n        # Round the area to 2 decimal points and return it\n        return round(area, 2)\n    \n    else:\n        # If three sides do not form a valid triangle, return -1\n        return -1\n\n# Test the function with example inputs\nprint(triangle_area(3, 4, 5))  # Expected output: 6.00\nprint(triangle_area(1, 2, 10))  # Expected output: -1"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Input to this function is a string containing multiple groups of nested parentheses.\n    Your goal is to separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    result = []\n    current_group = ''\n    \n    for char in paren_string:\n        if char == '(':\n            current_group += char\n        elif char == ')':\n            current_group += char\n            # Check if the group is balanced\n            balance = 0\n            for c in current_group:\n                if c == '(':\n                    balance += 1\n                else:\n                    balance -= 1\n            if balance == 0:\n                result.append(current_group)\n                current_group = ''\n    \n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n\n    # First, sort the list in ascending order to make it easier to find three distinct elements that sum to zero.\n    l.sort()\n\n    # Iterate over each element in the list.\n    for i in range(len(l)):\n        # For each element, iterate over the next two elements (since we need at least three distinct elements).\n        for j in range(i + 1, len(l)):\n            # For each pair of elements, iterate over the rest of the list to find a third element that makes the sum zero.\n            for k in range(j + 1, len(l)):\n                # Check if the current three elements are distinct and their sum is zero.\n                if l[i] != l[j] and l[j] != l[k] and l[i] != l[k] and l[i] + l[j] + l[k] == 0:\n                    # If we find such a triplet, return True immediately.\n                    return True\n\n    # If we've iterated over the entire list without finding a triplet that sums to zero, return False.\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    \n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    example:\n    \n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \n    Parameters:\n    game (list): A list of scores\n    guess (list): A list of guesses\n    \n    Returns:\n    list: A list of differences between the scores and guesses\n    \"\"\"\n    return [abs(g - s) for g, s in zip(game, guess)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([ \n       [1,2,3,4,5,6], \n       [1,2,3,4,1,6], \n       [1,2,3,4,5,1] \n     ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n     \"\"\"\n\n    result = []\n    \n    # Iterate over each row in the list\n    for i, row in enumerate(lst):\n        # Find the indices of the value x in that row\n        indices = [j for j, val in enumerate(row) if val == x]\n        \n        # Sort these indices in descending order\n        indices.sort(reverse=True)\n        \n        # Add each index along with its corresponding row number to the result list\n        for idx in indices:\n            result.append((i, idx))\n    \n    return result"}
