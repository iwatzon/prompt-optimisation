{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that contain the given substring.\n    \n    Args:\n        strings (List[str]): List of strings to filter.\n        substring (str): Substring to check for in each string.\n        \n    Returns:\n        List[str]: Filtered list of strings containing the given substring.\n    \"\"\"\n    filtered_strings = [s for s in strings if substring in s]\n    return filtered_strings"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    # Initialize an empty string to store the concatenated result\n    result = ''\n    \n    # Iterate through each string in the list and concatenate it to the result\n    for string in strings:\n        result += string\n    \n    return result"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"\n    Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:  # Handle empty list case\n        return None\n\n    max_val = l[0]  # Initialize max_val with the first element of the list\n    for num in l:\n        if num > max_val:\n            max_val = num\n\n    return max_val"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    \n    # Check if the list is monotonically increasing\n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    \n    # Check if the list is monotonically decreasing\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n    \n    return increasing or decreasing"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    result = 1\n    factorial = 1\n\n    while n > 0:\n        factorial *= n\n        result *= factorial\n        n -= 1\n\n    return result"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n    if not numbers:\n        return 0, 1  # Return (0, 1) for an empty list\n\n    total_sum = 0\n    total_product = 1\n\n    for num in numbers:\n        total_sum += num\n        total_product *= num\n\n    return total_sum, total_product"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if len(xs) < 2:\n        return []\n\n    derivative_coeffs = []\n    for i in range(1, len(xs)):\n        derivative_coeffs.append(xs[i] * i)\n\n    return derivative_coeffs"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    unique_numbers = []\n    seen = set()\n    \n    for num in numbers:\n        if num not in seen:\n            unique_numbers.append(num)\n            seen.add(num)\n    \n    return unique_numbers"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    def sum_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    count = 0\n    for num in arr:\n        if sum_digits(num) > 0:\n            count += 1\n\n    return count"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n\n    # Ensure a is smaller than or equal to b\n    if a > b:\n        a, b = b, a\n\n    # Initialize a list to store even digits\n    even_digits = []\n\n    # Iterate through the range from a to b (inclusive)\n    for num in range(a, b + 1):\n        # Check if the digit is even\n        if num % 2 == 0:\n            even_digits.append(num)\n\n    return even_digits"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depths = []\n    max_depth = 0\n    current_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n    return [max_depth]\n\n# Test the function\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))  # Output: [2, 3, 1, 3]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    # Return the length of the string\n    return len(string)"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n\n    sorted_lst = sorted(lst)  # Sort the input list in ascending order\n    result = []  # Initialize an empty list to store the strange sorted values\n\n    while sorted_lst:  # Continue until the sorted list is not empty\n        result.append(sorted_lst.pop(0))  # Add the minimum value to the result list\n        if sorted_lst:  # Check if there are more elements in the sorted list\n            result.append(sorted_lst.pop())  # Add the maximum value to the result list\n\n    return result"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    \n    result = 0\n    \n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            result += num ** 2\n    \n    return result"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/143", "completion": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vice versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n\n    # Check if the string contains any letters\n    has_letters = any(char.isalpha() for char in s)\n\n    if not has_letters:\n        # If no letters, reverse the string\n        return s[::-1]\n    else:\n        # Reverse the case of letters\n        result = \"\"\n        for char in s:\n            if char.isalpha():\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n            else:\n                result += char\n        return result"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) if ch.isalpha() else ch for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    Takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) if ch.isalpha() else ch for ch in s])"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n        else:\n            i += 1\n    return n\n\n# Test cases\nprint(largest_prime_factor(13195))  # Output: 29\nprint(largest_prime_factor(2048))   # Output: 2"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    # Handle negative numbers by converting them to positive\n    num = abs(num)\n    \n    even_count = 0\n    odd_count = 0\n    \n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    \n    return (even_count, odd_count)"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n\n    if not nums:\n        return 0  # If the input array is empty, return 0\n\n    min_sum = float('inf')  # Initialize min_sum to positive infinity\n\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        if current_sum > 0:\n            current_sum = 0  # Reset current_sum if it becomes positive\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    \"\"\"\n    Check if every opening bracket has a corresponding closing bracket.\n\n    :param brackets: A string of \"<\" and \">\" representing brackets.\n    :return: True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n    stack = []  # Using a stack to keep track of opening brackets\n\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:  # If there are no opening brackets to match with\n                return False\n            stack.pop()  # Match the opening bracket with the closing bracket\n\n    return len(stack) == 0  # If stack is empty, all brackets are matched\n\n# Testing the function with provided examples\nprint(correct_bracketing(\"<\"))     # Output: False\nprint(correct_bracketing(\"<>\"))    # Output: True\nprint(correct_bracketing(\"<<><>>\"))  # Output: True\nprint(correct_bracketing(\"><<>\"))   # Output: False"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    result = []\n    current_group = \"\"\n    open_braces = 0\n\n    for char in paren_string:\n        if char == '(':\n            open_braces += 1\n            current_group += char\n        elif char == ')':\n            open_braces -= 1\n            current_group += char\n            if open_braces == 0:\n                result.append(current_group)\n                current_group = \"\"\n\n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    result = []\n    \n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    \n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return even_count, odd_count"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n\n    # Sort the list for easier comparison\n    l.sort()\n\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with your current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exists an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path goes through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    def find_min_path(grid, k, current_cell, visited, path):\n        if len(path) == k:\n            return path\n\n        x, y = current_cell\n        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n        neighbors = [(nx, ny) for nx, ny in neighbors if 0 <= nx < len(grid) and 0 <= ny < len(grid[0])]\n\n        next_cell = min(neighbors, key=lambda cell: grid[cell[0]][cell[1]])\n\n        return find_min_path(grid, k, next_cell, visited + [next_cell], path + [grid[next_cell[0]][next_cell[1]])\n\n    start_cell = min([(i, j) for i in range(len(grid)) for j in range(len(grid[0])], key=lambda cell: grid[cell[0]][cell[1]])\n    start_value = grid[start_cell[0]][start_cell[1]]\n\n    return find_min_path(grid, k, start_cell, [start_cell], [start_value])"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    example:\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n    \n    # Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate through each match\n    for i in range(len(game)):\n        # Calculate the absolute difference between the guess and the score\n        diff = abs(game[i] - guess[i])\n        # Append the difference to the list\n        differences.append(diff)\n    \n    return differences"}
