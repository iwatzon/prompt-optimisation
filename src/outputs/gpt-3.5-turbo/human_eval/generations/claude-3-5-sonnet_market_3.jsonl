{"task_id": "HumanEval/28", "completion": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string \"\"\"\n    return ''.join(strings)\n\n# Explanation:\n# - The function takes a list of strings as input and returns a single concatenated string.\n# - Using the built-in `join` method of strings is a concise and efficient way to concatenate strings.\n# - The function does not need additional error handling as the `join` method can handle empty lists."}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    sorted_lst = []\n    lst.sort()\n    \n    while lst:\n        sorted_lst.append(lst.pop(0))\n        if lst:\n            sorted_lst.append(lst.pop())\n    \n    return sorted_lst"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers \"\"\"\n    return [value for value in values if isinstance(value, int)]\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring \"\"\"\n    return [s for s in strings if substring in s]\n\n\n# Edge case: empty input list\nassert filter_by_substring([], 'a') == []\n\n# Regular case\nassert filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a') == ['abc', 'bacd', 'array']"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n <= 0:\n        return None\n\n    result = 1\n    for i in range(1, n+1):\n        factorial = 1\n        for j in range(1, i+1):\n            factorial *= j\n        result *= factorial\n\n    return result"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    def sum_digits(num):\n        if num < 0:\n            num = -num\n        return sum(int(digit) for digit in str(num))\n\n    count = 0\n    for num in arr:\n        if sum_digits(num) > 0:\n            count += 1\n    return count\n\n# Test cases\nassert count_nums([]) == 0\nassert count_nums([-1, 11, -11]) == 1\nassert count_nums([1, 1, 2]) == 3"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\"Calculate the derivative of a polynomial represented by coefficients in xs.\"\"\"\n    if len(xs) < 2:\n        return []\n\n    derivative_coeffs = [xs[i] * i for i in range(1, len(xs))]\n    return derivative_coeffs\n\n# Test cases\nprint(derivative([3, 1, 2, 4, 5]))  # Output: [1, 4, 12, 20]\nprint(derivative([1, 2, 3]))  # Output: [2, 6]"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\nfrom functools import reduce\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return 0, 1\n\n    sum_result = sum(numbers)\n    product_result = reduce(lambda x, y: x * y, numbers)\n\n    return sum_result, product_result"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    if not string:\n        return 0\n    return len(string)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    depths = []\n    max_depth = 0\n    current_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n    return [max_depth]\n\n# Test the function\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))  # Output: [3, 3, 1, 3]"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    if not l:\n        return None\n\n    max_num = l[0]\n    for num in l:\n        if num > max_num:\n            max_num = num\n\n    return max_num\n\n# Test cases\nprint(max_element([1, 2, 3]))  # Output: 3\nprint(max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))  # Output: 123\nprint(max_element([]))  # Output: None"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n    seen = set()\n\n    for num in numbers:\n        if num not in seen:\n            unique_numbers.append(num)\n            seen.add(num)\n\n    return unique_numbers\n\n# Test the function\nprint(remove_duplicates([1, 2, 3, 2, 4]))  # Output: [1, 3, 4]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    \n    result = 0\n    \n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            result += num ** 2\n    \n    return result * 2"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    \n    if len(l) <= 1:\n        return True\n    \n    increasing = all(l[i] <= l[i+1] for i in range(len(l)-1))\n    decreasing = all(l[i] >= l[i+1] for i in range(len(l)-1))\n    \n    return increasing or decreasing\n\n# Test cases\nprint(monotonic([1, 2, 4, 20]))  # Output: True\nprint(monotonic([1, 20, 4, 10]))  # Output: False\nprint(monotonic([4, 1, 0, -10]))  # Output: True"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    if a <= 0 or b <= 0:\n        return \"Both numbers must be positive integers.\"\n    \n    start = min(a, b)\n    end = max(a, b)\n    \n    even_digits = [int(digit) for digit in str(start) if int(digit) % 2 == 0]\n    \n    result = []\n    current = start + 1 if start in even_digits else start\n    \n    while current <= end:\n        if current % 2 == 0:\n            result.append(current)\n        current += 1\n    \n    return result\n\n# Test cases\nprint(generate_integers(2, 8))  # Output: [2, 4, 6, 8]\nprint(generate_integers(8, 2))  # Output: [2, 4, 6, 8]\nprint(generate_integers(10, 14))  # Output: []"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    if not any(char.isalpha() for char in s):\n        return s[::-1]\n    \n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    \n    return result\n\n# Test cases\nprint(solve(\"1234\"))  # Output: \"4321\"\nprint(solve(\"ab\"))    # Output: \"AB\"\nprint(solve(\"#a@C\"))  # Output: \"#A@c\""}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n\n# Test cases\nprint(largest_prime_factor(13195))  # Output: 29\nprint(largest_prime_factor(2048))   # Output: 2"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with encode_shift function and returns the decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n# Key design choices:\n# 1. The decode_shift function reverses the encoding done by the encode_shift function by shifting characters back by 5 in the alphabet.\n# 2. We use list comprehension to iterate over each character in the input string, decode it, and join the decoded characters back into a string.\n# 3. We use the modulo operator (%) to handle cases where the character goes beyond the alphabet range.\n# 4. We ensure that the decoded characters are within the lowercase alphabet range by adding or subtracting the necessary values.\n# 5. Both functions handle edge cases where characters might go beyond the alphabet range by using modulo arithmetic."}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = \"\"\n    open_braces = 0\n\n    for char in paren_string:\n        if char == '(':\n            open_braces += 1\n            current_group += char\n        elif char == ')':\n            open_braces -= 1\n            current_group += char\n            if open_braces == 0:\n                result.append(current_group)\n                current_group = \"\"\n\n    return result\n\n\n# Test cases\nprint(separate_paren_groups('( ) (( )) (( )( ))'))  # Output: ['()', '(())', '(()())']"}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/143", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    n = len(grid)\n    visited = set()\n    \n    def dfs(i, j, path):\n        if len(path) == k:\n            return path\n        \n        visited.add((i, j))\n        neighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]\n        neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x))\n        \n        for ni, nj in neighbors:\n            if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                res = dfs(ni, nj, path + [grid[ni][nj]])\n                if res:\n                    return res\n        \n        visited.remove((i, j))\n    \n    start_values = [(grid[i][j], i, j) for i in range(n) for j in range(n)]\n    start_values.sort()\n    \n    for _, i, j in start_values:\n        res = dfs(i, j, [grid[i][j]])\n        if res:\n            return res\n\n# Test cases\nprint(minPath([[1,2,3], [4,5,6], [7,8,9]], 3))  # Output: [1, 2, 1]\nprint(minPath([[5,9,3], [4,1,6], [7,8,2]], 1))  # Output: [1]"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    stack = []\n    \n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Test cases\nprint(correct_bracketing(\"<\"))    # False\nprint(correct_bracketing(\"<>\"))    # True\nprint(correct_bracketing(\"<<><>>\"))    # True\nprint(correct_bracketing(\"><<>\"))    # False"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n\n    # Convert the number to a string to iterate over each digit\n    num_str = str(abs(num))\n\n    for digit in num_str:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return (even_count, odd_count)\n\n# Test cases\nprint(even_odd_count(-12))  # Output: (1, 1)\nprint(even_odd_count(123))  # Output: (1, 2)"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    if len(game) != len(guess):\n        raise ValueError(\"The lengths of the game and guess arrays must be equal.\")\n    \n    result = []\n    for i in range(len(game)):\n        diff = abs(game[i] - guess[i])\n        result.append(diff)\n    \n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    coordinates = []\n    \n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    if not nums:\n        return None\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum\n\n# Test cases\nprint(minSubArraySum([2, 3, 4, 1, 2, 4]))  # Output: 1\nprint(minSubArraySum([-1, -2, -3]))  # Output: -6"}
{"task_id": "HumanEval/107", "completion": "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef even_odd_palindrome(n):\n    if n < 1 or n > 10**3:\n        return \"Input out of range\"\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n+1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    if len(l) < 3:\n        return False\n\n    l.sort()\n\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\n# Run the provided test cases\nassert not triples_sum_to_zero([1, 3, 5, 0])\nassert triples_sum_to_zero([1, 3, -2, 1])\nassert not triples_sum_to_zero([1, 2, 3, 7])\nassert triples_sum_to_zero([2, 4, -5, 3, 9, 7])\nassert not triples_sum_to_zero([1])"}
