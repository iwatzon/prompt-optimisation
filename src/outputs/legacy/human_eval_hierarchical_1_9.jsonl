{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n    Ignore any spaces in the input string.\n    \n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '()(())']\n    \"\"\"\n    if not isinstance(paren_string, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Ignore spaces in the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    if not paren_string:\n        return []\n    \n    result = []\n    balance = 0\n    start_index = 0\n\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if balance == 0:\n                start_index = i\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(paren_string[start_index:i+1])\n    \n    if balance != 0:\n        raise ValueError(\"Unbalanced input string\")\n    \n    return result\n\n# Unit tests\ndef test_separate_paren_groups():\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '()(())'], \"Test case 1 failed\"\n    assert separate_paren_groups('(( ))') == ['(())'], \"Test case 2 failed\"\n    assert separate_paren_groups('( )') == ['()'], \"Test case 3 failed\"\n    assert separate_paren_groups('( )( )') == ['()', '()'], \"Test case 4 failed\"\n    assert separate_paren_groups('') == [], \"Test case 5 failed\"\n    assert separate_paren_groups('((())) (()) ()') == ['((()))', '(())', '()'], \"Test case 6 failed\"\n    \n    try:\n        separate_paren_groups('(()')\n    except ValueError as ve:\n        assert str(ve) == \"Unbalanced input string\", \"Test case 7 failed\"\n    \n    try:\n        separate_paren_groups(123)\n    except ValueError as ve:\n        assert str(ve) == \"Input must be a string\", \"Test case 8 failed\"\n    \n    print(\"All test cases passed!\")\n\ntest_separate_paren_groups()"}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Type and value checks\n    if numbers is None:\n        raise ValueError(\"Input list cannot be None\")\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    if len(numbers) == 0:\n        raise ValueError(\"Input list cannot be empty\")\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise ValueError(\"All elements in input list must be int or float\")\n    \n    # Calculate the mean\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the Mean Absolute Deviation\n    mean_absolute_deviation = sum(abs(x - mean) for x in numbers) / len(numbers)\n    \n    return mean_absolute_deviation\n\n# Unit tests\ndef test_mean_absolute_deviation():\n    # Typical case\n    assert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0\n    # Single element\n    assert mean_absolute_deviation([5.0]) == 0.0\n    # All elements are the same\n    assert mean_absolute_deviation([2.0, 2.0, 2.0]) == 0.0\n    # Including negative numbers\n    assert mean_absolute_deviation([-1.0, 0.0, 1.0]) == 0.6666666666666666\n    # Mixed integers and floats\n    assert mean_absolute_deviation([1, 2.5, 3, 4.5]) == 1.0\n    # Large dataset\n    large_dataset = [i for i in range(1000000)]\n    expected_mad = (sum(abs(x - 499999.5) for x in large_dataset) / len(large_dataset))\n    assert mean_absolute_deviation(large_dataset) == expected_mad\n\n# Running tests\ntest_mean_absolute_deviation()\nprint(\"All tests passed.\")\n"}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" \n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    \n    # Initial balance starts at zero\n    balance = 0\n    \n    # Loop through each operation in the list\n    for operation in operations:\n        # Update the balance with the current operation\n        balance += operation\n        \n        # If balance falls below zero, return True\n        if balance < 0:\n            return True\n    \n    # If loop ends without balance falling below zero, return False\n    return False\n\n# Example test cases\nassert below_zero([1, 2, 3]) == False\nassert below_zero([1, 2, -4, 5]) == True\nassert below_zero([-1, 1, -1, 1, -1]) == True  # Edge case where negative operation appears early\nassert below_zero([500, -100, -100, -300]) == False  # Large deposit before withdrawals\nassert below_zero([]) == False  # Edge case with empty operations list\n\n# Additional edge cases\nassert below_zero([0, 0, 0]) == False  # Only zero operations\nassert below_zero([1000000000, -999999999, -2]) == True  # Large values with overflow potential"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \n    For a given list of integers, return a tuple consisting of a sum and a product \n    of all the integers in a list. Empty sum should be equal to 0 and empty product \n    should be equal to 1.\n    \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    \n    # Validate the input type\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input should be a list of integers.\")\n    for num in numbers:\n        if not isinstance(num, int):\n            raise ValueError(\"All elements in the list should be integers.\")\n    \n    # Handle empty list case\n    if not numbers:\n        return (0, 1)\n    \n    # Initialize sum and product\n    total_sum = 0\n    total_product = 1\n    \n    # Iterate over the list to calculate sum and product\n    for num in numbers:\n        total_sum += num\n        total_product *= num\n    \n    return (total_sum, total_product)\n\n# Unit tests\ndef test_sum_product():\n    assert sum_product([]) == (0, 1)\n    assert sum_product([1, 2, 3, 4]) == (10, 24)\n    assert sum_product([0, 2, 5]) == (7, 0)\n    assert sum_product([-1, 1, -1, 1]) == (0, 1)\n    assert sum_product([5]) == (5, 5)\n    print(\"All tests passed.\")\n\ntest_sum_product()"}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    \n    Args:\n        a (str): A binary string consisting of '1's and '0's.\n        b (str): A binary string consisting of '1's and '0's.\n        \n    Returns:\n        str: The binary XOR result as a string.\n        \n    Raises:\n        ValueError: If the input strings are not of equal length or contain characters other than '1' and '0'.\n    \n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('111', '000')\n    '111'\n    >>> string_xor('', '')\n    ''\n    >>> string_xor('1010', '0101')\n    '1111'\n    >>> string_xor('1010', '010')  # Should raise an error\n    Traceback (most recent call last):\n        ...\n    ValueError: Input strings must have the same length.\n    >>> string_xor('101a', '0101')  # Should raise an error\n    Traceback (most recent call last):\n        ...\n    ValueError: Input strings must contain only '1's and '0's.\n    \"\"\"\n    \n    # Check if lengths of input strings are equal\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length.\")\n    \n    # Ensure all characters in a and b are '1' or '0'\n    if not (set(a).issubset({'0', '1'}) and set(b).issubset({'0', '1'})):\n        raise ValueError(\"Input strings must contain only '1's and '0's.\")\n    \n    # Perform XOR operation\n    result = []\n    for char_a, char_b in zip(a, b):\n        result.append('1' if char_a != char_b else '0')\n    \n    return ''.join(result)\n\n# Unit tests\ndef test_string_xor():\n    assert string_xor('010', '110') == '100'\n    assert string_xor('111', '000') == '111'\n    assert string_xor('', '') == ''\n    assert string_xor('1010', '0101') == '1111'\n    try:\n        string_xor('1010', '010')\n    except ValueError as e:\n        assert str(e) == \"Input strings must have the same length.\"\n    try:\n        string_xor('101a', '0101')\n    except ValueError as e:\n        assert str(e) == \"Input strings must contain only '1's and '0's.\"\n\n# Running unit tests\ntest_string_xor()"}
{"task_id": "HumanEval/2", "completion": "import unittest\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than the given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    \n    Args:\n        number: A positive float to be truncated.\n\n    Returns:\n        The decimal part of the number as a float.\n    \n    Raises:\n        TypeError: If the input is not a float.\n        ValueError: If the input is not a positive float.\n    \n    Examples:\n    >>> truncate_number(3.5)\n    0.5\n    >>> truncate_number(10.12345)\n    0.12345\n    >>> truncate_number(0.987)\n    0.987\n    \"\"\"\n\n    # Type check\n    if not isinstance(number, float):\n        raise TypeError(\"Input must be a float\")\n    \n    # Value check\n    if number < 0:\n        raise ValueError(\"Input must be a positive float\")\n    \n    # Extract decimal part\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    \n    return decimal_part\n\nclass TestTruncateNumber(unittest.TestCase):\n    \n    def test_typical_cases(self):\n        self.assertAlmostEqual(truncate_number(3.5), 0.5)\n        self.assertAlmostEqual(truncate_number(10.12345), 0.12345)\n        self.assertAlmostEqual(truncate_number(7.99999), 0.99999)\n    \n    def test_edge_cases(self):\n        self.assertAlmostEqual(truncate_number(0.987), 0.987)\n        self.assertAlmostEqual(truncate_number(0.0), 0.0)\n\n    def test_input_type(self):\n        with self.assertRaises(TypeError):\n            truncate_number(\"not a float\")\n        with self.assertRaises(TypeError):\n            truncate_number(10)\n        with self.assertRaises(TypeError):\n            truncate_number(None)\n    \n    def test_value_constraints(self):\n        with self.assertRaises(ValueError):\n            truncate_number(-1.5)\n        with self.assertRaises(ValueError):\n            truncate_number(-3.14159)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    \n    # Check if the input list is empty\n    if len(strings) == 0:\n        return None\n    \n    # Initialize the longest string as the first element in the list\n    longest_str = strings[0]\n    \n    # Iterate through the list to find the longest string\n    for string in strings:\n        if len(string) > len(longest_str):\n            longest_str = string\n            \n    return longest_str\n\n# Example usage:\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    if not isinstance(strings, list):\n        raise TypeError(\"First argument must be a list\")\n    if not isinstance(substring, str):\n        raise TypeError(\"Second argument must be a string\")\n    \n    # Filter the list for strings containing the given substring\n    return [s for s in strings if substring in s]\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    # This will automatically run the tests provided in the docstrings\n    doctest.testmod()\n\n    # Additional test cases\n    assert filter_by_substring(['testing', 'case', 'empty', 'test'], 'test') == ['testing', 'test']\n    assert filter_by_substring(['nothing', 'here'], 'z') == []\n    assert filter_by_substring(['longstring'*1000, 'short'], 'short') == ['short']\n    assert filter_by_substring(['case', 'Case', 'cAse'], 'case') == ['case']\n    assert filter_by_substring([], '') == []\n    assert filter_by_substring([''], '') == ['']\n    assert filter_by_substring(['a', 'b', 'c'], 'a') == ['a']\n    \n    try:\n        filter_by_substring('not a list', 'a')\n    except TypeError as e:\n        assert str(e) == \"First argument must be a list\"\n    \n    try:\n        filter_by_substring(['list'], 123)\n    except TypeError as e:\n        assert str(e) == \"Second argument must be a string\""}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b.\n    \n    Uses the Euclidean algorithm to efficiently compute the GCD.\n    \n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    \n    Returns:\n    int: The greatest common divisor of a and b.\n    \n    Raises:\n    ValueError: If either a or b is not a positive integer.\n    \n    Examples:\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(0, 5)\n    5\n    >>> greatest_common_divisor(7, 0)\n    7\n    \"\"\"\n    \n    # Validate inputs\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both a and b must be integers.\")\n    if a < 0 or b < 0:\n        raise ValueError(\"Both a and b must be non-negative integers.\")\n    \n    # Handle edge cases with zero values\n    if a == 0:\n        return abs(b)\n    if b == 0:\n        return abs(a)\n    \n    # Implement the Euclidean algorithm\n    while b:\n        a, b = b, a % b\n    \n    return abs(a)\n\n# Unit tests\nimport unittest\n\nclass TestGreatestCommonDivisor(unittest.TestCase):\n    def test_gcd(self):\n        self.assertEqual(greatest_common_divisor(3, 5), 1)\n        self.assertEqual(greatest_common_divisor(25, 15), 5)\n        self.assertEqual(greatest_common_divisor(0, 5), 5)\n        self.assertEqual(greatest_common_divisor(7, 0), 7)\n        self.assertEqual(greatest_common_divisor(0, 0), 0)\n        self.assertEqual(greatest_common_divisor(100, 25), 25)\n        self.assertEqual(greatest_common_divisor(54, 24), 6)\n        \n    def test_invalid_inputs(self):\n        with self.assertRaises(ValueError):\n            greatest_common_divisor(-1, 5)\n        with self.assertRaises(ValueError):\n            greatest_common_divisor(5, -1)\n        with self.assertRaises(ValueError):\n            greatest_common_divisor(\"5\", 10)\n        with self.assertRaises(ValueError):\n            greatest_common_divisor(10, \"5\")\n\nif __name__ == '__main__':\n    unittest.main()"}
{"task_id": "HumanEval/10", "completion": "import unittest\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" \n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    \n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    if string == \"\" or is_palindrome(string):\n        return string\n    \n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    \n    return string + string[::-1]\n\n\nclass TestMakePalindrome(unittest.TestCase):\n    \n    def test_empty_string(self):\n        self.assertEqual(make_palindrome(''), '')\n        \n    def test_single_character(self):\n        self.assertEqual(make_palindrome('a'), 'a')\n        self.assertEqual(make_palindrome('z'), 'z')\n    \n    def test_palindrome_string(self):\n        self.assertEqual(make_palindrome('madam'), 'madam')\n        self.assertEqual(make_palindrome('racecar'), 'racecar')\n    \n    def test_non_palindrome_string(self):\n        self.assertEqual(make_palindrome('cat'), 'catac')\n        self.assertEqual(make_palindrome('cata'), 'catac')\n        self.assertEqual(make_palindrome('ab'), 'aba')\n    \n    def test_special_characters(self):\n        self.assertEqual(make_palindrome('madam!'), 'madam!')\n        self.assertEqual(make_palindrome('noon@'), 'noon@')\n        self.assertEqual(make_palindrome('pal!'), 'pal!ap')\n    \n    def test_mixed_case_string(self):\n        self.assertEqual(make_palindrome('Race'), 'RacecaR')\n    \n    def test_large_string(self):\n        large_string = 'a' * 10**6\n        self.assertEqual(make_palindrome(large_string), large_string)\n\n    def test_type_error(self):\n        with self.assertRaises(TypeError):\n            make_palindrome(None)\n        with self.assertRaises(TypeError):\n            make_palindrome(['list', 'of', 'strings'])\n        with self.assertRaises(TypeError):\n            make_palindrome(123)\n\nif __name__ == '__main__':\n    unittest.main()"}
{"task_id": "HumanEval/9", "completion": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n    Arguments:\n    numbers -- list of integers to process\n    \n    Returns:\n    list of integers where each element is the maximum encountered so far\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n    if not all(isinstance(i, int) for i in numbers):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    rolling_max_list = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list\n\n# Unit tests\ndef test_rolling_max():\n    assert rolling_max([1, 2, 3, 2, 3, 4, 2]) == [1, 2, 3, 3, 3, 4, 4]\n    assert rolling_max([4, 2, 1, 3, 4, 6, 5]) == [4, 4, 4, 4, 4, 6, 6]\n    assert rolling_max([-1, -2, -3, -2, -1, 0, 2]) == [-1, -1, -1, -1, -1, 0, 2]\n    assert rolling_max([7]) == [7]\n    assert rolling_max([]) == []\n    try:\n        rolling_max(None)\n    except ValueError as e:\n        assert str(e) == \"Input must be a list.\"\n    try:\n        rolling_max([1, \"2\", 3])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be integers.\"\n\n# Run tests\ntest_rolling_max()"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    \n    # Check if input is of correct type\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n\n    prefixes = []\n    \n    # Generate prefixes and add to the list\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    \n    return prefixes\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    def test_all_prefixes():\n        assert all_prefixes(\"\") == []  # Test with empty string\n        assert all_prefixes(\"a\") == [\"a\"]  # Test with single character\n        assert all_prefixes(\"abc\") == [\"a\", \"ab\", \"abc\"]  # Provided example\n        assert all_prefixes(\"abcdef\") == [\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\"]  # Test with longer string\n        assert all_prefixes(\"123\") == [\"1\", \"12\", \"123\"]  # Test with numeric characters\n\n        try:\n            all_prefixes(None)\n        except TypeError as e:\n            assert str(e) == \"Input must be a string\"  # Test with None input\n\n    test_all_prefixes()"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    \n    # Validate input type and value\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n        \n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Generate space-delimited numbers from 0 to n\n    return ' '.join(map(str, range(n + 1)))\n\n\n# Unit tests\n\ndef test_string_sequence():\n    assert string_sequence(0) == '0'\n    assert string_sequence(5) == '0 1 2 3 4 5'\n    assert string_sequence(1) == '0 1'\n    assert string_sequence(10) == '0 1 2 3 4 5 6 7 8 9 10'\n    assert string_sequence(3) == '0 1 2 3'\n\n    try:\n        string_sequence(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be a non-negative integer.\"\n        \n    try:\n        string_sequence(5.5)\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer.\"\n        \n    try:\n        string_sequence(\"5\")\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer.\"\n\n# Run tests\ntest_string_sequence()"}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\" Insert a number 'delimiter' between every two consecutive elements of input list `numbers`.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        delimiter (int): The integer to insert between the elements of `numbers`.\n\n    Returns:\n        List[int]: A list with the delimiter inserted between each pair of elements.\n    \n    Examples:\n        >>> intersperse([], 4)\n        []\n        >>> intersperse([1, 2, 3], 4)\n        [1, 4, 2, 4, 3]\n    \"\"\"\n    \n    # Check for edge case of empty input\n    if not numbers:\n        return []\n\n    # Initialize result list with the first element of `numbers`\n    result = [numbers[0]]\n    \n    # Loop through the `numbers` starting from the second element\n    for num in numbers[1:]:\n        result.append(delimiter)  # Insert the delimiter\n        result.append(num)        # Insert the next number\n    \n    return result\n\n# Unit tests to validate the function's correctness\ndef test_intersperse():\n    assert intersperse([], 4) == []\n    assert intersperse([1], 4) == [1]\n    assert intersperse([1, 2, 3], 4) == [1, 4, 2, 4, 3]\n    assert intersperse([7, 8], 2) == [7, 2, 8]\n    assert intersperse([5, 6, 7, 8], 10) == [5, 10, 6, 10, 7, 10, 8]\n    assert intersperse([1, 2, 3, 4], -1) == [1, -1, 2, -1, 3, -1, 4]\n    \n# Run tests\ntest_intersperse()"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Ensure input is of type str\n    if not isinstance(string, str):\n        raise ValueError(\"The input must be a string\")\n    \n    # Use a set to hold distinct characters, ignoring case\n    distinct_characters = set()\n    \n    for char in string:\n        # Convert each character to lowercase and add to the set\n        distinct_characters.add(char.lower())\n\n    # The number of distinct items in the set is our result\n    return len(distinct_characters)\n\n# Unit Tests\ndef test_count_distinct_characters():\n    # Test typical scenarios\n    assert count_distinct_characters('xyzXYZ') == 3\n    assert count_distinct_characters('Jerry') == 4\n    assert count_distinct_characters('abcABCabc') == 3\n    assert count_distinct_characters('') == 0\n    \n    # Test edge cases\n    assert count_distinct_characters('aAbBcC') == 3\n    assert count_distinct_characters('A') == 1\n    assert count_distinct_characters('1234567890') == 10\n    assert count_distinct_characters('112233') == 3\n    assert count_distinct_characters('!@#$%^&*()') == 10\n    \n    print(\"All tests passed!\")\n\n# Run tests\ntest_count_distinct_characters()"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"\n    Return length of given string.\n    \n    Parameters:\n    string (str): The string whose length is to be calculated.\n    \n    Returns:\n    int: The length of the given string.\n    \n    Raises:\n    TypeError: If the input is not a string.\n    \n    Examples:\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    # Check for correct input type\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Length of the string can be obtained using the built-in len function\n    return len(string)\n\n# Unit Tests:\ndef test_strlen():\n    assert strlen('') == 0, \"Test case 1 failed\"\n    assert strlen('a') == 1, \"Test case 2 failed\"\n    assert strlen('abc') == 3, \"Test case 3 failed\"\n    assert strlen('hello world') == 11, \"Test case 4 failed\"\n    assert strlen('1234567890') == 10, \"Test case 5 failed\"\n    \n    try:\n        strlen(None)\n    except TypeError as e:\n        assert str(e) == \"Input must be a string\", \"Test case 6 failed\"\n    else:\n        assert False, \"Test case 6 failed: Exception not raised\"\n    \n    try:\n        strlen(123)\n    except TypeError as e:\n        assert str(e) == \"Input must be a string\", \"Test case 7 failed\"\n    else:\n        assert False, \"Test case 7 failed: Exception not raised\"\n    \n    print(\"All test cases passed.\")\n\n# Run unit tests\ntest_strlen()"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    \n    Args:\n    paren_string (str): A string containing multiple groups of nested parentheses separated by spaces.\n    \n    Returns:\n    List[int]: A list of integers where each integer represents the deepest level of nesting for corresponding group.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    \n    # Split the input string into separate groups based on spaces\n    groups = paren_string.split()\n\n    results = []\n\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n\n            # This would be a sign of malformed parentheses, guard against it\n            if current_depth < 0:\n                raise ValueError(\"Malformed input string. Unbalanced parentheses found.\")\n\n        # Check if all opened parentheses are closed\n        if current_depth != 0:\n            raise ValueError(\"Malformed input string. Unbalanced parentheses found.\")\n\n        results.append(max_depth)\n\n    return results\n\n# Unit Test cases\ndef test_parse_nested_parens():\n    assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert parse_nested_parens('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert parse_nested_parens('') == []\n    assert parse_nested_parens('((()()())) () (())') == [3, 1, 2]\n    assert parse_nested_parens('()') == [1]\n\n    try:\n        parse_nested_parens('(()')\n    except ValueError as e:\n        assert str(e) == \"Malformed input string. Unbalanced parentheses found.\"\n    else:\n        assert False, \"Expected ValueError for malformed input\"\n\n    try:\n        parse_nested_parens('())')\n    except ValueError as e:\n        assert str(e) == \"Malformed input string. Unbalanced parentheses found.\"\n    else:\n        assert False, \"Expected ValueError for malformed input\"\n\n# Run unit tests\ntest_parse_nested_parens()"}
{"task_id": "HumanEval/0", "completion": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, there are any two numbers closer to each other than\n    the given threshold.\n    \n    Args:\n    numbers: List of float values.\n    threshold: A float threshold value.\n    \n    Returns:\n    bool: True if any two numbers are closer than the threshold, False otherwise.\n    \n    Example:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    # Validate the inputs\n    if not isinstance(numbers, list) or not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"Input 'numbers' must be a list of numbers.\")\n    if not isinstance(threshold, (int, float)):\n        raise ValueError(\"Input 'threshold' must be a number.\")\n    \n    # If there are fewer than 2 numbers, no pair can be closer than the threshold\n    if len(numbers) < 2:\n        return False\n    \n    # Sort the list to check distances between consecutive elements\n    sorted_numbers = sorted(numbers)\n    \n    # Check for any two consecutive elements in the sorted list\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    return False\n\n# Unit tests\ndef test_has_close_elements():\n    assert has_close_elements([1.0, 2.0, 3.0], 0.5) == False\n    assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True\n    assert has_close_elements([], 0.5) == False\n    assert has_close_elements([1.5], 0.5) == False\n    assert has_close_elements([1.0, 1.1], 0.2) == True\n    assert has_close_elements([1.0, 1.1], 0.05) == False\n    assert has_close_elements([-1.0, -1.05], 0.1) == True\n    assert has_close_elements([1.0, 2.0, 3.0], 2.0) == True\n    \ntest_has_close_elements()"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \n    Filter given list of any python values only for integers.\n    \n    Args:\n        values (List[Any]): A list containing any Python values.\n        \n    Returns:\n        List[int]: A list of integers extracted from the input list.\n    \n    Examples:\n        >>> filter_integers(['a', 3.14, 5])\n        [5]\n        >>> filter_integers([1, 2, 3, 'abc', {}, []])\n        [1, 2, 3]\n    \"\"\"\n    # Validate that input is a list\n    if not isinstance(values, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Filter the list to include only integers\n    return [value for value in values if isinstance(value, int)]\n\n\n# Unit test cases\ndef test_filter_integers():\n    # Basic cases\n    assert filter_integers(['a', 3.14, 5]) == [5]\n    assert filter_integers([1, 2, 3, 'abc', {}, []]) == [1, 2, 3]\n    \n    # Empty list case\n    assert filter_integers([]) == []\n    \n    # All integers case\n    assert filter_integers([10, 20, 30]) == [10, 20, 30]\n    \n    # Mixed data types\n    assert filter_integers([1, 'a', None, 2, 3.5, 4]) == [1, 2, 4]\n    \n    # No integers case\n    assert filter_integers(['a', 'b', 3.14, {}, []]) == []\n    \n    # Special cases with edge values\n    assert filter_integers([0, -1, 1]) == [0, -1, 1]\n\n    # Large dataset\n    large_list = [i if i % 2 == 0 else str(i) for i in range(1000000)]\n    assert filter_integers(large_list) == [i for i in range(1000000) if i % 2 == 0]\n\n# Run tests\ntest_filter_integers()"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \n    Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    \n    Args:\n        numbers (List[float]): A list of float numbers.\n\n    Returns:\n        List[float]: A list where the numbers are rescaled to the range [0, 1].\n        \n    Raises:\n        ValueError: If the input list is empty or has less than two elements.\n        TypeError: If the input is not a list of floats.\n    \n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit([-10.0, 0.0, 10.0])\n    [0.0, 0.5, 1.0]\n    >>> rescale_to_unit([1.0, 1.0])\n    [0.0, 0.0]\n    \"\"\"\n    # Ensure the input is a list of floats\n    if not isinstance(numbers, list) or not all(isinstance(num, (float, int)) for num in numbers):\n        raise TypeError(\"Input must be a list of numbers (floats or integers).\")\n\n    # Ensure the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n    \n    # Handle the case if all numbers are the same\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    if min_num == max_num:\n        return [0.0 for _ in numbers]\n    \n    # Calculate the range\n    range_num = max_num - min_num\n    \n    # Rescale each number to the range [0, 1]\n    return [(num - min_num) / range_num for num in numbers]\n\n# Unit test\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" \n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    \n    Args:\n    string (str): The original string where the search will be conducted.\n    substring (str): The substring to count within the original string.\n    \n    Returns:\n    int: The number of times the substring appears in the string.\n    \n    Examples:\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    # Edge case: if the substring is empty, return 0\n    if not substring:\n        return 0\n    \n    # Initialize the count and the starting index for the search\n    count = 0\n    start = 0\n    \n    # Loop until the substring is no longer found\n    while True:\n        start = string.find(substring, start)\n        \n        # If not found, break the loop\n        if start == -1:\n            break\n        \n        # Increment the count and move the start position to allow overlapping matches\n        count += 1\n        start += 1\n    \n    return count\n\n# Unit test cases to validate the function\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase. \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    flipped_string = []\n    \n    for char in string:\n        if char.islower():\n            flipped_string.append(char.upper())\n        elif char.isupper():\n            flipped_string.append(char.lower())\n        else:\n            flipped_string.append(char)\n    \n    return ''.join(flipped_string)\n\nif __name__ == \"__main__\":\n    import unittest\n    \n    class TestFlipCase(unittest.TestCase):\n        def test_typical_cases(self):\n            self.assertEqual(flip_case('Hello'), 'hELLO')\n            self.assertEqual(flip_case('Python'), 'pYTHON')\n            self.assertEqual(flip_case('12345'), '12345')\n            self.assertEqual(flip_case(''), '')\n\n        def test_edge_cases(self):\n            self.assertEqual(flip_case('a'), 'A')\n            self.assertEqual(flip_case('A'), 'a')\n            self.assertEqual(flip_case('a1A'), 'A1a')\n            \n        def test_large_string(self):\n            large_string = 'a' * 1000000 + 'B' * 1000000\n            expected_result = 'A' * 1000000 + 'b' * 1000000\n            self.assertEqual(flip_case(large_string), expected_result)\n\n        def test_invalid_inputs(self):\n            with self.assertRaises(TypeError):\n                flip_case(None)\n            with self.assertRaises(TypeError):\n                flip_case(12345)\n            with self.assertRaises(TypeError):\n                flip_case(['a', 'B'])\n\n    unittest.main()"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        List[int]: A list of integers with duplicates removed.\n        \n    Examples:\n        >>> remove_duplicates([1, 2, 3, 2, 4])\n        [1, 3, 4]\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    if not all(isinstance(n, int) for n in numbers):\n        raise ValueError(\"All elements in the list must be integers\")\n        \n    from collections import Counter\n    \n    # Count occurrence of each number in the list\n    count = Counter(numbers)\n    \n    # Return numbers that appear only once, preserving the order\n    return [num for num in numbers if count[num] == 1]\n\n# Unit Tests\ndef test_remove_duplicates():\n    assert remove_duplicates([1, 2, 3, 2, 4]) == [1, 3, 4], \"Test Case 1 Failed\"\n    assert remove_duplicates([1, 1, 1, 1, 1]) == [], \"Test Case 2 Failed\"\n    assert remove_duplicates([]) == [], \"Test Case 3 Failed\"\n    assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5], \"Test Case 4 Failed\"\n    assert remove_duplicates([1, 2, 2, 3, 3, 4]) == [1, 4], \"Test Case 5 Failed\"\n    assert remove_duplicates([10, -10, 10, -10, 20]) == [20], \"Test Case 6 Failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run unit tests\ntest_remove_duplicates()"}
{"task_id": "HumanEval/25", "completion": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" \n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    \n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # prime factors\n    factors = []\n    # Start with the smallest prime number\n    divisor = 2\n    while n >= divisor:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Unit tests\nimport unittest\n\nclass TestFactorize(unittest.TestCase):\n    def test_small_numbers(self):\n        self.assertEqual(factorize(8), [2, 2, 2])\n        self.assertEqual(factorize(25), [5, 5])\n        self.assertEqual(factorize(70), [2, 5, 7])\n    \n    def test_prime_numbers(self):\n        self.assertEqual(factorize(13), [13])\n        self.assertEqual(factorize(19), [19])\n    \n    def test_composite_numbers(self):\n        self.assertEqual(factorize(50), [2, 5, 5])\n        self.assertEqual(factorize(100), [2, 2, 5, 5])\n\n    def test_large_numbers(self):\n        self.assertEqual(factorize(2 * 3 * 5 * 7 * 11), [2, 3, 5, 7, 11])\n\n    def test_invalid_input(self):\n        with self.assertRaises(TypeError):\n            factorize('a')\n        with self.assertRaises(ValueError):\n            factorize(-1)\n        with self.assertRaises(ValueError):\n            factorize(0)\n\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" \n    Concatenate list of strings into a single string\n    \n    Parameters:\n        strings (List[str]): A list of strings to concatenate\n        \n    Returns:\n        str: The concatenated string\n\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    >>> concatenate(['hello', ' ', 'world'])\n    'hello world'\n    \"\"\"\n    # Validate input type\n    if not isinstance(strings, list):\n        raise TypeError(\"Input must be a list of strings\")\n    \n    # Check if all elements in the list are strings\n    if not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"All elements in the list must be strings\")\n    \n    # Use join for efficient concatenation\n    return ''.join(strings)\n\n# Unit Tests\ndef test_concatenate():\n    # Typical scenarios\n    assert concatenate([]) == ''\n    assert concatenate(['a', 'b', 'c']) == 'abc'\n    assert concatenate(['hello', ' ', 'world']) == 'hello world'\n    \n    # Edge cases\n    assert concatenate(['']) == ''\n    assert concatenate(['', '']) == ''\n    assert concatenate(['a', '', 'c']) == 'ac'\n    assert concatenate(['', 'a', '', 'b', '']) == 'ab'\n    \n    # Test with large datasets\n    assert concatenate(['a'] * 1000000) == 'a' * 1000000\n    \n    # Test with invalid inputs (TypeError)\n    try:\n        concatenate(123)\n    except TypeError as e:\n        assert str(e) == \"Input must be a list of strings\"\n    \n    # Test with invalid inputs (ValueError)\n    try:\n        concatenate(['a', 1, 'b'])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be strings\"\n\n# Running the tests\ntest_concatenate()"}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Filter an input list of strings only for ones that start with a given prefix.\n    \n    Args:\n        strings (List[str]): List of strings to be filtered.\n        prefix (str): Prefix to filter the strings by.\n\n    Returns:\n        List[str]: List of strings that start with the given prefix.\n        \n    Raises:\n        TypeError: If the inputs are not of the expected type.\n\n    Examples:\n        >>> filter_by_prefix([], 'a')\n        []\n        >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n        ['abc', 'array']\n    \"\"\"\n    # Type checking of the inputs for robustness\n    if not isinstance(strings, list):\n        raise TypeError('The first argument must be a list of strings.')\n    if not isinstance(prefix, str):\n        raise TypeError('The second argument must be a string.')\n    for s in strings:\n        if not isinstance(s, str):\n            raise TypeError('All items in the list must be strings.')\n    \n    # Using list comprehension for efficient filtering\n    return [s for s in strings if s.startswith(prefix)]\n\n# Unit tests\ndef test_filter_by_prefix():\n    assert filter_by_prefix([], 'a') == []\n    assert filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']\n    assert filter_by_prefix(['apple', 'banana', 'apricot'], 'a') == ['apple', 'apricot']\n    assert filter_by_prefix(['apple', 'banana', 'apricot'], 'b') == ['banana']\n    assert filter_by_prefix(['abc', '123', 'a12', 'xyz'], 'a') == ['abc', 'a12']\n    assert filter_by_prefix(['apple', 'banana', 'apricot'], '') == ['apple', 'banana', 'apricot']  # empty prefix matches all\n\n    # Edge case: no matches\n    assert filter_by_prefix(['hello', 'world'], 'a') == []\n    \n    # Edge case: case sensitivity\n    assert filter_by_prefix(['Apple', 'apricot'], 'A') == ['Apple']\n    \n    print(\"All tests passed!\")\n\n# Running the tests\ntest_filter_by_prefix()"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    # Handle edge cases: n must be a positive integer larger than 1 to be prime\n    if not isinstance(n, int):\n        raise TypeError(f\"Expected an integer, got {type(n).__name__}\")\n    if n < 2:\n        return False\n\n    # Special cases for small prime numbers\n    if n in (2, 3):\n        return True\n    # Even number and multiples of 3 are not primes\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    # Check for factors from 5 to sqrt(n)\n    # This skips even numbers and uses an increment of 6 to check 6k \u00b1 1\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    \n    return True\n\nimport unittest\n\nclass TestIsPrime(unittest.TestCase):\n    def test_primes(self):\n        self.assertTrue(is_prime(2))\n        self.assertTrue(is_prime(3))\n        self.assertTrue(is_prime(5))\n        self.assertTrue(is_prime(11))\n        self.assertTrue(is_prime(61))\n        self.assertTrue(is_prime(101))\n        self.assertTrue(is_prime(13441))\n        \n    def test_non_primes(self):\n        self.assertFalse(is_prime(1))\n        self.assertFalse(is_prime(4))\n        self.assertFalse(is_prime(6))\n        self.assertFalse(is_prime(25))\n        self.assertFalse(is_prime(49))\n        \n    def test_invalid_input(self):\n        with self.assertRaises(TypeError):\n            is_prime(\"string\")\n        with self.assertRaises(TypeError):\n            is_prime(4.5)\n        with self.assertRaises(TypeError):\n            is_prime(None)\n            \n    def test_large_primes(self):\n        # Test a known large prime number\n        self.assertTrue(is_prime(1000003))\n\nif __name__ == \"__main__\":\n    unittest.main()\n"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n\n    Args:\n        l (list): A list of comparable elements.\n\n    Returns:\n        The maximum element in the list.\n\n    Raises:\n        ValueError: If the list is empty.\n        TypeError: If the elements in the list are not comparable or if input is not a list.\n\n    Examples:\n        >>> max_element([1, 2, 3])\n        3\n        >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n        123\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    if not l:\n        raise ValueError(\"List cannot be empty.\")\n    \n    # Initialize the maximum element with the first element\n    max_elem = l[0]\n    \n    # Iterate through the list to find the maximum element\n    for element in l:\n        if element > max_elem:\n            max_elem = element\n    \n    return max_elem\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional unit tests\n    assert max_element([1, -1, 0, 2]) == 2\n    assert max_element([5, 3, 9, 0, -1, -5]) == 9\n    assert max_element([10]) == 10\n    assert max_element([-1, -5, -3, -10]) == -1\n    \n    try:\n        max_element([])\n    except ValueError as e:\n        assert str(e) == \"List cannot be empty\"\n\n    try:\n        max_element(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"Input must be a list\"\n    \n    print(\"All test cases pass\")"}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    \n    # Type check for function input\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list of numbers.\")\n        \n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n        \n    # Sorting the list to find closest elements efficiently\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair\n\n# Uncomment the following lines to run basic test cases\n# print(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))  # Output: (2.0, 2.2)\n# print(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))  # Output: (2.0, 2.0)"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Parameters:\n    n (int): The number for which to find the largest divisor\n    \n    Returns:\n    int: The largest divisor of n which is smaller than n\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(0)\n    0\n    \"\"\"\n    \n    # Type checking for input parameter\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    \n    # Handle special cases\n    if n <= 1:\n        # 1 and 0 do not have proper divisors smaller than themselves\n        return 0\n    \n    # Starting from n//2 and checking downwards to avoid checking 1 (it's always valid)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    # This line should never be reached due to the logic above\n    raise ValueError(\"Unexpected error during computation.\")\n\n# Testing\nimport unittest\n\nclass TestLargestDivisor(unittest.TestCase):\n    def test_typical_cases(self):\n        self.assertEqual(largest_divisor(15), 5)\n        self.assertEqual(largest_divisor(100), 50)\n        self.assertEqual(largest_divisor(13), 1)\n    \n    def test_edge_cases(self):\n        self.assertEqual(largest_divisor(0), 0)\n        self.assertEqual(largest_divisor(1), 0)\n        self.assertEqual(largest_divisor(2), 1)\n    \n    def test_type_errors(self):\n        with self.assertRaises(TypeError):\n            largest_divisor(\"15\")\n        with self.assertRaises(TypeError):\n            largest_divisor(15.5)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n\n    Args:\n        l (list): List of elements which may contain duplicates.\n\n    Returns:\n        list: Sorted list of unique elements.\n\n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n\n    Raises:\n        TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n\n    # Handle edge cases\n    if not l:  # if the list is empty\n        return []\n\n    if any(element is None for element in l):\n        raise ValueError(\"List elements cannot be None.\")\n\n    # Create a set to get unique elements\n    unique_elements = set(l)\n    # Sort the unique elements and return as a list\n    return sorted(unique_elements)\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    def test_unique():\n        # Testing with normal list\n        assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n        \n        # Testing with empty list\n        assert unique([]) == []\n\n        # Testing with all unique elements\n        assert unique([1, 2, 3]) == [1, 2, 3]\n        \n        # Testing with all same elements\n        assert unique([4, 4, 4, 4]) == [4]\n        \n        # Testing with mix of negative and positive numbers\n        assert unique([-1, -1, 0, 1, 1]) == [-1, 0, 1]\n\n        # Testing with None in list (should raise ValueError)\n        try:\n            unique([1, None, 2])\n        except ValueError as e:\n            assert str(e) == \"List elements cannot be None.\"\n\n        # Testing with non-list input (should raise TypeError)\n        try:\n            unique(\"not a list\")\n        except TypeError as e:\n            assert str(e) == \"Input must be a list.\"\n\n    test_unique()"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise ValueError(\"The input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"The input must be a non-negative integer.\")\n    \n    # Initialize counter for digit '7'\n    count = 0\n    \n    # Iterate through numbers less than n\n    for i in range(n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to string and count '7's\n            count += str(i).count('7')\n    \n    return count\n\n# Unit tests\ndef test_fizz_buzz():\n    assert fizz_buzz(50) == 0\n    assert fizz_buzz(78) == 2\n    assert fizz_buzz(79) == 3\n    assert fizz_buzz(0) == 0\n    assert fizz_buzz(11) == 0\n    assert fizz_buzz(88) == 3\n    assert fizz_buzz(0) == 0\n    try:\n        fizz_buzz(-1)\n    except ValueError as e:\n        assert str(e) == \"The input must be a non-negative integer.\"\n    try:\n        fizz_buzz(\"100\")\n    except ValueError as e:\n        assert str(e) == \"The input must be an integer.\"\n    print(\"All tests passed!\")\n\n# Run tests\ntest_fizz_buzz()"}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    Args:\n        l (list): Input list of elements.\n    \n    Returns:\n        list: A list where elements at indices divisible by three are sorted.\n    \n    Raises:\n        TypeError: If input is not a list.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if the list is empty\n    if not l:\n        return l\n    \n    # Extract elements at indices divisible by three\n    elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort those elements\n    elements.sort()\n    \n    # Create a copy of the list so we don't modify the input list\n    result = l[:]\n    \n    # Replace elements at indices divisible by three with sorted elements\n    e_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = elements[e_index]\n            e_index += 1\n    \n    return result\n\n# Unit tests\nimport unittest\n\nclass TestSortThird(unittest.TestCase):\n    \n    def test_empty_list(self):\n        self.assertEqual(sort_third([]), [])\n    \n    def test_single_element(self):\n        self.assertEqual(sort_third([1]), [1])\n    \n    def test_no_sort_needed(self):\n        self.assertEqual(sort_third([1, 2, 3]), [1, 2, 3])\n    \n    def test_sort_needed(self):\n        self.assertEqual(sort_third([5, 6, 3, 4, 8, 9, 2]), [2, 6, 3, 4, 8, 9, 5])\n    \n    def test_all_indices_sort(self):\n        self.assertEqual(sort_third([9, 1, 3, 8, 5, 2]), [8, 1, 3, 9, 5, 2])\n    \n    def test_non_contiguous_elements(self):\n        self.assertEqual(sort_third([7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4]), [1, 6, 5, 4, 3, 2, 7, 0, -1, -2, -3, -4])\n    \n    def test_input_not_a_list(self):\n        with self.assertRaises(TypeError):\n            sort_third(123)\n        with self.assertRaises(TypeError):\n            sort_third(\"string\")\n        with self.assertRaises(TypeError):\n            sort_third(None)\n        with self.assertRaises(TypeError):\n            sort_third({1, 2, 3})\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/19", "completion": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numeral words from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    # Validate the input\n    if not isinstance(numbers, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if not numbers:\n        return \"\"\n\n    # Map of number words to their numeric values\n    word_to_num = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, \n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n\n    # Split input string into number word list\n    number_words = numbers.split()\n\n    # Check for validation of the number words\n    for word in number_words:\n        if word not in word_to_num:\n            raise ValueError(f\"Invalid number word in input: '{word}'\")\n\n    # Sort the number words based on their numeric values\n    sorted_number_words = sorted(number_words, key=lambda x: word_to_num[x])\n    \n    # Join the sorted number words back into a string\n    return ' '.join(sorted_number_words)\n\n# Unit tests\ndef test_sort_numbers():\n    assert sort_numbers('three one five') == 'one three five'\n    assert sort_numbers('nine eight zero') == 'zero eight nine'\n    assert sort_numbers('five four three two one') == 'one two three four five'\n    assert sort_numbers('zero zero zero') == 'zero zero zero'\n    assert sort_numbers('') == ''\n    try:\n        sort_numbers('one two ten')\n        assert False, \"Expected ValueError for invalid number word\"\n    except ValueError:\n        pass\n    try:\n        sort_numbers(123)\n        assert False, \"Expected TypeError for non-string input\"\n    except TypeError:\n        pass\n\n# To run the tests\ntest_sort_numbers()\n\n# Output the answer"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    \n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        list: A list of positive integers from the input list.\n\n    Raises:\n        ValueError: If input list contains non-integer values.\n\n    Examples:\n        >>> get_positive([-1, 2, -4, 5, 6])\n        [2, 5, 6]\n        >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n        [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    \n    if not isinstance(l, list):\n        raise ValueError(\"Input must be a list\")\n\n    for elem in l:\n        if not isinstance(elem, int):\n            raise ValueError(\"All elements in the list must be integers\")\n\n    return [x for x in l if x > 0]\n\n\n# Unit tests\nif __name__ == \"__main__\":\n    # Test typical scenarios\n    assert get_positive([-1, 2, -4, 5, 6]) == [2, 5, 6]\n    assert get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 9, 123, 1]\n\n    # Test edge cases\n    assert get_positive([]) == []  # Empty list should return an empty list\n    assert get_positive([-1, -2, -3]) == []  # List with no positive numbers should return an empty list\n    assert get_positive([1]) == [1]  # Single positive number should return a list with that number\n    assert get_positive([-1]) == []  # Single negative number should return an empty list\n    assert get_positive([0]) == []  # Single zero should return an empty list\n\n    # Test input type check\n    try:\n        get_positive(\"Not a list\")  # Should raise ValueError\n    except ValueError as e:\n        assert str(e) == \"Input must be a list\"\n\n    # Test element type check\n    try:\n        get_positive([1, 2, \"string\", 4])  # Should raise ValueError\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be integers\"\n\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    # Define a dictionary for note to beat mapping\n    note_to_beats = {\n        'o': 4,  # whole note\n        'o|': 2,  # half note\n        '.|': 1   # quarter note\n    }\n    \n    # Split the input string by spaces into a list of notes\n    notes = music_string.split()\n\n    # Check for empty input and return an empty list\n    if not notes:\n        return []\n\n    # Convert each note into its corresponding beat value using the dictionary\n    beats = []\n    for note in notes:\n        if note not in note_to_beats:\n            raise ValueError(f\"Unrecognized note format in the input: {note}\")\n        beats.append(note_to_beats[note])\n\n    return beats\n\n# Test cases to validate the implementation\nimport unittest\n\nclass TestParseMusic(unittest.TestCase):\n    def test_basic(self):\n        self.assertEqual(parse_music('o o| .| o| o| .| .| .| .| o o'), [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4])\n\n    def test_empty(self):\n        self.assertEqual(parse_music(''), [])\n\n    def test_single_notes(self):\n        self.assertEqual(parse_music('o'), [4])\n        self.assertEqual(parse_music('o|'), [2])\n        self.assertEqual(parse_music('.|'), [1])\n        \n    def test_invalid_format(self):\n        with self.assertRaises(ValueError):\n            parse_music('x o| .|')\n\n    def test_large_input(self):\n        music_string = ' '.join(['o', 'o|', '.|'] * 1000)\n        expected_output = [4, 2, 1] * 1000\n        self.assertEqual(parse_music(music_string), expected_output)\n\n# Run the unit tests\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/32", "completion": "import math\nfrom typing import List\n\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    if not isinstance(xs, list) or not all(isinstance(coeff, (int, float)) for coeff in xs):\n        raise TypeError(\"xs should be a list of integers or floats\")\n    if not isinstance(x, (int, float)):\n        raise TypeError(\"x should be an integer or float\")\n    \n    # Calculate the polynomial value using Horner's method for efficiency\n    result = 0\n    for coeff in reversed(xs):\n        result = result * x + coeff\n    return result\n\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\" \n    xs are coefficients of a polynomial.\n    find_zero finds x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non-zero coefficient as it guarantees\n    a solution.\n    \n    Args:\n    xs : List[float] : List of coefficients of the polynomial\n    \n    Returns:\n    float : The zero of the polynomial\n    \n    Raises:\n    ValueError : If the list xs does not have an even number of coefficients or if the largest is 0.\n    \n    Examples:\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if not isinstance(xs, list) or not all(isinstance(coeff, (int, float)) for coeff in xs):\n        raise TypeError(\"xs should be a list of integers or floats\")\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list xs should have an even number of coefficients\")\n    if max(xs, key=abs) == 0:\n        raise ValueError(\"The list xs should have a non-zero maximum coefficient\")\n    \n    # Implementing the Bisection method to find one of the zeros\n    def bisection_method(a, b, tol=1e-7, max_iterations=1000):\n        f_a = poly(xs, a)\n        f_b = poly(xs, b)\n        if f_a * f_b > 0:\n            raise ValueError(\"The values at the endpoints of the interval should have opposite signs\")\n        \n        for _ in range(max_iterations):\n            c = (a + b) / 2\n            f_c = poly(xs, c)\n            if abs(f_c) < tol:\n                return c\n            if f_c * f_a < 0:\n                b = c\n                f_b = f_c\n            else:\n                a = c\n                f_a = f_c\n        raise ValueError(\"Bisection method did not converge\")\n    \n    # To ensure we find a zero, we must provide an initial interval [a, b]\n    # Where the signs of f(a) and f(b) are opposite. For simplicity:\n    a, b = -10, 10\n    try:\n        zero = bisection_method(a, b)\n    except ValueError:\n        raise ValueError(\"Could not find a zero within the interval [-10, 10]. Try expanding the interval.\")\n    \n    return zero\n\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional tests\n    assert round(find_zero([1, 2]), 2) == -0.5\n    assert round(find_zero([-6, 11, -6, 1]), 2) == 1.0\n    assert round(find_zero([2, -4, 2]), 2) == 1.0\n    assert round(find_zero([2, 0, -2, 0, 1]), 2) == -1.0"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    # Type check to ensure that 'l' is a list\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Check if the list has fewer than 3 elements\n    if len(l) < 3:\n        return False\n\n    # Sort the list to apply two-pointer method efficiently\n    l.sort()\n\n    # Iterate through the list and use two-pointer technique to find triples that sum to zero\n    for i in range(len(l) - 2):\n        # Avoid duplicate elements\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        left, right = l[i + 1], len(l) - 1\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n\n    # If no such triplet is found\n    return False\n\n# Unit testing\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str) -> str:\n    \"\"\"\n    Returns an encoded string by cycling groups of three characters.\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Split the string into groups of 3 characters each\n    groups = [s[i:i + 3] for i in range(0, len(s), 3)]\n\n    # Cycle elements in each group unless the group has fewer than 3 elements\n    encoded_groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n\n    return \"\".join(encoded_groups)\n\n\ndef decode_cyclic(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with the encode_cyclic function. Returns the decoded string.\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Split the string into groups of 3 characters each\n    groups = [s[i:i + 3] for i in range(0, len(s), 3)]\n\n    # Reverse cycle elements in each group unless the group has fewer than 3 elements\n    decoded_groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n\n    return \"\".join(decoded_groups)\n\n\n# Unit tests\nimport unittest\n\nclass TestCyclicEncoding(unittest.TestCase):\n    def test_encode_decode_simple(self):\n        self.assertEqual(encode_cyclic(\"abcdef\"), \"bcaefd\")\n        self.assertEqual(decode_cyclic(encode_cyclic(\"abcdef\")), \"abcdef\")\n\n    def test_encode_decode_with_remainder(self):\n        self.assertEqual(encode_cyclic(\"abcdefg\"), \"bcaefdg\")\n        self.assertEqual(decode_cyclic(encode_cyclic(\"abcdefg\")), \"abcdefg\")\n\n    def test_empty_string(self):\n        self.assertEqual(encode_cyclic(\"\"), \"\")\n        self.assertEqual(decode_cyclic(\"\"), \"\")\n\n    def test_single_char(self):\n        self.assertEqual(encode_cyclic(\"a\"), \"a\")\n        self.assertEqual(decode_cyclic(\"a\"), \"a\")\n\n    def test_two_chars(self):\n        self.assertEqual(encode_cyclic(\"ab\"), \"ab\")\n        self.assertEqual(decode_cyclic(\"ab\"), \"ab\")\n\n    def test_invalid_input(self):\n        with self.assertRaises(ValueError):\n            encode_cyclic(123)\n        with self.assertRaises(ValueError):\n            decode_cyclic(123)\n\n\nif __name__ == '__main__':\n    unittest.main()"}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list) -> list:\n    \"\"\"\n    Return list with elements incremented by 1.\n\n    Parameters:\n    l (list): A list of integers.\n\n    Returns:\n    list: A new list with each element incremented by 1.\n\n    Raises:\n    TypeError: If any element in the list is not an integer.\n    ValueError: If the input list contains any None values.\n\n    Examples:\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    >>> incr_list([])\n    []\n    >>> incr_list([None])\n    Traceback (most recent call last):\n        ...\n    ValueError: List must not contain None values.\n    \"\"\"\n    \n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    if any(element is None for element in l):\n        raise ValueError(\"List must not contain None values.\")\n    \n    if not all(isinstance(element, int) for element in l):\n        raise TypeError(\"All elements in the list must be integers.\")\n    \n    return [element + 1 for element in l]\n\n# Unit tests\ndef test_incr_list():\n    assert incr_list([1, 2, 3]) == [2, 3, 4]\n    assert incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    assert incr_list([]) == []\n    \n    try:\n        incr_list([None])\n    except ValueError as e:\n        assert str(e) == \"List must not contain None values.\"\n\n    try:\n        incr_list([\"a\", \"b\", \"c\"])\n    except TypeError as e:\n        assert str(e) == \"All elements in the list must be integers.\"\n\n    try:\n        incr_list(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"Input must be a list.\"\n\n# Run tests\ntest_incr_list()"}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, returns the area of a triangle.\n    Args:\n        a (float): The length of the base of the triangle.\n        h (float): The height of the triangle measured perpendicular from the base.\n    Returns:\n        float: The area of the triangle.\n    \n    Raises:\n        ValueError: If 'a' or 'h' is not a positive number.\n    \n    Examples:\n    >>> triangle_area(5, 3)\n    7.5\n    >>> triangle_area(7, 4)\n    14.0\n    \"\"\"\n    # Type checking\n    if not isinstance(a, (int, float)) or not isinstance(h, (int, float)):\n        raise TypeError(\"Both 'a' and 'h' must be numbers (int or float)\")\n\n    # Value checking\n    if a <= 0 or h <= 0:\n        raise ValueError(\"'a' and 'h' must be positive numbers\")\n\n    # Area calculation\n    return 0.5 * a * h\n\n\n# Unit tests\nimport unittest\n\nclass TestTriangleArea(unittest.TestCase):\n\n    def test_typical_case(self):\n        self.assertAlmostEqual(triangle_area(5, 3), 7.5)\n        self.assertAlmostEqual(triangle_area(7, 4), 14.0)\n\n    def test_floats(self):\n        self.assertAlmostEqual(triangle_area(5.0, 3.0), 7.5)\n        self.assertAlmostEqual(triangle_area(7.1, 4.6), 16.33, places=2)\n\n    def test_zero_or_negative(self):\n        with self.assertRaises(ValueError):\n            triangle_area(0, 3)\n        with self.assertRaises(ValueError):\n            triangle_area(5, 0)\n        with self.assertRaises(ValueError):\n            triangle_area(-5, 3)\n        with self.assertRaises(ValueError):\n            triangle_area(5, -3)\n\n    def test_non_numeric(self):\n        with self.assertRaises(TypeError):\n            triangle_area('a', 3)\n        with self.assertRaises(TypeError):\n            triangle_area(5, 'h')\n        with self.assertRaises(TypeError):\n            triangle_area([5], 3)\n        with self.assertRaises(TypeError):\n            triangle_area(5, {3})\n\n# Running the tests\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"\n    Return median of elements in the list l.\n    \n    - If the number of elements is odd, return the middle element.\n    - If the number of elements is even, return the average of the two middle elements.\n    \n    If l is empty, raise a ValueError.\n    \n    Parameters:\n    l (list): List of numerical elements.\n    \n    Returns:\n    float: The median value.\n    \n    Examples:\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if the list is empty\n    if len(l) == 0:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Sort the list\n    l_sorted = sorted(l)\n    \n    # Calculate the median\n    n = len(l_sorted)\n    mid = n // 2\n\n    if n % 2 == 0:\n        # If even number of elements, median is the average of the two middle elements\n        return (l_sorted[mid - 1] + l_sorted[mid]) / 2.0\n    else:\n        # If odd number of elements, median is the middle element\n        return l_sorted[mid]\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional tests\n    try:\n        print(median([]))  # Should raise ValueError\n    except ValueError as e:\n        print(e)  # Expected output\n\n    try:\n        print(median(\"not a list\"))  # Should raise TypeError\n    except TypeError as e:\n        print(e)  # Expected output\n\n    print(median([1]))  # 1\n    print(median([1, 2]))  # 1.5\n    print(median([1, 2, 3, 4, 5]))  # 3\n    print(median([5, 6, 7, 8, 9, 10]))  # 7.5"}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    \n    # Type checks\n    if not isinstance(n, int) or not isinstance(p, int):\n        raise ValueError(\"Both n and p must be integers\")\n    \n    if p <= 0:\n        raise ValueError(\"p must be a positive integer\")\n    \n    # Use Python's built-in pow function with three arguments for efficient computation\n    # pow(x, y, z) computes (x ** y) % z efficiently\n    return pow(2, n, p)\n\n\n# Testing the function with test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional edge case tests\n    print(modp(0, 1))  # Should handle modulo 1\n    print(modp(0, 2))  # Should return 1 since 2^0 is 1\n    print(modp(1, 2))  # Should return 0 because 2^1 % 2 is 0\n    print(modp(15, 16))  # Should return 8 because 2^15 % 16 is 8\n    print(modp(100000, 99991))  # Large n example\n    print(modp(213, 100003)) # Random additional case"}
{"task_id": "HumanEval/43", "completion": "from typing import List\n\n\ndef pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    \n    :param l: List of integers\n    :return: True if there are two distinct elements in the list that sum to zero, False otherwise.\n    \n    Examples:\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    \n    # Type check for input\n    if not isinstance(l, list):\n        raise TypeError(\"Input should be a list of integers\")\n    \n    # Edge case: If list is empty or contains only one element, it's impossible to find two elements that sum to zero\n    if len(l) < 2:\n        return False\n    \n    # Set for storing seen elements\n    seen = set()\n    \n    for number in l:\n        # Check if the negation of the current number is in the seen set\n        if -number in seen:\n            return True\n        # Add the current number to the seen set\n        seen.add(number)\n    \n    return False\n\n# Unit tests\ndef test_pairs_sum_to_zero():\n    assert pairs_sum_to_zero([1, 3, 5, 0]) == False\n    assert pairs_sum_to_zero([1, 3, -2, 1]) == False\n    assert pairs_sum_to_zero([1, 2, 3, 7]) == False\n    assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True\n    assert pairs_sum_to_zero([1]) == False\n    assert pairs_sum_to_zero([1, -1]) == True\n    assert pairs_sum_to_zero([0, 0]) == True\n    assert pairs_sum_to_zero([]) == False\n    assert pairs_sum_to_zero([42, -42, 17]) == True\n    assert pairs_sum_to_zero([1, 5, -6, 6, 12, -4, 4]) == True\n    \n    # Type checks\n    try:\n        pairs_sum_to_zero(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"Input should be a list of integers\"\n    else:\n        assert False, \"TypeError not raised\"\n\n    try:\n        pairs_sum_to_zero(None)\n    except TypeError as e:\n        assert str(e) == \"Input should be a list of integers\"\n    else:\n        assert False, \"TypeError not raised\"\n\n# Run tests\ntest_pairs_sum_to_zero()\n"}
{"task_id": "HumanEval/48", "completion": "import re\nimport unittest\n\ndef is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    - Ignores non-alphanumeric characters\n    - Case insensitive\n\n    Args:\n        text (str): The string to check for palindrome.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('A man, a plan, a canal, Panama')\n    True\n    >>> is_palindrome('No lemon, no melon')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Filter the text to include only alphanumeric characters and ignore case\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text).lower()\n\n    # Check palindrome by comparing the cleaned text to its reverse\n    return cleaned_text == cleaned_text[::-1]\n\n# Unit tests\nclass TestIsPalindrome(unittest.TestCase):\n    def test_empty_string(self):\n        self.assertTrue(is_palindrome(''))\n\n    def test_simple_palindromes(self):\n        self.assertTrue(is_palindrome('aba'))\n        self.assertTrue(is_palindrome('aaaaa'))\n        self.assertTrue(is_palindrome('Aba'))  # Case insensitivity test\n\n    def test_non_palindrome(self):\n        self.assertFalse(is_palindrome('zbcd'))\n\n    def test_ignores_non_alphanumeric(self):\n        self.assertTrue(is_palindrome('A man, a plan, a canal, Panama'))\n        self.assertTrue(is_palindrome('No lemon, no melon'))\n\n    def test_type_error(self):\n        with self.assertRaises(TypeError):\n            is_palindrome(None)\n        with self.assertRaises(TypeError):\n            is_palindrome(12321)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    \n    Args:\n    x (int): The number to be converted.\n    base (int): The base to convert the number to.\n    \n    Returns:\n    str: The string representation of the number in the specified base.\n    \n    Examples:\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \n    Raises:\n    ValueError: If base is not between 2 and 9, or if x is not a non-negative integer.\n    \"\"\"\n    \n    # Error handling for input values\n    if not isinstance(x, int) or not isinstance(base, int):\n        raise TypeError(\"Both x and base must be integers.\")\n    if x < 0:\n        raise ValueError(\"x must be a non-negative integer.\")\n    if base < 2 or base > 9:\n        raise ValueError(\"base must be between 2 and 9 inclusive.\")\n    \n    # Edge case for zero\n    if x == 0:\n        return '0'\n    \n    # Initialize the result string\n    result = ''\n    \n    # Perform the base conversion\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n\n    return result\n\n# Unit test cases\ndef test_change_base():\n    assert change_base(8, 3) == '22'\n    assert change_base(8, 2) == '1000'\n    assert change_base(7, 2) == '111'\n    assert change_base(0, 2) == '0'\n    assert change_base(5, 5) == '10'\n    assert change_base(10, 10) == '10'\n    assert change_base(1, 2) == '1'\n    \n    try:\n        change_base(-8, 3)\n    except ValueError as e:\n        assert str(e) == \"x must be a non-negative integer.\"\n\n    try:\n        change_base(8, 1)\n    except ValueError as e:\n        assert str(e) == \"base must be between 2 and 9 inclusive.\"\n    \n    try:\n        change_base(\"8\", 3)\n    except TypeError as e:\n        assert str(e) == \"Both x and base must be integers.\"\n    \n    print(\"All tests passed.\")\n\n# Run tests\ntest_change_base()"}
{"task_id": "HumanEval/51", "completion": "import re\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns string without vowels.\n    It removes both lowercase and uppercase vowels.\n    \n    Args:\n        text (str): The input string from which vowels should be removed.\n    \n    Returns:\n        str: The resultant string with all vowels removed.\n    \n    Raises:\n        TypeError: If the input is not a string.\n    \n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    \n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional unit test cases\n    assert remove_vowels('') == ''\n    assert remove_vowels(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert remove_vowels('abcdef') == 'bcdf'\n    assert remove_vowels('aaaaa') == ''\n    assert remove_vowels('aaBAA') == 'B'\n    assert remove_vowels('zbcd') == 'zbcd'\n    assert remove_vowels('TYPICAL TEXT WITH VOWELS') == 'TYPOCL TXT WTH VWLS'\n    assert remove_vowels('123456') == '123456'\n    assert remove_vowels('AEIOUaeiou') == ''\n    \n    print(\"All unit tests passed!\")"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Return True if all numbers in the list l are below threshold t.\n    \n    Args:\n        l (list): A list of integers.\n        t (int): Threshold integer value.\n\n    Returns:\n        bool: True if all elements in the list are below the threshold, False otherwise.\n        \n    Raises:\n        TypeError: If 'l' is not a list or 't' is not an integer.\n    \n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    >>> below_threshold([], 5)\n    True\n    \"\"\"\n    # Type check for 'l'\n    if not isinstance(l, list):\n        raise TypeError(\"The first argument must be a list.\")\n    \n    # Type check for 't'\n    if not isinstance(t, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    \n    # Check if all numbers are below threshold\n    return all(isinstance(x, int) and x < t for x in l)\n\n# Unit tests\nimport unittest\n\nclass TestBelowThreshold(unittest.TestCase):\n    def test_all_below_threshold(self):\n        self.assertTrue(below_threshold([1, 2, 3], 5))\n    \n    def test_some_above_threshold(self):\n        self.assertFalse(below_threshold([1, 6, 3], 5))\n    \n    def test_empty_list(self):\n        self.assertTrue(below_threshold([], 10))\n    \n    def test_threshold_negative(self):\n        self.assertFalse(below_threshold([1, -2, 3], -1))\n    \n    def test_non_integer_values(self):\n        self.assertFalse(below_threshold([1, \"2\", 3], 5))\n    \n    def test_type_error_first_argument(self):\n        with self.assertRaises(TypeError):\n            below_threshold(\"not a list\", 5)\n    \n    def test_type_error_second_argument(self):\n        with self.assertRaises(TypeError):\n            below_threshold([1, 2, 3], \"not an int\")\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    \n    # Validate that input is a list\n    if not isinstance(l, list):\n        raise TypeError(\"Input should be of type list.\")\n    \n    # Validate elements inside the list are integers\n    if not all(isinstance(i, int) for i in l):\n        raise ValueError(\"All elements in the list should be integers.\")\n    \n    # Separate even-indexed elements\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even-indexed elements\n    sorted_even_indices = sorted(even_indices)\n    \n    # Create new list by replacing even indices with sorted values\n    result = l[:]\n    for i, value in zip(range(0, len(l), 2), sorted_even_indices):\n        result[i] = value\n    \n    return result\n\n# Unit tests\ndef test_sort_even():\n    # Basic cases\n    assert sort_even([1, 2, 3]) == [1, 2, 3]\n    assert sort_even([5, 6, 3, 4]) == [3, 6, 5, 4]\n    \n    # More complex cases\n    assert sort_even([10, 1, 30, 2, 20, 3]) == [10, 1, 20, 2, 30, 3]\n    assert sort_even([4, 5, 6, 7, 8, 9]) == [4, 5, 6, 7, 8, 9]\n    assert sort_even([11, 12, 13, 14, 15, 16]) == [11, 12, 13, 14, 15, 16]\n    \n    # Edge cases\n    assert sort_even([]) == []\n    assert sort_even([1]) == [1]\n    assert sort_even([10, 20, 30]) == [10, 20, 30]\n    \n    # Case where all elements need sorting\n    assert sort_even([8, 3, 5, 1, 4, 2]) == [4, 3, 5, 1, 8, 2]\n    \n    # Case with non-integer elements to raise ValueError\n    try:\n        sort_even([1, 'a', 3])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list should be integers.\"\n    \n    # Case with non-list input to raise TypeError\n    try:\n        sort_even(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"Input should be of type list.\"\n\n# Run tests\ntest_sort_even()\n"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    \"\"\"\n    Returns an encoded string by shifting every character by 5 positions in the alphabet.\n    Characters are wrapped around if they exceed 'z'.\n    \n    Parameters:\n    s (str): the input string to be encoded\n    \n    Returns:\n    str: the encoded string with characters shifted by 5 positions\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if not s:\n        return \"\"\n    \n    encoded = []\n    for ch in s:\n        if 'a' <= ch <= 'z':\n            shifted = ((ord(ch) - ord('a') + 5) % 26) + ord('a')\n            encoded.append(chr(shifted))\n        else:\n            raise ValueError(\"Input string must contain only lowercase a-z characters.\")\n    \n    return \"\".join(encoded)\n\n\ndef decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with encode_shift function. Returns the decoded string\n    by reversing the shift by 5 positions in the alphabet.\n    \n    Parameters:\n    s (str): the encoded string to be decoded\n    \n    Returns:\n    str: the decoded string with characters shifted back by 5 positions\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    if not s:\n        return \"\"\n    \n    decoded = []\n    for ch in s:\n        if 'a' <= ch <= 'z':\n            shifted = ((ord(ch) - ord('a') - 5) % 26) + ord('a')\n            decoded.append(chr(shifted))\n        else:\n            raise ValueError(\"Input string must contain only lowercase a-z characters.\")\n    \n    return \"\".join(decoded)\n\n\n# Unit Tests\ndef run_tests():\n    # Typical cases\n    assert encode_shift(\"abc\") == \"fgh\", \"Test case 1 failed\"\n    assert decode_shift(\"fgh\") == \"abc\", \"Test case 1a failed\"\n    \n    assert encode_shift(\"xyz\") == \"cde\", \"Test case 2 failed\"\n    assert decode_shift(\"cde\") == \"xyz\", \"Test case 2a failed\"\n    \n    # Edge cases\n    assert encode_shift(\"\") == \"\", \"Test case 3 failed\"\n    assert decode_shift(\"\") == \"\", \"Test case 3a failed\"\n    \n    try:\n        encode_shift(\"ABC\")\n    except ValueError as e:\n        assert str(e) == \"Input string must contain only lowercase a-z characters.\", \"Test case 4 failed\"\n    \n    try:\n        decode_shift(\"123\")\n    except ValueError as e:\n        assert str(e) == \"Input string must contain only lowercase a-z characters.\", \"Test case 5 failed\"\n        \n    print(\"All test cases passed!\")\n\n\n# Run the tests\nrun_tests()"}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Parameters:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n\n    Returns:\n    bool: True if both strings consist of the same characters, False otherwise.\n    \n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Ensure the inputs are strings\n    if not isinstance(s0, str) or not isinstance(s1, str):\n        raise ValueError(\"Both inputs must be strings.\")\n    \n    # Return False immediately if either string is empty\n    if len(s0) == 0 or len(s1) == 0:\n        return False\n    \n    # Convert both strings to sets and compare\n    return set(s0) == set(s1)\n\ndef test_same_chars():\n    assert same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == True, \"Test case 1 failed\"\n    assert same_chars('abcd', 'dddddddabc') == True, \"Test case 2 failed\"\n    assert same_chars('dddddddabc', 'abcd') == True, \"Test case 3 failed\"\n    assert same_chars('eabcd', 'dddddddabc') == False, \"Test case 4 failed\"\n    assert same_chars('abcd', 'dddddddabce') == False, \"Test case 5 failed\"\n    assert same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == False, \"Test case 6 failed\"\n    assert same_chars('', '') == False, \"Test case 7 failed\"\n    assert same_chars('a', 'a') == True, \"Test case 8 failed\"\n    assert same_chars('a', 'b') == False, \"Test case 9 failed\"\n    assert same_chars('abcd', 'abec') == False, \"Test case 10 failed\"\n    \n    print(\"All test cases pass\")\n\n# Run the tests\ntest_same_chars()"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    \n    The Fibonacci sequence is defined as follows:\n    fib(0) = 0\n    fib(1) = 1\n    fib(n) = fib(n-1) + fib(n-2) for n > 1\n    \n    This function returns the n-th Fibonacci number.\n\n    Parameters:\n    n (int): the position in the Fibonacci sequence to retrieve, which must be a non-negative integer.\n\n    Returns:\n    int: the n-th Fibonacci number.\n\n    Raises:\n    ValueError: if n is negative.\n    TypeError: if n is not an integer.\n    \n    Example usages:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    # Type check for the input\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Check if input is non-negative\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    # Handle base case\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Use iterative approach for better performance\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n\n# Unit Testing\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional unit tests\n    assert fib(0) == 0, \"Test case failed: fib(0) should be 0\"\n    assert fib(1) == 1, \"Test case failed: fib(1) should be 1\"\n    assert fib(2) == 1, \"Test case failed: fib(2) should be 1\"\n    assert fib(3) == 2, \"Test case failed: fib(3) should be 2\"\n    assert fib(4) == 3, \"Test case failed: fib(4) should be 3\"\n    assert fib(10) == 55, \"Test case failed: fib(10) should be 55\"\n    assert fib(20) == 6765, \"Test case failed: fib(20) should be 6765\"\n    try:\n        fib(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be a non-negative integer\"\n    try:\n        fib(\"string\")\n    except TypeError as e:\n        assert str(e) == \"Input must be an integer\"\n\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int) -> int:\n    \"\"\"\n    Add two numbers x and y and return the result\n    \n    Args:\n    x (int): The first number.\n    y (int): The second number.\n\n    Returns:\n    int: The sum of x and y.\n    \n    Raises:\n    TypeError: If either x or y is not an integer.\n\n    Examples:\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    \n    # Check that inputs are integers\n    if not isinstance(x, int):\n        raise TypeError(f'Expected x to be an integer, got {type(x).__name__}')\n    if not isinstance(y, int):\n        raise TypeError(f'Expected y to be an integer, got {type(y).__name__}')\n    \n    return x + y\n\n# Adding test cases using assertions to simulate unit tests\n# These are basic/typical scenarios\nassert add(2, 3) == 5, \"Test case 1 failed\"\nassert add(5, 7) == 12, \"Test case 2 failed\"\n\n# Edge cases\nassert add(0, 0) == 0, \"Test case 3 failed\"  # Testing zero values\nassert add(-1, 1) == 0, \"Test case 4 failed\"  # Testing negative and positive values leading to zero\nassert add(-5, -5) == -10, \"Test case 5 failed\"  # Testing two negative values\n\n# Large numbers to check performance and handling of big integers\nassert add(1000000000, 2000000000) == 3000000000, \"Test case 6 failed\"\n\nprint(\"All test cases passed!\")"}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    Args:\n        l1 (list): The first list of elements.\n        l2 (list): The second list of elements.\n    \n    Returns:\n        list: A sorted list of unique common elements between l1 and l2.\n        \n    Examples:\n        >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n        [1, 5, 653]\n        >>> common([5, 3, 2, 8], [3, 2])\n        [2, 3]\n    \"\"\"\n    # Type checks\n    if not isinstance(l1, list):\n        raise TypeError(\"First argument must be a list\")\n    if not isinstance(l2, list):\n        raise TypeError(\"Second argument must be a list\")\n\n    # Remove duplicates by converting to set\n    set_l1, set_l2 = set(l1), set(l2)\n    \n    # Find common elements using set intersection\n    common_elements = set_l1.intersection(set_l2)\n    \n    # Convert to sorted list\n    result = sorted(common_elements)\n    \n    return result\n\n# Unit test cases\n\ndef test_common():\n    assert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert common([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert common([], [3, 2]) == []\n    assert common([5, 3, 2, 8], []) == []\n    assert common([], []) == []\n    assert common([1, 1, 1], [1]) == [1]\n    assert common([1, 2, 3], [4, 5, 6]) == []\n    try:\n        common({}, [1, 2, 3])\n    except TypeError as e:\n        assert str(e) == \"First argument must be a list\"\n    try:\n        common([1, 2, 3], {})\n    except TypeError as e:\n        assert str(e) == \"Second argument must be a list\"\n    print(\"All tests passed.\")\n\ntest_common()"}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int) -> int:\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    \n    Args:\n        n (int): The index of the fib4 sequence element to compute.\n    \n    Returns:\n        int: The n-th element of the fib4 sequence.\n    \n    Raises:\n        TypeError: If n is not an integer.\n        ValueError: If n is negative.\n    \n    Examples:\n        >>> fib4(5)\n        4\n        >>> fib4(6)\n        8\n        >>> fib4(7)\n        14\n    \"\"\"\n    # Type and value checks\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    \n    # Handle base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    if n == 3:\n        return 0\n\n    # Initialize the first four elements\n    fib4_seq = [0, 0, 2, 0]\n\n    # Iterate to compute the nth element\n    for i in range(4, n + 1):\n        next_value = fib4_seq[i - 1] + fib4_seq[i - 2] + fib4_seq[i - 3] + fib4_seq[i - 4]\n        fib4_seq.append(next_value)\n\n    return fib4_seq[n]\n\n# Unit tests\ndef test_fib4():\n    # Test base cases\n    assert fib4(0) == 0, \"Test case 0 failed\"\n    assert fib4(1) == 0, \"Test case 1 failed\"\n    assert fib4(2) == 2, \"Test case 2 failed\"\n    assert fib4(3) == 0, \"Test case 3 failed\"\n\n    # Test some known values\n    assert fib4(4) == 2, \"Test case 4 failed\"\n    assert fib4(5) == 4, \"Test case 5 failed\"\n    assert fib4(6) == 8, \"Test case 6 failed\"\n    assert fib4(7) == 14, \"Test case 7 failed\"\n\n    # Test larger value\n    assert fib4(10) == 68, \"Test case 10 failed\"\n    assert fib4(20) == 11400, \"Test case 20 failed\"\n\n    # Test edge cases\n    try:\n        fib4(-1)\n    except ValueError:\n        pass\n    else:\n        assert False, \"Negative input test case failed\"\n\n    try:\n        fib4(3.5)\n    except TypeError:\n        pass\n    else:\n        assert False, \"Non-integer input test case failed\"\n\n    print(\"All test cases passed!\")\n\ntest_fib4()\n"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    \n    Args:\n        l (list): The list of elements to check.\n    \n    Returns:\n        bool: True if the list is monotonically increasing or decreasing, False otherwise.\n    \n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if not isinstance(l, list):\n        raise TypeError(\"The input must be a list.\")\n\n    if len(l) == 0:\n        return True\n    \n    increasing = decreasing = True\n\n    for i in range(1, len(l)):\n        if l[i] > l[i - 1]:\n            decreasing = False\n        if l[i] < l[i - 1]:\n            increasing = False\n\n    return increasing or decreasing\n\n# Unit tests\n\ndef test_monotonic():\n    # Test increasing list\n    assert monotonic([1, 2, 3, 4]) == True\n\n    # Test decreasing list\n    assert monotonic([4, 3, 2, 1]) == True\n\n    # Test mixed list\n    assert monotonic([1, 3, 2, 4]) == False\n\n    # Test single element list\n    assert monotonic([1]) == True\n\n    # Test empty list\n    assert monotonic([]) == True\n\n    # Test constant list\n    assert monotonic([2, 2, 2, 2]) == True\n\n    # Test large dataset\n    large_list_increasing = list(range(1000000))\n    assert monotonic(large_list_increasing) == True\n\n    large_list_decreasing = list(range(1000000, 0, -1))\n    assert monotonic(large_list_decreasing) == True\n\n    # Test with incorrect input type\n    try:\n        monotonic(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"The input must be a list.\"\n\n    print(\"All tests passed.\")\n\ntest_monotonic()"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    brackets is a string of \"(\" and \")\".\n    Return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    # Initialize a counter for open brackets\n    open_count = 0\n    \n    # Iterate over each character in the string\n    for char in brackets:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            open_count -= 1\n        else:\n            # This case shouldn't happen as the input is defined to be only \"(\" and \")\"\n            raise ValueError(\"The input string contains invalid characters\")\n        \n        # If open_count becomes negative, it means a closing bracket appeared before a corresponding opening bracket\n        if open_count < 0:\n            return False\n    \n    # If open_count is zero, all opened brackets have been closed properly\n    return open_count == 0\n\n\n# Example unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    assert correct_bracketing(\"\") == True, \"Test case with empty string failed\"\n    assert correct_bracketing(\"(()(()))\") == True, \"Test case 1 failed\"\n    assert correct_bracketing(\"((())\") == False, \"Test case 2 failed\"\n    assert correct_bracketing(\"()()()\") == True, \"Test case 3 failed\"\n    assert correct_bracketing(\"())(()\") == False, \"Test case 4 failed\"\n    assert correct_bracketing(\")(\") == False, \"Test case 5 failed\"\n    print(\"All test cases passed!\")"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    \n    # Check if the input is a valid list of numbers\n    if not isinstance(xs, list) or not all(isinstance(x, (int, float)) for x in xs):\n        raise ValueError(\"Input must be a list of numbers\")\n    \n    # Handle the case of empty list or null values\n    if xs == []:\n        return []\n    \n    # Initialize an empty list for the derivative coefficients\n    derivative_coefficients = []\n    \n    # Loop through the list starting from the second element\n    # The zeroth element is skipped because its derivative (constant term) is zero\n    for i in range(1, len(xs)):\n        derivative_coefficients.append(xs[i] * i)\n    \n    return derivative_coefficients\n\n\n# Testing function\ndef test_derivative():\n    # Test with example cases\n    assert derivative([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert derivative([1, 2, 3]) == [2, 6]\n    \n    # Edge cases\n    assert derivative([]) == []\n    assert derivative([5]) == []\n    \n    # Polynomials where coefficients are all zeros\n    assert derivative([0, 0, 0]) == [0, 0]\n    \n    # Test with negative coefficients\n    assert derivative([-1, -2, -3, -4]) == [-2, -6, -12]\n    \n    # All coefficients are large numbers\n    assert derivative([1000000, 2000000, 3000000]) == [2000000, 6000000]\n    \n    print(\"All tests passed.\")\n\n# Run tests\ntest_derivative()\n"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if not isinstance(n, int) or n <= 1:\n        raise ValueError(\"Input must be an integer greater than 1.\")\n\n    # Function to find the largest prime factor\n    def max_prime_factor(n):\n        # Initialize the largest factor to 1\n        max_factor = 1\n\n        # Check for divisibility by 2\n        while n % 2 == 0:\n            max_factor = 2\n            n //= 2\n\n        # Check for odd factors from 3 up to the square root of n\n        factor = 3\n        while factor * factor <= n:\n            while n % factor == 0:\n                max_factor = factor\n                n //= factor\n            factor += 2\n\n        # If n is still a prime number greater than 2\n        if n > 2:\n            max_factor = n\n\n        return max_factor\n\n    return max_prime_factor(n)\n\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases to cover more scenarios\n    assert largest_prime_factor(15) == 5, \"Test Case 1 Failed\"\n    assert largest_prime_factor(77) == 11, \"Test Case 2 Failed\"\n    assert largest_prime_factor(49) == 7, \"Test Case 3 Failed\"\n    assert largest_prime_factor(10403) == 101, \"Test Case 4 Failed\"\n    assert largest_prime_factor(135) == 5, \"Test Case 5 Failed\"\n\n    try:\n        largest_prime_factor(-5)\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer greater than 1.\", \"Test Case 6 Failed\"\n\n    try:\n        largest_prime_factor(1)\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer greater than 1.\", \"Test Case 7 Failed\"\n\n    print(\"All test cases passed!\")"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int) -> int:\n    \"\"\"\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    \n    Parameters:\n    n (int): The index of the sequence.\n    \n    Returns:\n    int: The n-th element of the FibFib number sequence.\n    \n    Raises:\n    TypeError: If the input is not an integer.\n    ValueError: If the input is a negative integer.\n    \n    Example:\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n\n    # Type check for the input\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    # Base conditions\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    # Array to store the FibFib sequence values\n    # Initialize with base conditions\n    fibfib_sequence = [0, 0, 1]\n\n    # Compute the sequence iteratively for performance\n    for i in range(3, n + 1):\n        next_value = fibfib_sequence[-1] + fibfib_sequence[-2] + fibfib_sequence[-3]\n        fibfib_sequence.append(next_value)\n    \n    return fibfib_sequence[n]\n\n# Unit tests\ndef test_fibfib():\n    assert fibfib(0) == 0\n    assert fibfib(1) == 0\n    assert fibfib(2) == 1\n    assert fibfib(3) == 1\n    assert fibfib(4) == 2\n    assert fibfib(5) == 4\n    assert fibfib(6) == 7\n    assert fibfib(7) == 13\n    assert fibfib(8) == 24\n    assert fibfib(9) == 44\n    assert fibfib(10) == 81\n\n    print(\"All test cases pass.\")\n\n# Run tests\ntest_fibfib()"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Ensure string is non-empty and has at least one character\n    if not s:\n        return 0\n\n    # Define vowels\n    vowels = set('aeiou')\n\n    # Convert string to lowercase for case insensitive comparison\n    s_lower = s.lower()\n\n    # Initialize count of vowels\n    count = 0\n\n    # Loop through the string to count vowels\n    for i in range(len(s_lower)):\n        if s_lower[i] in vowels:\n            count += 1\n\n    # Check if the last character is 'y'\n    if s_lower.endswith('y'):\n        count += 1\n        \n    return count\n\n# Unit test cases\nimport unittest\n\nclass TestVowelsCount(unittest.TestCase):\n    def test_typical_cases(self):\n        self.assertEqual(vowels_count(\"abcde\"), 2)\n        self.assertEqual(vowels_count(\"ACEDY\"), 3)\n        self.assertEqual(vowels_count(\"hello\"), 2)\n        self.assertEqual(vowels_count(\"Jelly\"), 2)\n    \n    def test_edge_cases(self):\n        self.assertEqual(vowels_count(\"\"), 0)\n        self.assertEqual(vowels_count(\"AEIOU\"), 5)\n        self.assertEqual(vowels_count(\"xyz\"), 1)\n        self.assertEqual(vowels_count(\"why\"), 1)\n        self.assertEqual(vowels_count(\"bcdfg\"), 0)\n\n    def test_input_type(self):\n        with self.assertRaises(TypeError):\n            vowels_count(12345)\n        with self.assertRaises(TypeError):\n            vowels_count(None)\n        with self.assertRaises(TypeError):\n            vowels_count([])\n\n# Run tests\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    \"\"\"\n    Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The sum of the ASCII codes of the uppercase characters in the input string.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    \n    # Type check\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Corner case: empty string\n    if s == \"\":\n        return 0\n\n    sum_upper_ascii = sum(ord(char) for char in s if 'A' <= char <= 'Z')\n\n    return sum_upper_ascii\n\n# Adding unit tests to verify the implementation\n\ndef test_digitSum():\n    assert digitSum(\"\") == 0\n    assert digitSum(\"abAB\") == 131\n    assert digitSum(\"abcCd\") == 67\n    assert digitSum(\"helloE\") == 69\n    assert digitSum(\"woArBld\") == 131\n    assert digitSum(\"aAaaaXa\") == 153\n    assert digitSum(\"XYZ\") == 88 + 89 + 90\n    assert digitSum(\"1234ABCD\") == 65 + 66 + 67 + 68\n    assert digitSum(\"lowercase\") == 0\n    assert digitSum(\"ALLUPPER\") == sum(ord(char) for char in \"ALLUPPER\")\n\n    print(\"All test cases passed!\")\n\n# Running the tests\ntest_digitSum()"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    # Initialize a counter to track unmatched opening brackets\n    counter = 0\n\n    # Iterate through each character in the input string\n    for char in brackets:\n        if char == '<':\n            # Increment counter for every opening bracket\n            counter += 1\n        elif char == '>':\n            # Decrement counter for every closing bracket\n            counter -= 1\n            # If the counter goes negative, there are unmatched closing brackets\n            if counter < 0:\n                return False\n\n    # If the counter is zero, all opening brackets are matched\n    return counter == 0\n\n# Unit tests to validate the implementation\ndef test_correct_bracketing():\n    assert correct_bracketing(\"<\") == False\n    assert correct_bracketing(\"<>\") == True\n    assert correct_bracketing(\"<<><>>\") == True\n    assert correct_bracketing(\"><<>\") == False\n    assert correct_bracketing(\"\") == True\n    assert correct_bracketing(\"<<>>\") == True\n    assert correct_bracketing(\"<><><><>\") == True\n    assert correct_bracketing(\"<<><>><><><>>\") == True\n    assert correct_bracketing(\"><\") == False\n    assert correct_bracketing(\"<>><<\") == False\n    assert correct_bracketing(\"<<>><>\") == True\n    assert correct_bracketing(\"<<><<>>><>><<>><>><<>>>>>\") == False\n\n    # Edge cases\n    try:\n        correct_bracketing(None)\n    except TypeError as e:\n        print(e)\n\n    try:\n        correct_bracketing(123)\n    except TypeError as e:\n        print(e)\n\ntest_correct_bracketing()"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n\n    Args:\n        n (int): The upper limit of the range of numbers to sum.\n\n    Returns:\n        int: The sum of numbers from 1 to n.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Examples:\n        >>> sum_to_n(30)\n        465\n        >>> sum_to_n(100)\n        5050\n        >>> sum_to_n(5)\n        15\n        >>> sum_to_n(10)\n        55\n        >>> sum_to_n(1)\n        1\n    \"\"\"\n    # Check if the input is a valid positive integer\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Using the formula for the sum of the first n natural numbers: n * (n + 1) // 2\n    return n * (n + 1) // 2\n\n\n# Unit tests\ndef test_sum_to_n():\n    # Testing typical scenarios\n    assert sum_to_n(30) == 465\n    assert sum_to_n(100) == 5050\n    assert sum_to_n(5) == 15\n    assert sum_to_n(10) == 55\n    assert sum_to_n(1) == 1\n    \n    # Testing edge cases\n    try:\n        sum_to_n(0)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    try:\n        sum_to_n(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    try:\n        sum_to_n(\"10\")\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    try:\n        sum_to_n(None)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    print(\"All tests passed!\")\n\n\n# Run unit tests\ntest_sum_to_n()"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    Args:\n    x (int): The integer whose digits are to be shifted.\n    shift (int): The number of positions to shift the digits to the right.\n\n    Returns:\n    str: The result of the circular shift, as a string.\n\n    Raises:\n    TypeError: If x is not an integer or shift is not an integer.\n    ValueError: If x is negative.\n    \n    Examples:\n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    \"\"\"\n    \n    # Type checks\n    if not isinstance(x, int) or not isinstance(shift, int):\n        raise TypeError(\"Both x and shift must be integers.\")\n    \n    # Value check for non-negative integer\n    if x < 0:\n        raise ValueError(\"x must be a non-negative integer.\")\n    \n    digits = list(str(x))\n    n = len(digits)\n    \n    # If shift is greater than or equal to number of digits, return the reversed digits\n    if shift >= n:\n        return ''.join(digits[::-1])\n    \n    # Perform circular shift using list slicing\n    shift = shift % n  # Ensure shift is within the range of digits\n    return ''.join(digits[-shift:] + digits[:-shift])\n\n# Unit tests\ndef test_circular_shift():\n    # Test typical scenarios\n    assert circular_shift(12345, 1) == \"51234\"\n    assert circular_shift(12345, 3) == \"34512\"\n    assert circular_shift(123, 2) == \"312\"\n    \n    # Test edge cases\n    assert circular_shift(0, 1) == \"0\"\n    assert circular_shift(12, 2) == \"12\"  # Complete circular shift\n    assert circular_shift(1234, 4) == \"4321\"  # Shift equal to number of digits\n    \n    try:\n        circular_shift(\"123\", 2)\n    except TypeError as e:\n        assert str(e) == \"Both x and shift must be integers.\"\n    \n    try:\n        circular_shift(123, \"2\")\n    except TypeError as e:\n        assert str(e) == \"Both x and shift must be integers.\"\n    \n    try:\n        circular_shift(-123, 2)\n    except ValueError as e:\n        assert str(e) == \"x must be a non-negative integer.\"\n\n    # Large number test\n    assert circular_shift(1234567890, 15) == \"8901234567\"\n\n# Running the tests\ntest_circular_shift()"}
{"task_id": "HumanEval/70", "completion": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting is when you start with the minimum value,\n    then the maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    # Check if the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be of type list\")\n\n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in lst):\n        raise ValueError(\"All elements in the list should be integers\")\n\n    # Edge case: if the list is empty, return the empty list\n    if not lst:\n        return lst\n\n    # Sorting the list for easy retrieval of min and max values\n    lst.sort()\n    \n    result = []\n\n    # Loop until the sorted list is empty\n    while lst:\n        # Add the minimum element\n        result.append(lst.pop(0))  # pop index 0 for the smallest element\n        if lst:\n            # Add the maximum element (from the remaining numbers)\n            result.append(lst.pop(-1))  # pop index -1 for the largest element\n\n    return result\n\n# Unit tests\nassert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\nassert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\nassert strange_sort_list([]) == []\nassert strange_sort_list([10, 30, 20, 40]) == [10, 40, 20, 30]\nassert strange_sort_list([-10, -20, -30, -40]) == [-40, -10, -30, -20]\n\nprint(\"All tests passed!\")\n"}
{"task_id": "HumanEval/67", "completion": "import re\nimport unittest\n\ndef fruit_distribution(s, n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n    \n    if not isinstance(s, str) or not isinstance(n, int):\n        raise ValueError(\"Input types are incorrect: s should be a string and n should be an integer\")\n\n    # Find all integers in the string\n    numbers = re.findall(r'\\d+', s)\n    \n    # Convert them to integers\n    numbers = list(map(int, numbers))\n    \n    if len(numbers) != 2:\n        raise ValueError(\"Input string does not contain exactly two integers representing apples and oranges\")\n\n    apples, oranges = numbers\n\n    if apples < 0 or oranges < 0 or n < 0:\n        raise ValueError(\"Numbers in the input and the total number of fruits must not be negative\")\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    if mangoes < 0:\n        raise ValueError(\"Total number of fruits in the basket cannot be less than the sum of apples and oranges\")\n    \n    return mangoes\n\n# Unit tests\nclass TestFruitDistribution(unittest.TestCase):\n    \n    def test_basic_cases(self):\n        self.assertEqual(fruit_distribution(\"5 apples and 6 oranges\", 19), 8)\n        self.assertEqual(fruit_distribution(\"0 apples and 1 oranges\", 3), 2)\n        self.assertEqual(fruit_distribution(\"2 apples and 3 oranges\", 100), 95)\n        self.assertEqual(fruit_distribution(\"100 apples and 1 oranges\", 120), 19)\n    \n    def test_no_apples_or_oranges(self):\n        self.assertEqual(fruit_distribution(\"0 apples and 0 oranges\", 10), 10)\n    \n    def test_large_numbers(self):\n        self.assertEqual(fruit_distribution(\"1000 apples and 2000 oranges\", 10000), 7000)\n    \n    def test_invalid_input_types(self):\n        with self.assertRaises(ValueError):\n            fruit_distribution(123, 100)\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"5 apples and 6 oranges\", \"100\")\n    \n    def test_invalid_string_format(self):\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"5 apples, 6 oranges and 1 mango\", 19)\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"just some random text\", 19)\n    \n    def test_negative_values(self):\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"5 apples and -6 oranges\", 24)\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"-5 apples and 6 oranges\", 5)\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"5 apples and 6 oranges\", -10)\n    \n    def test_total_less_than_sum_of_apples_oranges(self):\n        with self.assertRaises(ValueError):\n            fruit_distribution(\"5 apples and 6 oranges\", 10)\n            fruit_distribution(\"5 apples and 6 oranges\", 6)\n\nif __name__ == '__main__':\n    unittest.main()"}
{"task_id": "HumanEval/39", "completion": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num == 2:\n        return True  # 2 is the only even prime number\n    if num % 2 == 0:\n        return False  # All other even numbers are not prime\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    def generate_fibonacci():\n        \"\"\"Generator to yield Fibonacci numbers.\"\"\"\n        a, b = 1, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    count = 0\n    for fib in generate_fibonacci():\n        if is_prime(fib):\n            count += 1\n            if count == n:\n                return fib\n\n# Unit tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    assert prime_fib(1) == 2\n    assert prime_fib(2) == 3\n    assert prime_fib(3) == 5\n    assert prime_fib(4) == 13\n    assert prime_fib(5) == 89\n    assert prime_fib(6) == 233\n    assert prime_fib(7) == 1597\n\n    try:\n        prime_fib(0)\n    except ValueError as ve:\n        assert str(ve) == \"Input must be a positive integer.\"\n\n    try:\n        prime_fib(-1)\n    except ValueError as ve:\n        assert str(ve) == \"Input must be a positive integer.\"\n\n    try:\n        prime_fib(\"a\")\n    except ValueError as ve:\n        assert str(ve) == \"Input must be a positive integer.\"\n\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n    \n    # Type checks\n    if not isinstance(w, (int, float)) or w < 0:\n        raise ValueError(\"Maximum possible weight should be a non-negative number.\")\n    \n    if not isinstance(q, list):\n        raise ValueError(\"The first argument should be a list.\")\n    \n    # Empty list case\n    if not q:\n        return True  # An empty list is trivially balanced and its sum is 0\n\n    # Check if the list is palindromic\n    if q != q[::-1]:\n        return False\n    \n    # Check if the sum of elements is less than or equal to w\n    if sum(q) <= w:\n        return True\n    else:\n        return False\n\n# Unit tests\ndef test_will_it_fly():\n    # Balanced and sum within limit\n    assert will_it_fly([3, 2, 3], 9) == True\n    # Balanced and sum at the limit\n    assert will_it_fly([3, 2, 3], 8) == True\n    # Unbalanced list\n    assert will_it_fly([1, 2], 5) == False\n    # Balanced but sum exceeds the limit\n    assert will_it_fly([3, 2, 3], 1) == False\n    # Single element list\n    assert will_it_fly([3], 5) == True\n    # Empty list\n    assert will_it_fly([], 5) == True\n    # Various types and value errors\n    try:\n        will_it_fly([1, 2, 3], -1)\n    except ValueError:\n        pass\n    try:\n        will_it_fly(123, 5)\n    except ValueError:\n        pass\n    \n    print(\"All tests passed!\")\n\n# Run tests\ntest_will_it_fly()"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list\")\n\n    if not all(isinstance(x, int) and x >= 0 for x in arr):\n        raise ValueError(\"All elements in the array must be non-negative integers\")\n\n    smallest_even = float('inf')\n    index_of_smallest = -1\n\n    for i, value in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even:\n            smallest_even = value\n            index_of_smallest = i\n    \n    if index_of_smallest == -1:\n        return []\n    else:\n        return [smallest_even, index_of_smallest]\n\n# Unit test cases\n\ndef test_pluck():\n    # Test cases from the docstring\n    assert pluck([4, 2, 3]) == [2, 1]\n    assert pluck([1, 2, 3]) == [2, 1]\n    assert pluck([]) == []\n    assert pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n\n    # Additional test cases\n    assert pluck([1, 3, 5, 7]) == []\n    assert pluck([2, 4, 6, 8]) == [2, 0]\n    assert pluck([9, 7, 5, 3, 2]) == [2, 4]\n    assert pluck([8, 6, 4, 2]) == [2, 3]\n    assert pluck([11, 13, 17, 10, 18, 14]) == [10, 3]\n    assert pluck([0, 0, 0, 0]) == [0, 0]\n\n    print(\"All tests passed!\")\n\ntest_pluck()"}
{"task_id": "HumanEval/69", "completion": "from collections import Counter\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    \n    # Handle edge cases: empty list or None\n    if not lst:\n        raise ValueError(\"The input list should not be empty or None.\")\n    \n    # Use Counter to get frequencies of each element\n    frequency = Counter(lst)\n    \n    # Filter and collect elements that satisfy the condition\n    valid_elements = [num for num, count in frequency.items() if num > 0 and count >= num]\n    \n    # Return the greatest valid element or -1 if none found\n    return max(valid_elements, default=-1)\n\n# Unit test cases to validate the implementation\ndef test_search():\n    assert search([4, 1, 2, 2, 3, 1]) == 2, \"Test case 1 failed\"\n    assert search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3, \"Test case 2 failed\"\n    assert search([5, 5, 4, 4, 4]) == -1, \"Test case 3 failed\"\n    assert search([6, 6, 6, 6, 6, 6]) == 6, \"Test case 4 failed\"\n    assert search([10] * 9) == -1, \"Test case 5 failed\"\n    assert search([1]) == 1, \"Test case 6 failed\"\n    assert search([2, 2, 5, 5, 5, 7, 7, 7, 7, 7]) == 5, \"Test case 7 failed\"\n    \n    print(\"All test cases pass\")\n\n# Running the tests\ntest_search()"}
{"task_id": "HumanEval/77", "completion": "\nimport math\n\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n\n    # Handle the special case for 0 since 0 is a cube (0^3 = 0)\n    if a == 0:\n        return True\n\n    # Calculate the cube root as a floating-point number\n    cube_root = a ** (1/3)\n\n    # Ensure we correctly round the cube root for both positive and negative numbers\n    rounded_close = round(cube_root)  # Closest integer cube root\n\n    # Check if the rounded cube's cube is equal to the input a\n    return rounded_close ** 3 == a\n\n\n# Unit tests\n\ndef test_iscube():\n    assert iscube(1) == True, \"Test case 1 failed\"\n    assert iscube(2) == False, \"Test case 2 failed\"\n    assert iscube(-1) == True, \"Test case 3 failed\"\n    assert iscube(64) == True, \"Test case 4 failed\"\n    assert iscube(0) == True, \"Test case 5 failed\"\n    assert iscube(180) == False, \"Test case 6 failed\"\n    assert iscube(27) == True, \"Test case 7 failed\"\n    assert iscube(-27) == True, \"Test case 8 failed\"\n    assert iscube(1000000) == True, \"Test case 9 failed\"\n    assert iscube(1000001) == False, \"Test case 10 failed\"\n    assert iscube(0) == True, \"Test case 11 failed\"  # Additional edge case\n\n    print(\"All test cases pass\")\n\n# Run tests\ntest_iscube()"}
{"task_id": "HumanEval/71", "completion": "import math\nimport unittest\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Check input types and values\n    if not all(isinstance(x, (int, float)) and x > 0 for x in [a, b, c]):\n        raise ValueError(\"All sides must be positive numbers.\")\n    \n    # Check for a valid triangle\n    if not (a + b > c and a + c > b and b + c > a):\n        return -1\n    \n    # Calculate the area using Heron's formula\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    # Return the area rounded to 2 decimal places\n    return round(area, 2)\n\n# Unit tests\nclass TestTriangleArea(unittest.TestCase):\n    def test_valid_triangle(self):\n        self.assertEqual(triangle_area(3, 4, 5), 6.00)\n        self.assertEqual(triangle_area(5, 12, 13), 30.00)\n        self.assertEqual(triangle_area(7, 8, 9), 26.83)\n    \n    def test_invalid_triangle(self):\n        self.assertEqual(triangle_area(1, 2, 10), -1)\n        self.assertEqual(triangle_area(1, 1, 2), -1)\n    \n    def test_input_types(self):\n        with self.assertRaises(ValueError):\n            triangle_area(\"a\", 4, 5)\n        with self.assertRaises(ValueError):\n            triangle_area(3, -4, 5)\n    \n    def test_edge_cases(self):\n        self.assertEqual(triangle_area(0.1, 0.1, 0.1), 0)\n        self.assertEqual(triangle_area(1e-10, 1e-10, 1e-10), 0)\n\nif __name__ == '__main__':\n    unittest.main()"}
{"task_id": "HumanEval/75", "completion": "def is_prime(n):\n    \"\"\"Helper function to determine if a number is a prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the product of exactly 3 prime numbers and False otherwise.\"\"\"\n    \n    # Input validation\n    if not isinstance(a, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    if a < 2 or a >= 100:\n        return False\n\n    prime_factors = []\n    \n    # Find prime factors of a\n    for i in range(2, a):\n        while is_prime(i) and (a % i == 0):\n            prime_factors.append(i)\n            a //= i\n        if len(prime_factors) > 3:\n            return False  # Short-circuit if we have more than 3 factors\n\n    # Check if we have exactly 3 prime factors\n    return len(prime_factors) == 3\n\n\n# Unit tests\ndef test_is_multiply_prime():\n    assert is_multiply_prime(30) == True  # 2 * 3 * 5\n    assert is_multiply_prime(60) == False  # 2 * 2 * 3 * 5 (has 4 prime factors)\n    assert is_multiply_prime(105) == True  # 3 * 5 * 7\n    assert is_multiply_prime(50) == False  # 2 * 5 * 5 (same factor appearing twice)\n    assert is_multiply_prime(89) == False  # 89 is a prime number itself\n    assert is_multiply_prime(1) == False  # No prime factors\n    assert is_multiply_prime(90) == False  # 2 * 3 * 3 * 5, more than 3 prime factors including non-unique\n    assert is_multiply_prime(6) == False  # 2 * 3 (only 2 prime factors)\n    \n    # Test with invalid inputs\n    try:\n        is_multiply_prime(\"30\")\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer.\"\n        \n    try:\n        is_multiply_prime(None)\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer.\"\n    \n    print(\"All tests passed!\")\n\ntest_is_multiply_prime()"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n ** a = x (where a is an integer)\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n    \n    # Handle edge cases\n    if not isinstance(x, (int, float)) or not isinstance(n, (int, float)):\n        raise ValueError(\"Both x and n must be numbers.\")\n    if x <= 0 or n <= 0:\n        return False\n    if n == 1:\n        return x == 1  # 1**anything is always 1\n\n    # Try to determine if log_n(x) is an integer\n    from math import log, isclose, isinf\n\n    try:\n        power = log(x, n)\n        # Check if 'power' is close to an integer\n        return isclose(power, round(power))\n    except (ValueError, OverflowError):\n        return False\n\n# Unit testing\nimport unittest\n\nclass TestIsSimplePower(unittest.TestCase):\n\n    def test_simple_cases(self):\n        self.assertTrue(is_simple_power(1, 4))\n        self.assertTrue(is_simple_power(2, 2))\n        self.assertTrue(is_simple_power(8, 2))\n        self.assertTrue(is_simple_power(27, 3))\n        \n    def test_not_powers(self):\n        self.assertFalse(is_simple_power(3, 2))\n        self.assertFalse(is_simple_power(3, 1))\n        self.assertFalse(is_simple_power(5, 3))\n        \n    def test_edge_cases(self):\n        self.assertFalse(is_simple_power(0, 4))\n        self.assertFalse(is_simple_power(4, 0))\n        self.assertFalse(is_simple_power(-1, 4))\n        \n    def test_invalid_inputs(self):\n        with self.assertRaises(ValueError):\n            is_simple_power(\"a\", 4)\n        with self.assertRaises(ValueError):\n            is_simple_power(4, \"b\")\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    # Validate input type\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"Input should be a list of integers\")\n\n    # Initialize the change counter\n    change_count = 0\n    \n    # Iterate over the array from both ends towards the middle\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] != arr[right]:\n            change_count += 1\n        left += 1\n        right -= 1\n\n    return change_count\n\n# Unit tests\ndef test_smallest_change():\n    assert smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) == 4\n    assert smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert smallest_change([1, 2, 3, 2, 1]) == 0\n    assert smallest_change([]) == 0\n    assert smallest_change([1]) == 0\n    assert smallest_change([1, 2, 1]) == 0\n    assert smallest_change([1, 3, 3, 1]) == 0\n    assert smallest_change([1, 2, 3, 4]) == 2\n\n    print(\"All tests passed.\")\n    \n# Running unit tests to validate the implementation\ntest_smallest_change()"}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    # Ensure both inputs are lists of strings, otherwise raise a TypeError\n    if not isinstance(lst1, list) or not all(isinstance(s, str) for s in lst1):\n        raise TypeError(\"lst1 should be a list of strings\")\n    if not isinstance(lst2, list) or not all(isinstance(s, str) for s in lst2):\n        raise TypeError(\"lst2 should be a list of strings\")\n    \n    # Calculate the total number of characters in both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Determine and return the list with fewer total characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1\n\n# Example usage with various test cases, including edge cases\nimport unittest\n\nclass TestTotalMatchFunction(unittest.TestCase):\n    def test_empty_lists(self):\n        self.assertEqual(total_match([], []), [])\n    \n    def test_first_list_smaller(self):\n        self.assertEqual(total_match(['hi', 'admin'], ['hI', 'Hi']), ['hI', 'Hi'])\n    \n    def test_second_list_smaller(self):\n        self.assertEqual(total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']), ['hi', 'admin'])\n    \n    def test_after_swapping(self):\n        self.assertEqual(total_match(['hi', 'admin'], ['hI', 'hi', 'hi']), ['hI', 'hi', 'hi'])\n    \n    def test_single_element_list(self):\n        self.assertEqual(total_match(['4'], ['1', '2', '3', '4', '5']), ['4'])\n    \n    def test_same_length(self):\n        self.assertEqual(total_match(['abc', 'def'], ['ghi', 'jkl']), ['abc', 'def'])\n\nif __name__ == \"__main__\":\n    unittest.main(argv=[''], exit=False)"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Sort characters within each word and rejoin the string\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Rejoin the sorted words with spaces to retain the original spaces\n    return ' '.join(sorted_words)\n\n\n# Unit tests\nassert anti_shuffle('Hi') == 'Hi', \"Test case 1 failed\"\nassert anti_shuffle('hello') == 'ehllo', \"Test case 2 failed\"\nassert anti_shuffle('Hello World!!!') == 'Hello !!!Wdlor', \"Test case 3 failed\"\nassert anti_shuffle('') == '', \"Test case 4 failed\"  # Edge case for empty string\nassert anti_shuffle('a') == 'a', \"Test case 5 failed\"  # Single character\n\nprint(\"All test cases passed.\")"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right; simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from\n    each other. All cars move at the same speed. Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \n    Args:\n    n (int): The number of cars moving in each direction.\n    \n    Returns:\n    int: The number of collisions.\n    \n    Raises:\n    TypeError: If the input is not an integer.\n    ValueError: If the input is negative.\n    \"\"\"\n    \n    # Type check to ensure input is an integer\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Value check to ensure input is non-negative\n    if n < 0:\n        raise ValueError(\"The number of cars cannot be negative\")\n    \n    # Each car moving left to right will collide with each car moving right to left.\n    # Since there are n cars in each group, there will be n * n collisions.\n    return n * n\n\n# Unit test cases to validate the implementation of the function\ndef test_car_race_collision():\n    # Test with a typical scenario\n    assert car_race_collision(3) == 9, \"Test case 1 failed\"\n    \n    # Test with larger number of cars\n    assert car_race_collision(10) == 100, \"Test case 2 failed\"\n    \n    # Test with edge case where there are no cars\n    assert car_race_collision(0) == 0, \"Test case 3 failed\"\n    \n    # Test with maximum single-digit number of cars\n    assert car_race_collision(9) == 81, \"Test case 4 failed\"\n    \n    # Test type checking with non-integer input\n    try:\n        car_race_collision(\"five\")\n    except TypeError as e:\n        assert str(e) == \"Input must be an integer\", \"Test case 5 failed\"\n    \n    # Test value checking with negative input\n    try:\n        car_race_collision(-1)\n    except ValueError as e:\n        assert str(e) == \"The number of cars cannot be negative\", \"Test case 6 failed\"\n\n# Call the test function to run all test cases\ntest_car_race_collision()\n\n# If no assertion error happens, all test cases passed\nprint(\"All test cases passed!\")"}
{"task_id": "HumanEval/82", "completion": "import math\n\ndef is_prime(n):\n    \"\"\"Check if a number n is prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise.\n    \n    Args:\n    string (str): The string to check.\n    \n    Returns:\n    bool: True if the length of the string is a prime number, False otherwise.\n    \n    Examples:\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n    \n    length = len(string)\n    return is_prime(length)\n\n# Unit tests\ndef test_prime_length():\n    assert prime_length('Hello') == True  # Length is 5, which is prime\n    assert prime_length('abcdcba') == True  # Length is 7, which is prime\n    assert prime_length('kittens') == True  # Length is 7, which is prime\n    assert prime_length('orange') == False  # Length is 6, which is not prime\n    assert prime_length('') == False  # Length is 0, which is not prime\n    assert prime_length('a') == False  # Length is 1, which is not prime\n    assert prime_length('ab') == True  # Length is 2, which is prime\n\n    # Test non-string inputs\n    try:\n        prime_length(123)\n    except ValueError as e:\n        assert str(e) == \"Input must be a string\"\n    try:\n        prime_length(None)\n    except ValueError as e:\n        assert str(e) == \"Input must be a string\"\n\n# Run unit tests\ntest_prime_length()\n\nprint(\"All tests passed.\")"}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n    \n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n    \n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n\n    # Type check for the decimal parameter\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer\")\n        \n    # Handle negative inputs explicitly as they are not usually intended\n    if decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Special case for zero, as it is a valid input and should return \"db0db\"\n    if decimal == 0:\n        return \"db0db\"\n    \n    # Convert the provided decimal number to binary using bin() and strip the '0b' prefix\n    binary_representation = bin(decimal)[2:]\n    \n    # Return the binary representation with 'db' prefixed and suffixed\n    return f\"db{binary_representation}db\"\n\n# Unit tests to validate the implementation\ndef test_decimal_to_binary():\n    assert decimal_to_binary(0) == \"db0db\", \"Test case 0 failed\"\n    assert decimal_to_binary(15) == \"db1111db\", \"Test case 15 failed\"\n    assert decimal_to_binary(32) == \"db100000db\", \"Test case 32 failed\"\n    assert decimal_to_binary(1) == \"db1db\", \"Test case 1 failed\"\n    assert decimal_to_binary(255) == \"db11111111db\", \"Test case 255 failed\"\n    \n    try:\n        decimal_to_binary(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be a non-negative integer\", \"Negative input test case failed\"\n    \n    try:\n        decimal_to_binary(\"string\")\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer\", \"String input test case failed\"\n    \n    try:\n        decimal_to_binary(3.14)\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer\", \"Float input test case failed\"\n    \n    print(\"All test cases passed.\")\n\ntest_decimal_to_binary()"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n    # Check if the string length is less than 3\n    if len(s) < 3:\n        return False\n\n    # Iterate through the string and check consecutive triplets\n    for i in range(len(s) - 2):\n        # Check if the three consecutive characters are distinct\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            continue\n        else:\n            return False\n\n    return True\n\n# Unit tests to cover typical scenarios and edge cases\nassert is_happy(\"\") == False, \"Test Case 1 Failed\"\nassert is_happy(\"a\") == False, \"Test Case 2 Failed\"\nassert is_happy(\"aa\") == False, \"Test Case 3 Failed\"\nassert is_happy(\"aaa\") == False, \"Test Case 4 Failed\"\nassert is_happy(\"abc\") == True, \"Test Case 5 Failed\"\nassert is_happy(\"abccba\") == True, \"Test Case 6 Failed\"\nassert is_happy(\"aab\") == False, \"Test Case 7 Failed\"\nassert is_happy(\"abcabcd\") == True, \"Test Case 8 Failed\"\nassert is_happy(\"xyy\") == False, \"Test Case 9 Failed\"\nprint(\"All test cases passed!\")\n"}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    \"\"\"\n    Counts the number of hexadecimal digits that are prime.\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers in hexadecimal digits are: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n    \n    Args:\n        num (str): The hexadecimal number as a string.\n    \n    Returns:\n        int: The count of prime digits in the hexadecimal number.\n    \n    Note:\n        You may assume the input is always correct or an empty string, \n        and symbols A, B, C, D, E, F are always uppercase.\n    \"\"\"\n    \n    # Define a set of hexadecimal digits that represent prime numbers\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for the prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string and count prime digits\n    for digit in num:\n        if digit in prime_hex_digits:\n            prime_count += 1\n            \n    return prime_count\n\n# Unit tests\nimport unittest\n\nclass TestHexKey(unittest.TestCase):\n    \n    def test_examples(self):\n        self.assertEqual(hex_key(\"AB\"), 1)\n        self.assertEqual(hex_key(\"1077E\"), 2)\n        self.assertEqual(hex_key(\"ABED1A33\"), 4)\n        self.assertEqual(hex_key(\"123456789ABCDEF0\"), 6)\n        self.assertEqual(hex_key(\"2020\"), 2)\n    \n    def test_empty_string(self):\n        self.assertEqual(hex_key(\"\"), 0)\n    \n    def test_all_prime_digits(self):\n        self.assertEqual(hex_key(\"2357BD\"), 6)\n    \n    def test_no_prime_digits(self):\n        self.assertEqual(hex_key(\"04689AECF\"), 0)\n    \n    def test_mixed_case_is_not_allowed(self):\n        # Since the docstring mentions input will always be uppercase, this is to check functionality nonetheless\n        self.assertEqual(hex_key(\"Babc123\"), 1)\n\nif __name__ == '__main__':\n    unittest.main(argv=[''], exit=False)"}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n    \n    Returns:\n        int: The sum of all even elements that are at odd indices in the list.\n        \n    Raises:\n        TypeError: If lst is not a list or contains non-integer elements.\n        ValueError: If lst is empty.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    \n    # Check if lst is indeed a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Expected lst to be a list.\")\n    \n    # Check if lst is empty\n    if not lst:\n        raise ValueError(\"The input list is empty.\")\n    \n    # Check if all elements in lst are integers\n    for element in lst:\n        if not isinstance(element, int):\n            raise TypeError(\"All elements in the list must be integers.\")\n    \n    # Sum the even elements at odd indices\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    \n    return total\n\n# Unit tests\nimport unittest\n\nclass TestAddFunction(unittest.TestCase):\n    \n    def test_typical_case(self):\n        self.assertEqual(add([4, 2, 6, 7]), 2)\n    \n    def test_all_odd_indices_even(self):\n        self.assertEqual(add([1, 2, 3, 4, 5, 6]), 12)\n    \n    def test_all_odd_indices_odd(self):\n        self.assertEqual(add([1, 3, 5, 7, 9, 11]), 0)\n    \n    def test_single_element(self):\n        with self.assertRaises(ValueError):\n            add([])\n    \n    def test_non_integer_elements(self):\n        with self.assertRaises(TypeError):\n            add([1, \"two\", 3, 4])\n    \n    def test_empty_list(self):\n        with self.assertRaises(ValueError):\n            add([])\n    \n    def test_large_dataset(self):\n        # Test with a large dataset\n        self.assertEqual(add([i for i in range(10**6)]), 125000000000)\n\nif __name__ == '__main__':\n    unittest.main()"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if input is a list and contains at least 2 distinct elements\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list of integers.\")\n    if len(lst) < 2:\n        return None\n    \n    # Create a set to eliminate duplicates and check number of distinct elements\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements and return the second smallest element\n    unique_elements.sort()\n    return unique_elements[1]\n\n# Unit tests to validate the implementation\ndef test_next_smallest():\n    assert next_smallest([1, 2, 3, 4, 5]) == 2\n    assert next_smallest([5, 1, 4, 3, 2]) == 2\n    assert next_smallest([]) == None\n    assert next_smallest([1, 1]) == None\n    assert next_smallest([2, 1, 3, -1, 0]) == 0\n    assert next_smallest([-3, -1, -4, -2]) == -3\n    assert next_smallest([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 20\n    assert next_smallest([10]) == None\n    assert next_smallest([10, 10, 10, 10]) == None\n    \ntest_next_smallest()"}
{"task_id": "HumanEval/84", "completion": "\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example:\n        For N = 1000, the sum of digits will be 1 and the output should be \"1\".\n        For N = 150, the sum of digits will be 6 and the output should be \"110\".\n        For N = 147, the sum of digits will be 12 and the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    \n    # Validate input type\n    if not isinstance(N, int):\n        raise ValueError(\"Input must be an integer\")\n    # Validate input range\n    if N < 0 or N > 10000:\n        raise ValueError(\"Input must be in the range 0 \u2264 N \u2264 10000\")\n\n    # Sum the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and return as string without '0b' prefix\n    return bin(digit_sum)[2:]\n\n# Unit test cases\ndef test_solve():\n    # Test typical scenarios\n    assert solve(1000) == \"1\", \"Test case 1 failed\"\n    assert solve(150) == \"110\", \"Test case 2 failed\"\n    assert solve(147) == \"1100\", \"Test case 3 failed\"\n    \n    # Test edge cases\n    assert solve(0) == \"0\", \"Test case 4 failed\"\n    assert solve(9999) == \"1001\", \"Test case 5 failed\"\n    \n    # Test error handling for non-integer input\n    try:\n        solve(\"test\")\n    except ValueError as e:\n        assert str(e) == \"Input must be an integer\", \"Test case 6 failed\"\n    \n    # Test error handling for negative input\n    try:\n        solve(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be in the range 0 \u2264 N \u2264 10000\", \"Test case 7 failed\"\n    \n    # Test error handling for input larger than 10000\n    try:\n        solve(10001)\n    except ValueError as e:\n        assert str(e) == \"Input must be in the range 0 \u2264 N \u2264 10000\", \"Test case 8 failed\"\n\n    print(\"All test cases pass\")\n\n\n# Run the tests\ntest_solve()"}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    shift = 2 * 2  # letters shift down by two multiplied by two places\n    result = []\n\n    for char in s:\n        if not char.isalpha() or len(char) != 1:  # Ignore any non-alphabetic character\n            result.append(char)\n        else:\n            shifted = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            result.append(shifted)\n\n    return ''.join(result)\n\n\n# Unit test cases\ndef test_encrypt():\n    assert encrypt('hi') == 'lm'\n    assert encrypt('asdfghjkl') == 'ewhjklnop'\n    assert encrypt('gf') == 'kj'\n    assert encrypt('et') == 'ix'\n    assert encrypt('abcd') == 'efgh'\n    assert encrypt('') == ''\n    assert encrypt('aa') == 'ee'\n    assert encrypt('xyz') == 'bcd'\n    assert encrypt('za') == 'ed'\n\n    # Test with mixed case and symbols\n    assert encrypt('Hello, World!') == 'Lipps, Asvph!'\n    assert encrypt('123 and 456') == '123 erf 456'\n\n    # Type checks\n    try:\n        encrypt(123)\n    except TypeError as e:\n        assert str(e) == \"Input must be a string\"\n    else:\n        assert False, \"Expected TypeError\"\n\n# Run the test cases\ntest_encrypt()"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n\n    Parameters:\n    n (int): The number of digits (must be a positive integer)\n\n    Returns:\n    int: The count of n-digit numbers that start or end with 1\n\n    Raises:\n    ValueError: If n is not a positive integer.\n    \"\"\"\n    # Ensure n is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Edge case for one digit\n    if n == 1:\n        # Digits are from 1 to 9, only [1] starts or ends with 1.\n        return 1\n\n    # Number of n-digit numbers\n    total_n_digit_numbers = 9 * (10 ** (n - 1))\n    \n    # Number of n-digit numbers starting with 1 (1XXX... to 1999...)\n    starts_with_1 = 10 ** (n - 1)\n    \n    # Number of n-digit numbers ending with 1 (10**(n-1) + 1, 10**(n-1) + 11, ..., 9 * 10**(n-1) + 1)\n    ends_with_1 = 9 * 10 ** (n - 1)\n    \n    # Subtract overlap where numbers start and end with 1\n    starts_and_ends_with_1 = 1 * (10 ** (n - 2))  # Example: 1001, 1011, ..., 1991\n\n    return starts_with_1 + ends_with_1 - starts_and_ends_with_1\n\n# Unit Test cases\ndef test_starts_one_ends():\n    assert starts_one_ends(1) == 1  # Only 1 starts or ends with 1 in 1-digit numbers\n    assert starts_one_ends(2) == 18  # [10-19, 11, 21, 31, ..., 91]\n    assert starts_one_ends(3) == 162  # Large calculation: manually or via a verified method\n    assert starts_one_ends(4) == 1719\n    assert starts_one_ends(5) == 17199\n    assert starts_one_ends(6) == 171999\n\n    try:\n        starts_one_ends(0)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    try:\n        starts_one_ends(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n        \n    try:\n        starts_one_ends(\"not an int\")\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n\n    print(\"All tests passed!\")\n\n# Run tests\ntest_starts_one_ends()"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given 2 dimensional data, as nested lists, which is similar to a matrix.\n    However, unlike matrices, each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list, and return a list of tuples\n    [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    if not isinstance(lst, list) or not all(isinstance(row, list) for row in lst):\n        raise ValueError(\"Input lst must be a 2D list.\")\n    \n    if not isinstance(x, int):\n        raise ValueError(\"Input x must be an integer.\")\n\n    coordinates = []\n    \n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sorting first by rows in ascending order and then columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates\n\n# Unit tests\ndef test_get_row():\n    assert get_row([\n        [1, 2, 3, 4, 5, 6],\n        [1, 2, 3, 4, 1, 6],\n        [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    assert get_row([], 1) == []\n    assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    assert get_row([\n        [7, 8, 7],\n        [5, 6, 7],\n        [7, 7, 7]\n    ], 7) == [(0, 2), (0, 0), (1, 2), (2, 2), (2, 1), (2, 0)]\n    \n    assert get_row([\n        [1, 2, 3],\n        [4, 5, 6]\n    ], 10) == []\n    \n    assert get_row([\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ], 6) == [(1, 1)]\n    \n    # Test with non-integer values\n    try:\n        get_row([[1, 2, 3], [4, 5, 6]], \"6\")\n    except ValueError as e:\n        assert str(e) == \"Input x must be an integer.\"\n\n    # Test with non-list values\n    try:\n        get_row(\"invalid input\", 6)\n    except ValueError as e:\n        assert str(e) == \"Input lst must be a 2D list.\"\n\n    print(\"All tests passed.\")\n\n# Run the tests\ntest_get_row()"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a\n    way that it swaps case of all letters, replaces all vowels in\n    the message with the letter that appears 2 places ahead of that\n    vowel in the English alphabet.\n    Assume only letters.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    if not isinstance(message, str):\n        raise ValueError(\"Input must be a string\")\n\n    vowels = 'aeiou'\n    vowel_shift_mapping = {\n        'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n        'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'\n    }\n\n    result = []\n    for char in message:\n        if char in vowel_shift_mapping:\n            # If the character is a vowel, replace it\n            result.append(vowel_shift_mapping[char])\n        else:\n            # Otherwise, add the character with swapped case\n            result.append(char.swapcase())\n\n    return ''.join(result)\n\n# Unit test cases\nif __name__ == \"__main__\":\n    assert encode('test') == 'TGST'\n    assert encode('This is a message') == 'tHKS KS C MGSSCGG'\n    assert encode('AEIOUaeiou') == 'CGKQWcgkqw'\n    assert encode('') == ''\n    assert encode('BCDF') == 'bcdf'\n    assert encode('bcdf') == 'BCDF'\n    \n    try:\n        encode(None)\n    except ValueError as e:\n        assert str(e) == 'Input must be a string'\n    \n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    # Handle edge case for empty array\n    if not array:\n        return []\n    \n    # Handle edge case for array with a single element\n    if len(array) == 1:\n        return array[:]\n    \n    # Ensure all elements are non-negative integers\n    if not all(isinstance(x, int) and x >= 0 for x in array):\n        raise ValueError(\"All elements in the array must be non-negative integers.\")\n    \n    # Calculate the sum of the first and last element\n    first_last_sum = array[0] + array[-1]\n    \n    # Determine sorting order based on the sum is even or odd\n    if first_last_sum % 2 == 0:\n        # Sum is even, sort in descending order\n        return sorted(array, reverse=True)\n    else:\n        # Sum is odd, sort in ascending order\n        return sorted(array)\n\n# Unit test cases\ndef test_sort_array():\n    assert sort_array([]) == []\n    assert sort_array([5]) == [5]\n    assert sort_array([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n    assert sort_array([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n    assert sort_array([1, 3, 2]) == [1, 2, 3] # 1 + 2 = 3 (odd), ascending\n    assert sort_array([1,1,1,1,1,1]) == [1, 1, 1, 1, 1, 1] # 1 + 1 = 2 (even), descending\n    assert sort_array([10, 20, 30, 40]) == [40, 30, 20, 10] # 10 + 40 = 50 (even), descending\n    \n    try:\n        sort_array([2, -1, 3]) # Should raise an error due to negative number\n    except ValueError as ve:\n        assert str(ve) == \"All elements in the array must be non-negative integers.\"\n    \n    try:\n        sort_array([\"a\", 1, 3]) # Should raise an error due to non-integer\n    except ValueError as ve:\n        assert str(ve) == \"All elements in the array must be non-negative integers.\"\n    \n    print(\"All tests passed!\")\n\n# Run the tests\ntest_sort_array()"}
{"task_id": "HumanEval/96", "completion": "import math\n\ndef is_prime(num):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if num <= 1:\n        return False\n    if num == 2:\n        return True  # Special case as 2 is the only even prime number\n    if num % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n):\n    \"\"\"Implement a function that takes a non-negative integer and returns an array of the prime\n    numbers that are less than n.\n    \n    For example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n    # Type check\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Edge case for non-positive input\n    if n <= 0:\n        return []\n    \n    primes = []\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n    \n    return primes\n\n# Unit tests\ndef test_count_up_to():\n    assert count_up_to(5) == [2, 3]\n    assert count_up_to(11) == [2, 3, 5, 7]\n    assert count_up_to(0) == []\n    assert count_up_to(20) == [2, 3, 5, 7, 11, 13, 17, 19]\n    assert count_up_to(1) == []\n    assert count_up_to(18) == [2, 3, 5, 7, 11, 13, 17]\n    assert count_up_to(2) == []\n\n    # Test invalid input\n    try:\n        count_up_to(-5)\n    except ValueError as e:\n        assert str(e) == \"Input must be a non-negative integer.\"\n    \n    try:\n        count_up_to('a')\n    except ValueError as e:\n        assert str(e) == \"Input must be a non-negative integer.\"\n\n    print(\"All tests passed!\")\n\n# Run unit tests\ntest_count_up_to()"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n        \n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \n    Args:\n        grades (list): A list of numerical GPA values (floats or ints).\n    \n    Returns:\n        list: A list of corresponding letter grades as strings.\n    \"\"\"\n    # Input validation\n    if not isinstance(grades, list):\n        raise TypeError(\"Input grades must be a list.\")\n    if any(not isinstance(gpa, (int, float)) or gpa < 0 or gpa > 4.0 for gpa in grades):\n        raise ValueError(\"All GPA values must be numbers between 0 and 4.0, inclusive.\")\n\n    letter_grades = []\n    \n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n\n    return letter_grades\n\n# Unit testing\nimport unittest\n\nclass TestNumericalLetterGrade(unittest.TestCase):\n\n    def test_typical_cases(self):\n        self.assertEqual(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]), ['A+', 'B', 'C-', 'C', 'A-'])\n\n    def test_edge_cases(self):\n        self.assertEqual(numerical_letter_grade([0.0, 0.5, 1.0, 4.0]), ['E', 'D-', 'D-', 'A+'])\n        self.assertEqual(numerical_letter_grade([3.7, 2.7, 1.7]), ['A', 'B', 'C'])\n        self.assertEqual(numerical_letter_grade([3.3, 2.3, 1.3]), ['A-', 'B-', 'C-'])\n\n    def test_empty_input(self):\n        self.assertEqual(numerical_letter_grade([]), [])\n\n    def test_invalid_type_input(self):\n        with self.assertRaises(TypeError):\n            numerical_letter_grade(\"invalid input\")\n        \n    def test_invalid_value_input(self):\n        with self.assertRaises(ValueError):\n            numerical_letter_grade([4.1, -1, \"invalid\"])\n\n# Runs the unit tests\nif __name__ == '__main__':\n    unittest.main(argv=[''], exit=False)"}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14, -15) should return 20.\n    \"\"\"\n    # If a or b is None, raise a TypeError.\n    if a is None or b is None:\n        raise TypeError(\"Input values must be integers.\")\n        \n    # Ensure the inputs are integers.\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    # Get the unit digit for each integer.\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Return the product of the unit digits.\n    return unit_digit_a * unit_digit_b\n\n# Unit Test Cases\n\ndef test_multiply():\n    assert multiply(148, 412) == 16, \"Test case 1 failed\"\n    assert multiply(19, 28) == 72, \"Test case 2 failed\"\n    assert multiply(2020, 1851) == 0, \"Test case 3 failed\"\n    assert multiply(14, -15) == 20, \"Test case 4 failed\"\n    assert multiply(0, 0) == 0, \"Test case 5 failed\"\n    assert multiply(12345, 67890) == 0, \"Test case 6 failed\"\n    assert multiply(-1234, -4321) == 4, \"Test case 7 failed\"\n    \n    print(\"All test cases pass\")\n\n# Run the unit tests\ntest_multiply()"}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    # Ensure S is a string\n    if not isinstance(S, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Split the string into sentences\n    sentences = S.split('.')\n    bored_count = 0\n    \n    # Check each sentence for boredom\n    for sentence in sentences:\n        sentence = sentence.strip()  # Remove leading/trailing whitespace\n        if sentence.startswith((\"I \", \"I.\", \"I?\", \"I!\")):\n            bored_count += 1\n    \n    return bored_count\n\n# Test cases\nassert is_bored(\"Hello world\") == 0\nassert is_bored(\"The sky is blue. The sun is shining. I love this weather.\") == 1\nassert is_bored(\"\") == 0\nassert is_bored(\"I am here. You are there. She is over there? I think so!\") == 2\nassert is_bored(\"Do I know you? I don't think so!\") == 1\nassert is_bored(\"Is this real? No it isn't! Wait. I think it is.\") == 1\n\nprint(\"All test cases pass.\")"}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(dictionary):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False if the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    \n    # Check if the dictionary is empty\n    if not dictionary:\n        return False\n    \n    # Validate that all keys are strings\n    for key in dictionary.keys():\n        if not isinstance(key, str):\n            return False\n\n    # Check the case of the first key\n    first_key = next(iter(dictionary.keys()))\n    if first_key.islower():\n        key_case = 'lower'\n    elif first_key.isupper():\n        key_case = 'upper'\n    else:\n        return False\n\n    # Check if all keys match the case of the first key\n    for key in dictionary.keys():\n        if key_case == 'lower' and not key.islower():\n            return False\n        if key_case == 'upper' and not key.isupper():\n            return False\n    \n    return True\n\n# Unit test cases\ndef test_check_dict_case():\n    assert check_dict_case({\"a\": \"apple\", \"b\": \"banana\"}) == True\n    assert check_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"}) == False\n    assert check_dict_case({\"a\": \"apple\", 8: \"banana\", \"a\": \"apple\"}) == False\n    assert check_dict_case({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}) == False\n    assert check_dict_case({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) == True\n    assert check_dict_case({}) == False  # Edge case: empty dictionary\n    assert check_dict_case({\"lowercase\": \"only\"}) == True  # Single item\n    assert check_dict_case({\"UPPERCASE\": \"ONLY\"}) == True  # Single item in upper case\n    assert check_dict_case({\"mixed\": \"CASE\", \"example\": \"test\"}) == True  # All lower\n    assert check_dict_case({\"Mixed\": \"case\", \"example\": \"Test\"}) == False  # Mixed case\n    print(\"All test cases passed.\")\n\n# Running the test cases\ntest_check_dict_case()"}
{"task_id": "HumanEval/98", "completion": "import unittest\n\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n\n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    if s is None:\n        raise ValueError(\"Input string cannot be None\")\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    upper_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    # Iterate through even indices only\n    for i in range(0, len(s), 2):\n        if s[i] in upper_vowels:\n            count += 1\n    \n    return count\n\n# Unit test cases\n\nclass TestCountUpper(unittest.TestCase):\n\n    def test_basic_cases(self):\n        self.assertEqual(count_upper('aBCdEf'), 1)\n        self.assertEqual(count_upper('abcdefg'), 0)\n        self.assertEqual(count_upper('dBBE'), 0)\n\n    def test_empty_string(self):\n        self.assertEqual(count_upper(''), 0)\n\n    def test_no_uppercase_vowels(self):\n        self.assertEqual(count_upper('bcdfghjklmnpqrstvwxyz'), 0)\n    \n    def test_all_uppercase_vowels_at_even_indices(self):\n        self.assertEqual(count_upper('AEOUae'), 4)\n    \n    def test_mixed_vowels(self):\n        self.assertEqual(count_upper('AaEeIiOoUu'), 3)\n\n    def test_non_string_input(self):\n        with self.assertRaises(TypeError):\n            count_upper(12345)\n    \n    def test_none_input(self):\n        with self.assertRaises(ValueError):\n            count_upper(None)\n\n    def test_large_string(self):\n        large_string = 'A' * 1000000 + 'B' * 1000000\n        self.assertEqual(count_upper(large_string), 500000)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/101", "completion": "import re\n\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be of type string\")\n    \n    if not s:\n        return []\n    \n    # Use regular expression to split by comma and/or space, ensuring to handle multiple spaces\n    words = re.split(r'[\\s,]+', s)\n\n    # Filter out any empty strings in the case of trailing commas or spaces\n    return [word for word in words if word]\n\n# Unit Tests\nif __name__ == \"__main__\":\n    # Test typical scenarios\n    assert words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"], \"Test case 1 failed\"\n    assert words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"], \"Test case 2 failed\"\n\n    # Test with spaces and commas\n    assert words_string(\"  spaced  ,out, string  \") == [\"spaced\", \"out\", \"string\"], \"Test case 3 failed\"\n    assert words_string(\",commas,, ,every, ,where, \") == [\"commas\", \"every\", \"where\"], \"Test case 4 failed\"\n\n    # Test edge cases\n    assert words_string(\"\") == [], \"Test case 5 failed\"\n    assert words_string(\"   \") == [], \"Test case 6 failed\"\n    assert words_string(\", , , \") == [], \"Test case 7 failed\"\n    assert words_string(\"singleword\") == [\"singleword\"], \"Test case 8 failed\"\n    \n    # Test error handling\n    try:\n        words_string(None)\n    except TypeError as e:\n        assert str(e) == \"Input must be of type string\", \"Test case 9 failed\"\n    else:\n        raise AssertionError(\"Test case 9 failed\")\n    \n    try:\n        words_string(123)\n    except TypeError as e:\n        assert str(e) == \"Input must be of type string\", \"Test case 10 failed\"\n    else:\n        raise AssertionError(\"Test case 10 failed\")\n\n    print(\"All test cases passed!\")\n"}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    try:\n        # Type check to ensure input is a string\n        if not isinstance(value, str):\n            raise TypeError(\"Input must be a string representing a number.\")\n        \n        # Convert the string to a float\n        number = float(value)\n        \n        # Use Python's round-half-away-from-zero approach\n        if number > 0:\n            result = int(number + 0.5)\n        else:\n            result = int(number - 0.5)\n        \n        return result\n    \n    except ValueError:\n        raise ValueError(\"Invalid input. Please provide a valid string representation of a number.\")\n\n# Unit testing\nif __name__ == \"__main__\":\n    import unittest\n    \n    class TestClosestInteger(unittest.TestCase):\n        def test_positive_integer(self):\n            self.assertEqual(closest_integer(\"10\"), 10)\n        \n        def test_negative_integer(self):\n            self.assertEqual(closest_integer(\"-10\"), -10)\n        \n        def test_positive_float(self):\n            self.assertEqual(closest_integer(\"15.3\"), 15)\n            self.assertEqual(closest_integer(\"14.5\"), 15)\n        \n        def test_negative_float(self):\n            self.assertEqual(closest_integer(\"-15.3\"), -15)\n            self.assertEqual(closest_integer(\"-14.5\"), -15)\n        \n        def test_zero(self):\n            self.assertEqual(closest_integer(\"0\"), 0)\n        \n        def test_invalid_input(self):\n            with self.assertRaises(ValueError):\n                closest_integer(\"abc\")\n        \n        def test_input_not_string(self):\n            with self.assertRaises(TypeError):\n                closest_integer(25)\n    \n    unittest.main()"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    # Type check for n to be a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    pile = [n]  # Initialize the pile with the first level having 'n' stones\n\n    # Determine the increment based on whether n is odd or even\n    if n % 2 == 0:\n        increment = 2\n    else:\n        increment = 2\n\n    next_stone_count = n\n\n    # Generate stones for the next levels\n    for _ in range(1, n):\n        next_stone_count += increment\n        pile.append(next_stone_count)\n    \n    return pile\n\n# Unit tests to validate the implementation\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    def test_make_a_pile():\n        assert make_a_pile(1) == [1]\n        assert make_a_pile(2) == [2, 4]\n        assert make_a_pile(3) == [3, 5, 7]\n        assert make_a_pile(4) == [4, 6, 8, 10]\n        assert make_a_pile(5) == [5, 7, 9, 11, 13]\n\n        try:\n            make_a_pile(0)\n        except ValueError as e:\n            assert str(e) == \"Input must be a positive integer\"\n\n        try:\n            make_a_pile(-1)\n        except ValueError as e:\n            assert str(e) == \"Input must be a positive integer\"\n\n        try:\n            make_a_pile(\"string\")\n        except ValueError as e:\n            assert str(e) == \"Input must be a positive integer\"\n\n    test_make_a_pile()"}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n    \n    Parameters:\n    x, y, z (int or float): Input three numbers.\n\n    Returns:\n    bool: True if one number equals the sum of the other two and all are integers, otherwise False.\n    '''\n    \n    # Check if all inputs are integers\n    if not all(isinstance(num, int) for num in (x, y, z)):\n        return False\n    \n    # Check if any number is the sum of the other two\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    \n    return False\n\n# Unit tests\ndef test_any_int():\n    assert any_int(5, 2, 7) == True\n    assert any_int(3, 2, 2) == False\n    assert any_int(3, -2, 1) == True\n    assert any_int(3.6, -2.2, 2) == False\n    assert any_int(0, 0, 0) == True  # Edge case: All zeros\n    assert any_int(1, 2, 3) == True  # 3 = 1 + 2\n    assert any_int(2, 2, 4) == True  # 4 = 2 + 2\n    assert any_int(1, 1, 1) == False  # No combination adds up\n    assert any_int(-1, -2, -3) == True  # -3 = -1 + -2\n    assert any_int(-3, -2, 1) == False  # No combination adds up\n\n# Run unit tests\ntest_any_int()"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n    \n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    \n    # Check if inputs are positive and if x and y are integers\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both x and y must be integers.\")\n    if x < 0 or y < 0:\n        raise ValueError(\"Both x and y must be positive numbers.\")\n    \n    # Ensure x is less than or equal to y\n    if x > y:\n        return -1\n    \n    # Start searching from y to x for the largest even number\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:\n            return i\n    \n    # If no even number is found, return -1\n    return -1\n\n# Unit tests\ndef test_choose_num():\n    assert choose_num(12, 15) == 14, \"Test Case 1 Failed\"\n    assert choose_num(13, 12) == -1, \"Test Case 2 Failed\"\n    assert choose_num(10, 10) == 10, \"Test Case 3 Failed\"\n    assert choose_num(9, 9) == -1, \"Test Case 4 Failed\"\n    assert choose_num(2, 9) == 8, \"Test Case 5 Failed\"\n    assert choose_num(15, 20) == 20, \"Test Case 6 Failed\"\n    \n    # Edge case: x and y are the same and even\n    assert choose_num(4, 4) == 4, \"Test Case 7 Failed\"\n    \n    # Edge case: x and y are the same and odd\n    assert choose_num(3, 3) == -1, \"Test Case 8 Failed\"\n    \n    # Edge case: negative inputs\n    try:\n        choose_num(-1, 4)\n    except ValueError as e:\n        assert str(e) == \"Both x and y must be positive numbers.\", \"Test Case 9 Failed\"\n    \n    try:\n        choose_num(4, -1)\n    except ValueError as e:\n        assert str(e) == \"Both x and y must be positive numbers.\", \"Test Case 10 Failed\"\n    \n    # Edge case: non-integer input\n    try:\n        choose_num(2.5, 9)\n    except ValueError as e:\n        assert str(e) == \"Both x and y must be integers.\", \"Test Case 11 Failed\"\n    \n    try:\n        choose_num(2, 9.5)\n    except ValueError as e:\n        assert str(e) == \"Both x and y must be integers.\", \"Test Case 12 Failed\"\n    \n    print(\"All test cases pass\")\n\ntest_choose_num()"}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m).\n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    # Check if inputs are valid positive integers\n    if not (isinstance(n, int) and isinstance(m, int)):\n        raise ValueError(\"Both n and m must be integers\")\n    if n <= 0 or m <= 0:\n        raise ValueError(\"Both n and m must be positive integers\")\n    \n    # If n is greater than m, return -1\n    if n > m:\n        return -1\n\n    # Calculate the number of integers in the range [n, m]\n    count = m - n + 1\n    # Calculate the sum of the range using arithmetic series sum formula\n    range_sum = (n + m) * count // 2\n    # Calculate the average\n    avg = range_sum / count\n    \n    # Round the average to the nearest integer\n    rounded_avg = round(avg)\n    \n    # Convert the rounded average to binary\n    binary_result = bin(rounded_avg)\n    \n    return binary_result\n\n# Unit tests\nimport unittest\n\nclass TestRoundedAvg(unittest.TestCase):\n    def test_given_examples(self):\n        self.assertEqual(rounded_avg(1, 5), \"0b11\")\n        self.assertEqual(rounded_avg(7, 5), -1)\n        self.assertEqual(rounded_avg(10, 20), \"0b1111\")\n        self.assertEqual(rounded_avg(20, 33), \"0b11010\")\n    \n    def test_edge_cases(self):\n        self.assertEqual(rounded_avg(5, 5), \"0b101\")  # Single number case\n        self.assertEqual(rounded_avg(1, 2), \"0b1\")    # Small range\n        self.assertEqual(rounded_avg(1000, 1000), \"0b1111101000\")  # Large single number\n    \n    def test_invalid_input(self):\n        with self.assertRaises(ValueError):\n            rounded_avg(-5, 10)\n        with self.assertRaises(ValueError):\n            rounded_avg('a', 10)\n        with self.assertRaises(ValueError):\n            rounded_avg(10, None)\n\n    def test_performance_large_inputs(self):\n        self.assertEqual(rounded_avg(1, 1000000), \"0b111101000010001\")\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    elements that haven't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    \n    # Type checks\n    if not isinstance(x, list):\n        raise TypeError(\"Input must be a list of positive integers\")\n    for num in x:\n        if not isinstance(num, int) or num <= 0:\n            raise ValueError(\"All elements in the list must be positive integers\")\n\n    def has_no_even_digit(number):\n        \"\"\"Check if the given number has any even digit\"\"\"\n        while number > 0:\n            digit = number % 10\n            if digit % 2 == 0:\n                return False\n            number //= 10\n        return True\n\n    # Filter out numbers with even digits\n    result = [num for num in x if has_no_even_digit(num)]\n\n    # Return the sorted list\n    return sorted(result)\n\n# Unit test cases\ndef test_unique_digits():\n    assert unique_digits([15, 33, 1422, 1]) == [1, 15, 33]\n    assert unique_digits([152, 323, 1422, 10]) == []\n    assert unique_digits([]) == []\n    assert unique_digits([11, 13, 17, 19]) == [11, 13, 17, 19]\n    assert unique_digits([2, 4, 6, 8]) == []\n    assert unique_digits([135, 153, 371, 517]) == [135, 153, 371, 517]\n    try:\n        unique_digits('string input')\n    except TypeError as e:\n        assert str(e) == \"Input must be a list of positive integers\"\n    try:\n        unique_digits([-1, -2, 3])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be positive integers\"\n    try:\n        unique_digits([1.5, 2.3, 3.1])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be positive integers\"\n\n# Running tests\ntest_unique_digits()"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindromes are 1, 2, 3. One of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Four of them are even, and six of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. Returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    \n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    even_count = 0  # Count of even palindromes\n    odd_count = 0   # Count of odd palindromes\n\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)\n\n# Unit tests\ndef test_even_odd_palindrome():\n    # Test case 1\n    assert even_odd_palindrome(3) == (1, 2), f\"Test case 1 failed: {even_odd_palindrome(3)}\"\n    \n    # Test case 2\n    assert even_odd_palindrome(12) == (4, 6), f\"Test case 2 failed: {even_odd_palindrome(12)}\"\n    \n    # Test case 3: edge case with smallest input\n    assert even_odd_palindrome(1) == (0, 1), f\"Test case 3 failed: {even_odd_palindrome(1)}\"\n    \n    # Test case 4: input with no even palindromes\n    assert even_odd_palindrome(9) == (0, 9), f\"Test case 4 failed: {even_odd_palindrome(9)}\"\n    \n    # Test case 5: larger input\n    assert even_odd_palindrome(100) == (45, 54), f\"Test case 5 failed: {even_odd_palindrome(100)}\"\n    \n    print(\"All test cases pass\")\n\n# Running the unit tests\ntest_even_odd_palindrome()"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    # Type check for the input\n    if not isinstance(arr, list):\n        raise TypeError(\"Input should be a list of integers.\")\n    \n    # Check if each element is an integer\n    for num in arr:\n        if not isinstance(num, int):\n            raise ValueError(\"All elements in the list should be integers.\")\n    \n    def sum_of_digits(num):\n        \"\"\" Helper function to calculate the sum of digits of a number. \"\"\"\n        # Get the absolute value of the number\n        abs_num = abs(num)\n        \n        # Convert each digit to an integer and then sum them\n        digit_sum = sum(int(digit) for digit in str(abs_num))\n        \n        # If the number was negative, subtract twice the first digit's value from the sum\n        if num < 0:\n            first_digit = int(str(abs(num))[0])\n            digit_sum -= 2 * first_digit\n        \n        return digit_sum\n    \n    count = 0\n    for number in arr:\n        if sum_of_digits(number) > 0:\n            count += 1\n    \n    return count\n\n# Example usage and tests\nprint(count_nums([]))              # Expected output: 0\nprint(count_nums([-1, 11, -11]))    # Expected output: 1\nprint(count_nums([1, 1, 2]))        # Expected output: 3\n\n# Unit tests\nimport unittest\n\nclass TestCountNums(unittest.TestCase):\n    def test_empty_list(self):\n        self.assertEqual(count_nums([]), 0)\n\n    def test_single_negative(self):\n        self.assertEqual(count_nums([-123]), 0)\n        \n    def test_single_positive(self):\n        self.assertEqual(count_nums([123]), 1)\n        \n    def test_mixed_list(self):\n        self.assertEqual(count_nums([-1, 11, -11]), 1)\n        \n    def test_all_zero_sum(self):\n        self.assertEqual(count_nums([-10, 0]), 0)\n\n    def test_all_positive_sum(self):\n        self.assertEqual(count_nums([12, 13, 14]), 3)\n        \n    def test_type_error(self):\n        with self.assertRaises(TypeError):\n            count_nums(\"not a list\")\n        \n    def test_value_error(self):\n        with self.assertRaises(ValueError):\n            count_nums([1, \"string\", 2])\n\n# Run the tests\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Args:\n    test (str): a string of space-separated lowercase letters\n    \n    Returns:\n    dict: a dictionary with the most frequent letters as keys and their counts as values\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"\n    # Check if input is a string\n    if not isinstance(test, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Split the input string by spaces and filter out any empty strings\n    letters = list(filter(None, test.split(' ')))\n    \n    # If the input string is empty after splitting\n    if not letters:\n        return {}\n    \n    # Dictionary to count occurrences of each letter\n    counts = {}\n    \n    for letter in letters:\n        if letter.islower() and len(letter) == 1:\n            counts[letter] = counts.get(letter, 0) + 1\n        else:\n            raise ValueError(\"Only single lowercase letters are allowed\")\n    \n    # Determine the maximum count\n    max_count = max(counts.values())\n    \n    # Filter and return the letters with the maximum count\n    result = {letter: count for letter, count in counts.items() if count == max_count}\n    \n    return result\n\n# Unit tests\ndef test_histogram():\n    assert histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    assert histogram('a b b a') == {'a': 2, 'b': 2}\n    assert histogram('a b c a b') == {'a': 2, 'b': 2}\n    assert histogram('b b b b a') == {'b': 4}\n    assert histogram('') == {}\n    assert histogram('a a a b b') == {'a': 3}\n    \n    # Edge cases\n    try:\n        histogram(123)\n    except ValueError as e:\n        assert str(e) == \"Input must be a string\"\n    \n    try:\n        histogram('a b1 c')\n    except ValueError as e:\n        assert str(e) == \"Only single lowercase letters are allowed\"\n    \n    try:\n        histogram('a b C')\n    except ValueError as e:\n        assert str(e) == \"Only single lowercase letters are allowed\"\n    \n    try:\n        histogram('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n    except ValueError as e:\n        assert str(e) == \"Only single lowercase letters are allowed\"\n\n    print(\"All tests passed.\")\n\n# Run tests\ntest_histogram()"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    \"\"\"In this function, we determine if it is possible to exchange elements\n    between lst1 and lst2 such that all elements in lst1 are even numbers.\n    \n    Args:\n    lst1: List of integers to be checked and modified.\n    lst2: List of integers from where elements can be taken to make lst1 even.\n\n    Returns:\n    \"YES\" if it is possible to make all elements in lst1 even by exchanging elements with lst2, otherwise \"NO\".\n    \n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    \"\"\"\n    \n    # Type checks\n    if not isinstance(lst1, list) or not isinstance(lst2, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    \n    # Check for empty lists condition and data type within lists\n    if not lst1 or not lst2:\n        raise ValueError(\"Both lst1 and lst2 should be non-empty lists.\")\n    \n    if not all(isinstance(x, int) for x in lst1) or not all(isinstance(x, int) for x in lst2):\n        raise ValueError(\"Both lists must contain only integers.\")\n    \n    # Count number of odd/even elements in lst1\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    even_count_lst2 = sum(1 for y in lst2 if y % 2 == 0)\n    \n    # To make all elements in lst1 even, we need at least as many even numbers in lst2 as there are odd numbers in lst1\n    if odd_count_lst1 <= even_count_lst2:\n        return \"YES\"\n    else:\n        return \"NO\"\n    \n# Unit tests\nassert exchange([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\", \"Test case 1 failed\"\nassert exchange([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\", \"Test case 2 failed\"\nassert exchange([1, 3, 5], [2, 4, 6]) == \"YES\", \"Test case 3 failed\"\nassert exchange([1, 3, 5], [1, 3, 7]) == \"NO\", \"Test case 4 failed\"\nassert exchange([2, 4, 6], [1, 3, 5]) == \"YES\", \"Test case 5 failed\"\nassert exchange([1], [2]) == \"YES\", \"Test case 6 failed\"\nassert exchange([2], [1]) == \"YES\", \"Test case 7 failed\"\n\nprint(\"All test cases passed!\")"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]\n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55]\n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\n    # Mapping digits to their word equivalents\n    digit_to_word = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter out numbers that are not between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n\n    # Sort the array and then reverse it\n    sorted_reversed_arr = sorted(filtered_arr, reverse=True)\n    \n    # Map the sorted and reversed numbers to their word equivalents\n    result = [digit_to_word[num] for num in sorted_reversed_arr]\n    \n    return result\n\n\n# Unit test cases\ndef test_by_length():\n    assert by_length([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    assert by_length([]) == []\n    assert by_length([1, -1, 55]) == [\"One\"]\n    assert by_length([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [\"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]\n    assert by_length([10, 5, 0, 6]) == [\"Six\", \"Five\"]\n    \n    print(\"All test cases pass\")\n\ntest_by_length()"}
{"task_id": "HumanEval/106", "completion": "import math\n\ndef f(n):\n    \"\"\" Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n    # Type check for the input parameter\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    result = []\n    \n    for i in range(1, n + 1):\n        if i % 2 == 0:  # if i is even (i starts from 1 so 2, 4, 6, ... need the factorial)\n            result.append(math.factorial(i))\n        else:  # if i is odd (i starts from 1 so 1, 3, 5, ... need the sum of numbers from 1 to i)\n            result.append(sum(range(1, i + 1)))\n\n    return result\n\n# Unit tests\nimport unittest\n\nclass TestFunctionF(unittest.TestCase):\n    def test_typical_scenarios(self):\n        self.assertEqual(f(1), [1])  # Only one element (odd)\n        self.assertEqual(f(2), [1, 2])  # First is odd, second is even\n        self.assertEqual(f(5), [1, 2, 6, 24, 15])  # Provided example\n        self.assertEqual(f(6), [1, 2, 6, 24, 15, 720])  # Extending the example\n\n    def test_edge_cases(self):\n        self.assertEqual(f(0), [])\n        with self.assertRaises(ValueError):\n            f(-1)  # Negative number should raise an error\n        with self.assertRaises(ValueError):\n            f('a')  # Non-integer input should raise an error\n\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    \"\"\"\n    Task:\n    We are given two strings s and c, you have to delete all the characters in s that are equal to any\n    character in c then check if the result string is a palindrome.\n    \n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    \n    Example:\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd', False)\n    For s = \"abcdef\", c = \"b\", the result should be ('acdef', False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc', True)\n    \n    :param s: str - The original string.\n    :param c: str - The string containing the characters to be removed from s.\n    :return: tuple - The resulting string after deletion and a boolean indicating if it's a palindrome.\n    \"\"\"\n    \n    # Ensure input types are correct\n    if not isinstance(s, str):\n        raise ValueError(\"Input s must be a string.\")\n    if not isinstance(c, str):\n        raise ValueError(\"Input c must be a string.\")\n    \n    # Remove characters in s that are present in c\n    result = ''.join(ch for ch in s if ch not in c)\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return result, is_palindrome\n\n# Unit test cases to cover typical scenarios and edge cases\ndef test_reverse_delete():\n    # Test case 1\n    assert reverse_delete(\"abcde\", \"ae\") == ('bcd', False)\n    # Test case 2\n    assert reverse_delete(\"abcdef\", \"b\") == ('acdef', False)\n    # Test case 3\n    assert reverse_delete(\"abcdedcba\", \"ab\") == ('cdedc', True)\n    # Test case 4: Empty input s\n    assert reverse_delete(\"\", \"ab\") == ('', True)\n    # Test case 5: Empty input c\n    assert reverse_delete(\"abcdedcba\", \"\") == ('abcdedcba', True)\n    # Test case 6: Both s and c are empty\n    assert reverse_delete(\"\", \"\") == ('', True)\n    # Test case 7: All characters removed\n    assert reverse_delete(\"abcdef\", \"abcdef\") == ('', True)\n    # Test case 8: No characters removed\n    assert reverse_delete(\"abcdef\", \"ghij\") == ('abcdef', False)\n    # Test case 9: Entire string is a single character palindrome after removal\n    assert reverse_delete(\"aabbcc\", \"abc\") == ('', True)\n\n    print(\"All test cases pass\")\n\n# Execute unit tests\ntest_reverse_delete()"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n    \"\"\"\n    \n    # Handle edge cases\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    if not arr:\n        return True\n    \n    if len(arr) == 1:\n        return True\n\n    n = len(arr)\n    \n    # Check all n possible rotations.\n    for i in range(n):\n        rotated_arr = arr[i:] + arr[:i]\n        if rotated_arr == sorted(arr):\n            return True\n    \n    return False\n\n\n# Unit tests\ndef test_move_one_ball():\n    # Testing with examples given in the docstring\n    assert move_one_ball([3, 4, 5, 1, 2]) == True\n    assert move_one_ball([3, 5, 4, 1, 2]) == False\n    # Additional edge cases\n    assert move_one_ball([]) == True\n    assert move_one_ball([1]) == True\n    assert move_one_ball([2, 1]) == True  # 1 rotation needed\n    assert move_one_ball([4, 3, 2, 1]) == False  # No rotations can sort this\n    assert move_one_ball([1, 2, 3, 4]) == True  # Already sorted\n    \n    print(\"All tests passed.\")\n    \n# Run tests\ntest_move_one_ball()"}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    if not isinstance(lst, list) or not all(isinstance(s, str) for s in lst):\n        raise TypeError(\"Input should be a list of strings.\")\n    \n    result = []\n    for s in lst:\n        if s == \"\":  # Edge case for empty string\n            result.append(\"the number of odd elements 0n the str0ng 0 of the 0nput.\")\n            continue\n        \n        # Count odd digits in the string\n        odd_count = sum(1 for char in s if char in '13579')\n        \n        result_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(result_str)\n    \n    return result\n\n# Testing the function with unittest\nimport unittest\n\nclass TestOddCount(unittest.TestCase):\n    \n    def test_single_string(self):\n        self.assertEqual(odd_count(['1234567']), [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"])\n    \n    def test_multiple_strings(self):\n        self.assertEqual(odd_count(['3', '11111111']), [\n            \"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n            \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\n        ])\n    \n    def test_empty_list(self):\n        self.assertEqual(odd_count([]), [])\n    \n    def test_empty_string(self):\n        self.assertEqual(odd_count(['']), [\"the number of odd elements 0n the str0ng 0 of the 0nput.\"])\n    \n    def test_type_error(self):\n        with self.assertRaises(TypeError):\n            odd_count(\"123\")\n        with self.assertRaises(TypeError):\n            odd_count([12345])\n    \n    def test_all_even_digits(self):\n        self.assertEqual(odd_count(['24680']), [\"the number of odd elements 0n the str0ng 0 of the 0nput.\"])\n\nif __name__ == \"__main__\":\n    unittest.main(argv=[''], exit=False)"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    \n    # Check input type and handle edge cases\n    if not isinstance(nums, list):\n        raise TypeError(\"Input should be a list of integers.\")\n    if len(nums) == 0:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    # Large number to ensure any nums list will start off with a smaller number\n    min_sum = float('inf')\n    current_sum = 0\n    \n    for num in nums:\n        if not isinstance(num, int):\n            raise TypeError(\"All elements in the list should be integers.\")\n        \n        # Add current number to the current sum\n        current_sum += num\n        # Update the minimum found sum\n        min_sum = min(min_sum, current_sum)\n        # If current sum is positive, reset it to 0\n        if current_sum > 0:\n            current_sum = 0\n    \n    return min_sum\n\n# Sample unit tests\ndef test_minSubArraySum():\n    # Test cases\n    assert minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    assert minSubArraySum([-1, -2, -3]) == -6\n    assert minSubArraySum([-1, 2, -3, 4, -5]) == -6\n    assert minSubArraySum([-1, -2, 3, 1, -1, -2]) == -4\n    assert minSubArraySum([4, -1, 2, -3, 4]) == -3\n    \n    # Edge cases\n    assert minSubArraySum([0]) == 0\n    assert minSubArraySum([-1]) == -1\n    assert minSubArraySum([1]) == 1\n    \n    try:\n        minSubArraySum([])\n    except ValueError as e:\n        assert str(e) == \"Input list cannot be empty.\"\n    \n    try:\n        minSubArraySum('string')\n    except TypeError as e:\n        assert str(e) == \"Input should be a list of integers.\"\n\n    try:\n        minSubArraySum([1, 2, 'a', 4])\n    except TypeError as e:\n        assert str(e) == \"All elements in the list should be integers.\"\n\n# Running the tests\ntest_minSubArraySum()\n\n# Note: Tests are designed to cover the typical scenarios and edge cases"}
{"task_id": "HumanEval/94", "completion": "import math\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is a prime number.\"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    if not lst:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    max_prime = None\n\n    # Find the largest prime number in the list\n    for num in lst:\n        if isinstance(num, int) and is_prime(num):\n            if max_prime is None or num > max_prime:\n                max_prime = num\n\n    if max_prime is None:\n        raise ValueError(\"No prime numbers found in the input list.\")\n\n    # Calculate the sum of the digits of the largest prime number\n    sum_of_digits = sum(int(digit) for digit in str(max_prime))\n\n    return sum_of_digits\n\ndef test_skjkasdkd():\n    assert skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10\n    assert skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25\n    assert skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13\n    assert skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11\n    assert skjkasdkd([0,81,12,3,1,21]) == 3\n    assert skjkasdkd([0,8,1,2,1,7]) == 7\n    assert skjkasdkd([]) == ValueError(\"Input list cannot be empty.\")\n    assert skjkasdkd([0]) == ValueError(\"No prime numbers found in the input list.\")\n\ntest_skjkasdkd()\n"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    import math\n    \n    # Check if the input grid is valid\n    if not isinstance(grid, list) or any(not isinstance(row, list) for row in grid):\n        raise ValueError(\"The grid must be a list of lists\")\n    if not isinstance(capacity, int) or capacity < 1:\n        raise ValueError(\"The bucket capacity must be a positive integer\")\n    \n    total_units_of_water = 0\n    \n    # Calculate the total units of water in the grid\n    for row in grid:\n        if any(not (cell == 0 or cell == 1) for cell in row):\n            raise ValueError(\"The grid can only contain 0 or 1\")\n        total_units_of_water += sum(row)\n    \n    # Calculate the number of times the bucket needs to be lowered\n    bucket_use_count = math.ceil(total_units_of_water / capacity)\n    \n    return bucket_use_count\n\n# Unit tests\ndef test_max_fill():\n    # Test case 1\n    assert max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error in test case 1\"\n    \n    # Test case 2\n    assert max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error in test case 2\"\n    \n    # Test case 3\n    assert max_fill([[0,0,0], [0,0,0]], 5) == 0, \"Error in test case 3\"\n    \n    # Edge case: Empty grid\n    assert max_fill([], 1) == 0, \"Error in edge case: Empty grid\"\n    \n    # Edge case: Large bucket capacity\n    assert max_fill([[0,1,1], [1,1,1]], 10) == 1, \"Error in edge case: Large bucket capacity\"\n    \n    # Edge case: Invalid grid values\n    try:\n        max_fill([[0, 2, 1]], 1)\n    except ValueError as e:\n        assert str(e) == \"The grid can only contain 0 or 1\", \"Error in edge case: Invalid grid values\"\n\n# Run tests\ntest_max_fill()\nplt.show(block=all_runs())\n\nprint(\"All tests passed!\")\n\n# As specified, output your answer as a string containing the function.\n'<your answer>'"}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    # Ensure input is a list\n    if not isinstance(arr, list):\n        raise ValueError(\"Input should be a list.\")\n\n    # Ensure all elements are integers\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError(\"All elements in the input list should be integers.\")\n    \n    # Helper function to calculate the number of ones in the binary representation\n    def count_ones(n):\n        return bin(n).count('1')\n\n    # Sort the array by count of ones and then by decimal value\n    return sorted(arr, key=lambda x: (count_ones(x), x))\n\n# Below are the test cases to validate the implementation\n\ndef test_sort_array():\n    # Testing with positive integers\n    assert sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5], \"Failed test case: [1, 5, 2, 3, 4]\"\n    # Testing with negative integers\n    assert sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2], \"Failed test case: [-2, -3, -4, -5, -6]\"\n    # Testing with zeros\n    assert sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4], \"Failed test case: [1, 0, 2, 3, 4]\"\n    # Testing with repeated integers\n    assert sort_array([3, 7, 3, 7, 3]) == [3, 3, 3, 7, 7], \"Failed test case: [3, 7, 3, 7, 3]\"\n    # Testing with all ones in binary representation\n    assert sort_array([1, 8, 4, 2]) == [1, 2, 4, 8], \"Failed test case: [1, 8, 4, 2]\"\n    # Testing with empty list\n    assert sort_array([]) == [], \"Failed test case: []\"\n    # Testing with large values\n    large_input = [2**x for x in range(20)]\n    expected_output = sorted(large_input)\n    assert sort_array(large_input) == expected_output, \"Failed test case: Large input\"\n    print(\"All test cases passed!\")\n\ntest_sort_array()"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Set to store the unique odd numbers\n    odd_numbers = set()\n\n    # Generate Collatz sequence\n    while n != 1:\n        if n % 2 != 0:\n            odd_numbers.add(n)  # Add to set if it's odd\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n\n    # Add the last number 1 if it's not already added\n    odd_numbers.add(1)\n    \n    return sorted(odd_numbers)\n\n# Unit Tests\ndef test_get_odd_collatz():\n    # Test typical cases\n    assert get_odd_collatz(5) == [1, 5]\n    assert get_odd_collatz(7) == [1, 5, 7]\n    assert get_odd_collatz(10) == [1, 5]\n\n    # Test edge case - smallest input\n    assert get_odd_collatz(1) == [1]\n\n    # Test larger dataset\n    assert get_odd_collatz(27) == [1, 3, 5, 7, 9, 11, 15, 21, 27, 31, 41, 47, 55, 61, 73, 79, 85, 91, 93, 109, 127]\n\n    # Test invalid input\n    try:\n        get_odd_collatz(-5)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    try:\n        get_odd_collatz(0)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n    \n    try:\n        get_odd_collatz(5.5)\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n\n    try:\n        get_odd_collatz(\"a_string\")\n    except ValueError as e:\n        assert str(e) == \"Input must be a positive integer.\"\n\n# Run tests\ntest_get_odd_collatz()"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    \n    if lst is None:\n        raise ValueError(\"Input list is None\")\n    \n    if not all(isinstance(i, int) for i in lst):\n        raise ValueError(\"All elements should be integers\")\n\n    # Sum of odd elements at even positions (0-based index of the list)\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)\n\n# Unit test cases\ndef test_solution():\n    # Test cases from the problem statement\n    assert solution([5, 8, 7, 1]) == 12, \"Test case 1 failed\"\n    assert solution([3, 3, 3, 3, 3]) == 9, \"Test case 2 failed\"\n    assert solution([30, 13, 24, 321]) == 0, \"Test case 3 failed\"\n    \n    # Edge cases\n    assert solution([1]) == 1, \"Single element odd, even position\"\n    assert solution([2]) == 0, \"Single element even, even position\"\n    assert solution([2, 1, 4, 5, 6, 3, 8, 7]) == 0, \"No odd numbers in even positions\"\n    assert solution([11, 2, 33, 4, 55, 6]) == 99, \"Multiple odd numbers in even positions\"\n    \n    # Large input\n    large_input = [i if i % 2 == 0 else -(i+1) for i in range(1000000)]\n    assert solution(large_input) == sum(-i for i in range(1, 1000000, 2)), \"Large input test case failed\"\n    \n    print(\"All test cases pass.\")\n\n# Run the tests\ntest_solution()"}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Helper function to check if a string of parentheses is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            # If balance goes negative, parentheses are improperly nested\n            if balance < 0:\n                return False\n        # A balanced string ends with a balance of 0\n        return balance == 0\n\n    # Ensure the input is valid\n    if not isinstance(lst, list) or len(lst) != 2 or not all(isinstance(s, str) for s in lst):\n        raise ValueError(\"Input should be a list of two strings.\")\n\n    # Generate all possible concatenations of the two strings\n    s1, s2 = lst\n    concatenations = [s1 + s2, s2 + s1]\n\n    # Check each concatenation to see if it's balanced\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    \n    return 'No'\n\n# Testing the function\nprint(match_parens(['()(', ')']))  # Expected output: 'Yes'\nprint(match_parens([')', ')']))    # Expected output: 'No'\nprint(match_parens(['(', ')()']))  # Expected output: 'Yes'\nprint(match_parens(['(()', '())']))# Expected output: 'Yes'\nprint(match_parens([')(', ')(']))  # Expected output: 'No'"}
{"task_id": "HumanEval/125", "completion": "import unittest\n\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace. If no whitespaces exist in the text,\n    you should split on commas ','. If no commas exist, you should return the number of lower-case letters\n    with odd order in the alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n    \n    Examples:\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n    # Check if input is a string\n    if not isinstance(txt, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Split on whitespace if it exists\n    if ' ' in txt:\n        return txt.split()\n    \n    # Split on commas if no whitespace exists\n    elif ',' in txt:\n        return txt.split(',')\n    \n    # If no whitespaces or commas exist, calculate the odd ordered lower-case letters count\n    else:\n        odd_count = sum(1 for char in txt if char.islower() and (ord(char) - ord('a')) % 2 == 1)\n        return odd_count\n\n# Unit tests for the split_words function\nclass TestSplitWords(unittest.TestCase):\n\n    def test_split_on_whitespace(self):\n        self.assertEqual(split_words(\"Hello world!\"), [\"Hello\", \"world!\"])\n        self.assertEqual(split_words(\"This is a test\"), [\"This\", \"is\", \"a\", \"test\"])\n\n    def test_split_on_comma(self):\n        self.assertEqual(split_words(\"Hello,world!\"), [\"Hello\", \"world!\"])\n        self.assertEqual(split_words(\"a,b,c\"), [\"a\", \"b\", \"c\"])\n\n    def test_no_split_and_count_odd_ordered_lowercase(self):\n        self.assertEqual(split_words(\"abcdef\"), 3)  # 'b', 'd', 'f' have odd order positions\n        self.assertEqual(split_words(\"xyz\"), 2)  # 'x' and 'z' have odd order positions\n        self.assertEqual(split_words(\"mnop\"), 2)  # 'n', 'p' have odd order positions\n\n    def test_empty_string(self):\n        self.assertEqual(split_words(\"\"), 0)\n\n    def test_non_string_input(self):\n        with self.assertRaises(ValueError):\n            split_words(123)\n        with self.assertRaises(ValueError):\n            split_words([\"Hello\", \"world!\"])\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n    # Define vowels and consonants\n    vowels = 'AEIOUaeiou'\n    consonants = 'BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz'\n\n    # Edge case: Check if the input word is empty\n    if not word:\n        return \"\"\n\n    # Scan the word from right to left\n    for i in range(len(word) - 1, 0, -1):\n        # Check if word[i] is a vowel and is between two consonants\n        if word[i] in vowels and (i - 1 >= 0 and word[i - 1] in consonants) and (i + 1 < len(word) and word[i + 1] in consonants):\n            return word[i]\n    \n    # Return an empty string if no such vowel is found\n    return \"\"\n\n# Unit tests\ndef test_get_closest_vowel():\n    assert get_closest_vowel(\"yogurt\") == \"u\"\n    assert get_closest_vowel(\"FULL\") == \"U\"\n    assert get_closest_vowel(\"quick\") == \"\"\n    assert get_closest_vowel(\"ab\") == \"\"\n    assert get_closest_vowel(\"LEtter\") == \"e\"\n    assert get_closest_vowel(\"\") == \"\"\n    assert get_closest_vowel(\"Nd\") == \"\"\n    assert get_closest_vowel(\"abCdeFgHiJklMnOpQrsTuvwxyz\") == \"i\"\n    \n    print(\"All tests passed!\")\n\n# Run unit tests\ntest_get_closest_vowel()"}
{"task_id": "HumanEval/117", "completion": "import re\nimport unittest\n\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    \n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n    \n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"The number of consonants must be a non-negative integer\")\n\n    if s == \"\":\n        return []\n    \n    vowels = set(\"aeiouAEIOU\")\n    words = s.split()\n    \n    def count_consonants(word):\n        return sum(1 for char in word if char.isalpha() and char not in vowels)\n    \n    return [word for word in words if count_consonants(word) == n]\n\n\n# Unit testing\nclass TestSelectWords(unittest.TestCase):\n    def test_examples(self):\n        self.assertEqual(select_words(\"Mary had a little lamb\", 4), [\"little\"])\n        self.assertEqual(select_words(\"Mary had a little lamb\", 3), [\"Mary\", \"lamb\"])\n        self.assertEqual(select_words(\"simple white space\", 2), [])\n        self.assertEqual(select_words(\"Hello world\", 4), [\"world\"])\n        self.assertEqual(select_words(\"Uncle sam\", 3), [\"Uncle\"])\n        \n    def test_empty_string(self):\n        self.assertEqual(select_words(\"\", 3), [])\n        \n    def test_no_consonant_count_match(self):\n        self.assertEqual(select_words(\"a e i o u\", 1), [])\n        \n    def test_all_words_with_same_consonants(self):\n        self.assertEqual(select_words(\"abc abc abc\", 2), [\"abc\", \"abc\", \"abc\"])\n        \n    def test_non_alphabetic_letters(self):\n        with self.assertRaises(ValueError):\n            select_words(123, 3)\n        with self.assertRaises(ValueError):\n            select_words(\"Hello world\", -1)\n        with self.assertRaises(ValueError):\n            select_words(\"Hello world\", \"3\")\n\nunittest.main(argv=[''], exit=False)"}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111, 21, 3, 4000, 5, 6, 7, 8, 9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    # Type checks and error handling\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"arr must be a list of integers\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if not (1 <= len(arr) <= 100):\n        raise ValueError(\"Length of arr must be between 1 and 100\")\n    if not (1 <= k <= len(arr)):\n        raise ValueError(\"k must be between 1 and the length of arr\")\n    \n    # Sum of elements with at most two digits from the first k elements of arr\n    result = sum(x for x in arr[:k] if -99 <= x <= 99)\n\n    return result\n\n# Unit test cases\ndef test_add_elements():\n    # Basic case\n    assert add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) == 24\n    # Only invalid numbers\n    assert add_elements([111, 222, 333, 444, 555], 5) == 0\n    # All numbers are valid\n    assert add_elements([9, 10, 20, 30, 40], 5) == 109\n    # Exactly two digits\n    assert add_elements([10, 99, 100, -99, -100], 4) == 10 + 99 - 99\n    # Single element, valid\n    assert add_elements([50], 1) == 50\n    # Single element, invalid\n    assert add_elements([150], 1) == 0\n    # k equal to length of arr\n    assert add_elements([1, 2, 3, 4], 4) == 10\n    # Empty list scenario (invalid input, should raise error)\n    try:\n        add_elements([], 1)\n    except ValueError as e:\n        assert str(e) == \"Length of arr must be between 1 and 100\"\n\n    print(\"All test cases passed!\")\n\n# Run unit tests\ntest_add_elements()"}
{"task_id": "HumanEval/124", "completion": "import re\nfrom datetime import datetime\n\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"\n    \n    # Check if the date string is empty or not in the correct format\n    if not date or not isinstance(date, str):\n        return False\n\n    # Validate the format using regular expressions\n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n\n    # Extract parts of the date\n    month, day, year = map(int, date.split('-'))\n\n    # Check month\n    if month < 1 or month > 12:\n        return False\n\n    # Check day\n    if day < 1:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12] and day > 31:\n        return False\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n    if month == 2:\n        if day > 29:  # February has at most 29 days\n            return False\n        if day == 29:  # Must be a leap year\n            try:\n                datetime(year, 2, 29)\n            except ValueError:\n                return False\n\n    # If all checks passed\n    return True\n\n# Unit tests\nassert valid_date('03-11-2000') == True\nassert valid_date('15-01-2012') == False\nassert valid_date('04-0-2040') == False\nassert valid_date('06-04-2020') == True\nassert valid_date('06/04/2020') == False\nassert valid_date('02-29-2020') == True  # Leap year case\nassert valid_date('02-29-2021') == False  # Not a leap year\nassert valid_date('00-00-0000') == False  # Invalid date\nassert valid_date('13-01-2020') == False  # Invalid month\nassert valid_date('') == False  # Empty string\nassert valid_date(None) == False  # None value"}
{"task_id": "HumanEval/129", "completion": "from heapq import heappop, heappush\nfrom typing import List, Tuple\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    This function finds the lexicographically smallest path of length k in a grid, \n    starting from any cell and moving to any of its neighboring cells.\n    \"\"\"\n    \n    # Directions for moving in the grid: right, left, down, up\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def in_bounds(x: int, y: int, n: int) -> bool:\n        # Check if the coordinates are within the grid\n        return 0 <= x < n and 0 <= y < n\n\n    def get_neighbors(x: int, y: int, n: int) -> List[Tuple[int, int]]:\n        # Get valid neighboring cells\n        neighbors = []\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if in_bounds(nx, ny, n):\n                neighbors.append((nx, ny))\n        return neighbors\n    \n    n = len(grid)\n    min_paths = []  # Define a priority queue to store paths as tuples with the lexicographical comparison\n    \n    # Initialize the priority queue with all starting positions\n    for i in range(n):\n        for j in range(n):\n            heappush(min_paths, (grid[i][j], [(i, j)]))\n    \n    while min_paths:\n        lex_val, path = heappop(min_paths)\n        if len(path) == k:\n            return [grid[x][y] for x, y in path]\n        \n        # Get current position\n        cur_x, cur_y = path[-1]\n        \n        # Add paths to the heap extending the current path with each of its neighbors\n        for nx, ny in get_neighbors(cur_x, cur_y, n):\n            new_path = path + [(nx, ny)]\n            new_lex_val = tuple(grid[px][py] for px, py in new_path)\n            heappush(min_paths, (new_lex_val, new_path))\n    \n    # Edge case with invalid k requirement (e.g., k > nxn, but problem guarantees valid input)\n    return []\n\n\n# Unit test cases\nassert minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1], \"Test case 1 failed\"\nassert minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1], \"Test case 2 failed\"\nassert minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 2) == [1, 4], \"Test case 3 failed\"\nassert minPath([[2, 3, 1], [6, 7, 4], [8, 9, 5]], 3) == [1, 2, 3], \"Test case 4 failed\"\n\nprint(\"All test cases pass!\")"}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list of integers.\")\n    \n    # Check for empty input\n    if len(arr) == 0:\n        return -1\n    \n    # Variable to keep track of the largest index\n    index = -1\n    \n    # Iterate through the array to find the required index\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            index = i\n            \n    return index\n\n# Unit Tests\ndef run_tests():\n    # Test typical scenarios\n    assert can_arrange([1, 2, 4, 3, 5]) == 3, \"Test case 1 failed\"\n    assert can_arrange([1, 2, 3, 1]) == 3, \"Test case 2 failed\"\n    assert can_arrange([5, 4, 3, 2, 1]) == 1, \"Test case 3 failed\"\n    assert can_arrange([1, 2, 3]) == -1, \"Test case 4 failed\"\n    \n    # Test edge cases\n    assert can_arrange([]) == -1, \"Test case 5 (empty list) failed\"\n    \n    # Test large data sizes\n    large_input = list(range(1, 1000000)) + [999999]  # Last element less than its predecessor\n    assert can_arrange(large_input) == 999999, \"Test case 6 (large input) failed\"\n    \n    print(\"All tests passed!\")\n\nrun_tests()"}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Input validation\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be in the range 0 <= k <= len(arr).\")\n    \n    if k == 0:\n        return []\n\n    # Finding the k maximum elements and sorting them\n    # Use nlargest from the heapq module for better performance\n    from heapq import nlargest\n\n    return sorted(nlargest(k, arr))\n\n# Unit testing\n# Using the built-in unittest module for testing\nimport unittest\n\nclass TestMaximumFunction(unittest.TestCase):\n    \n    def test_example_1(self):\n        self.assertEqual(maximum([-3, -4, 5], 3), [-4, -3, 5])\n    \n    def test_example_2(self):\n        self.assertEqual(maximum([4, -4, 4], 2), [4, 4])\n    \n    def test_example_3(self):\n        self.assertEqual(maximum([-3, 2, 1, 2, -1, -2, 1], 1), [2])\n    \n    def test_empty_list(self):\n        self.assertEqual(maximum([], 0), [])\n    \n    def test_negative_k(self):\n        with self.assertRaises(ValueError):\n            maximum([1, 2, 3], -1)\n    \n    def test_k_greater_than_length(self):\n        with self.assertRaises(ValueError):\n            maximum([1, 2, 3], 4)\n    \n    def test_type_checks(self):\n        with self.assertRaises(TypeError):\n            maximum(\"not a list\", 2)\n        \n        with self.assertRaises(TypeError):\n            maximum([1, 2, 3], \"not an int\")\n    \n    def test_large_input(self):\n        large_arr = list(range(-1000, 1001))\n        self.assertEqual(maximum(large_arr, 5), [996, 997, 998, 999, 1000])\n\n# If this script is run directly, run the tests\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/128", "completion": "\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    >>> prod_signs([-1, -2, -3]) == -6\n    >>> prod_signs([4, -1, 0]) == 0\n    \"\"\"\n\n    # Handle edge case where the array is empty\n    if not arr:\n        return None\n\n    # Initialize variables\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        # Compute the sign (1, -1, 0) and magnitude of each number\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        else:\n            sign = 0\n\n        # Update the product of signs\n        product_of_signs *= sign\n\n        # Update the sum of magnitudes\n        sum_of_magnitudes += abs(num)\n\n        # If product of signs becomes zero, result will be zero\n        if product_of_signs == 0:\n            return 0\n    \n    # Return the final result\n    return product_of_signs * sum_of_magnitudes\n\n\n# Unit tests\ndef test_prod_signs():\n    # Test cases from docstring\n    assert prod_signs([1, 2, 2, -4]) == -9\n    assert prod_signs([0, 1]) == 0\n    assert prod_signs([]) == None\n\n    # Additional test cases\n    assert prod_signs([-1, -2, -3]) == -6\n    assert prod_signs([4, -1, 0]) == 0\n    assert prod_signs([5, 6, 7, 8]) == 26\n    assert prod_signs([-5, -6, 7, 8]) == -26\n    assert prod_signs([0]) == 0\n    assert prod_signs([-1]) == -1\n    assert prod_signs([1]) == 1\n    print(\"All tests passed.\")\n\n# Run tests\ntest_prod_signs()"}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n    # Edge case: Empty string\n    if not string:\n        return False\n    \n    # Stack to keep track of open brackets\n    stack = []\n    \n    # For checking if there's at least one nested pair\n    has_nested = False\n\n    # Traverse through each character in the string\n    for char in string:\n        if char == '[':\n            # Push open bracket to stack\n            stack.append(char)\n        elif char == ']':\n            # If stack is empty, there's an unmatched closing bracket\n            if not stack:\n                return False\n            # Pop open bracket from stack\n            stack.pop()\n            # If there was at least one nested level\n            has_nested = True\n    \n    # If stack is not empty, there are unmatched opening brackets; return False\n    return has_nested and not stack\n\n# Unit tests to cover typical scenarios and edge cases\ndef test_is_nested():\n    assert is_nested('[[]]') == True, \"Test case 1 failed\"\n    assert is_nested('[]]]]]]][[[[[]') == False, \"Test case 2 failed\"\n    assert is_nested('[][]') == False, \"Test case 3 failed\"\n    assert is_nested('[]') == False, \"Test case 4 failed\"\n    assert is_nested('[[][]]') == True, \"Test case 5 failed\"\n    assert is_nested('[[]][[') == True, \"Test case 6 failed\"\n    assert is_nested('[[[[[[[]]]]]]]') == True, \"Test case 7 failed\"\n    assert is_nested('[') == False, \"Test case 8 failed\"\n    assert is_nested(']') == False, \"Test case 9 failed\"\n    assert is_nested('') == False, \"Test case 10 failed\"\n    print(\"All test cases pass\")\n\n# Run the tests\ntest_is_nested()"}
{"task_id": "HumanEval/133", "completion": "import math\nimport unittest\n\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \"\"\"\n    \n    # Validate input\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list of numbers\")\n        \n    # Initialize the sum of squares\n    sum_of_squares = 0\n    \n    for num in lst:\n        # Type check for numbers\n        if not isinstance(num, (int, float)):\n            raise ValueError(\"All elements of the list should be numbers\")\n        \n        # Round up to ceiling\n        ceiling_num = math.ceil(num)\n        \n        # Add square to the sum\n        sum_of_squares += ceiling_num ** 2\n    \n    return sum_of_squares\n\n# Unit tests\nclass TestSumSquares(unittest.TestCase):\n    \n    def test_regular_cases(self):\n        self.assertEqual(sum_squares([1,2,3]), 14)\n        self.assertEqual(sum_squares([1,4,9]), 98)\n        self.assertEqual(sum_squares([1,3,5,7]), 84)\n        \n    def test_with_floats(self):\n        self.assertEqual(sum_squares([1.4,4.2,0]), 29)\n        self.assertEqual(sum_squares([-2.4,1,1]), 6)\n        \n    def test_empty_list(self):\n        self.assertEqual(sum_squares([]), 0)\n    \n    def test_large_numbers(self):\n        self.assertEqual(sum_squares([10000, 20000, 30000]), 1400000000)\n        \n    def test_type_errors(self):\n        with self.assertRaises(TypeError):\n            sum_squares(\"not a list\")\n        with self.assertRaises(ValueError):\n            sum_squares([1, 2, '3'])\n    \n    def test_null_values(self):\n        with self.assertRaises(ValueError):\n            sum_squares([1, None, 3])\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n    # Type checks for input validity\n    if not (isinstance(interval1, tuple) and isinstance(interval2, tuple)):\n        raise ValueError(\"The intervals must be provided as tuples.\")\n    if not (len(interval1) == 2 and len(interval2) == 2):\n        raise ValueError(\"Each interval must contain exactly two integers.\")\n    if not (all(isinstance(num, int) for num in interval1) and all(isinstance(num, int) for num in interval2)):\n        raise ValueError(\"All elements of the intervals must be integers.\")\n\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Ensure the intervals are correctly ordered\n    assert start1 <= end1, \"Invalid interval1, start must be less or equal to end\"\n    assert start2 <= end2, \"Invalid interval2, start must be less or equal to end\"\n\n    # Calculate intersection\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n\n    # Evaluate the length of intersection\n    if intersect_start <= intersect_end:\n        intersection_length = intersect_end - intersect_start + 1  # +1 because intervals are inclusive\n    else:\n        return \"NO\"\n\n    # Helper function to check if a number is prime\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Return result based on whether the intersection length is a prime number\n    return \"YES\" if is_prime(intersection_length) else \"NO\"\n\n# Unit tests\nassert intersection((1, 2), (2, 3)) == \"NO\"\nassert intersection((-1, 1), (0, 4)) == \"NO\"\nassert intersection((-3, -1), (-5, 5)) == \"YES\"\nassert intersection((0, 0), (0, 0)) == \"NO\"  # An edge case where the intervals are exactly one point\nassert intersection((5, 10), (10, 15)) == \"NO\"\nassert intersection((1, 3), (4, 6)) == \"NO\"  # No intersection case\nassert intersection((2, 3), (3, 5)) == \"NO\"  # Prime length 1 intersection\n\n# Output so the answer is visible on submission\nprint(intersection((1, 2), (2, 3)))\nprint(intersection((-1, 1), (0, 4)))\nprint(intersection((-3, -1), (-5, 5)))\nprint(intersection((5, 10), (10, 15)))\nprint(intersection((1, 3), (4, 6)))\nprint(intersection((2, 3), (3, 5)))"}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    \n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    product = 1\n    has_odd_digit = False\n\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n\n    if not has_odd_digit:\n        return 0\n    \n    return product\n\n# Unit Tests\ndef test_digits():\n    assert digits(1) == 1, \"Test case 1 failed\"\n    assert digits(4) == 0, \"Test case 2 failed\"\n    assert digits(235) == 15, \"Test case 3 failed\"\n    assert digits(2468) == 0, \"Test case 4 failed\"\n    assert digits(13579) == 945, \"Test case 5 failed\"\n    assert digits(10101) == 1, \"Test case 6 failed\"\n    assert digits(0) == 0, \"Test case 7 failed\"\n    print(\"All test cases pass\")\n\n# Run tests\ntest_digits()\n\n# Example Usage\nprint(digits(1))    # Output: 1\nprint(digits(4))    # Output: 0\nprint(digits(235))  # Output: 15"}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n    \n    # Validate input\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Initialize the result list with the base case tri(0)\n    result = [1]\n    \n    # Define a helper function to compute the Tribonacci value\n    def tribonacci(num):\n        if num == 1:\n            return 3\n        elif num % 2 == 0:\n            return 1 + num / 2\n        else:\n            return tribonacci(num - 1) + tribonacci(num - 2) + tri(num + 1)\n\n    # Compute the initial Tribonacci values iteratively up to n\n    for i in range(1, n + 1):\n        result.append(tribonacci(i))\n    \n    return result\n\n# Example usage:\n# print(tri(3))  # Should output [1, 3, 2, 8]"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n    # Check if the input is a list\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Handling the case for empty list which is considered sorted\n    if not lst:\n        return True\n    \n    # Check if all elements in the list are integers and non-negative\n    if not all(isinstance(x, int) and x >= 0 for x in lst):\n        raise ValueError(\"All elements in the list must be non-negative integers.\")\n    \n    # Iterate through the list to check if sorted and to count duplicates\n    element_count = {}\n    for i in range(1, len(lst)):\n        if lst[i-1] > lst[i]:\n            return False  # List is not sorted\n        element_count[lst[i-1]] = element_count.get(lst[i-1], 0) + 1\n        if element_count[lst[i-1]] > 2:\n            return False  # More than one duplicate found\n    \n    # Don't forget to check the count for the last element\n    element_count[lst[-1]] = element_count.get(lst[-1], 0) + 1\n    if element_count[lst[-1]] > 2:\n        return False\n    \n    return True\n\n# Unit test cases\ndef test_is_sorted():\n    assert is_sorted([]) == True, \"Test Case 1 Failed\"\n    assert is_sorted([5]) == True, \"Test Case 2 Failed\"\n    assert is_sorted([1, 2, 3, 4, 5]) == True, \"Test Case 3 Failed\"\n    assert is_sorted([1, 3, 2, 4, 5]) == False, \"Test Case 4 Failed\"\n    assert is_sorted([1, 2, 3, 4, 5, 6]) == True, \"Test Case 5 Failed\"\n    assert is_sorted([1, 3, 2, 4, 5, 6, 7]) == False, \"Test Case 6 Failed\"\n    assert is_sorted([1, 2, 2, 3, 3, 4]) == True, \"Test Case 7 Failed\"\n    assert is_sorted([1, 2, 2, 2, 3, 4]) == False, \"Test Case 8 Failed\"\n    assert is_sorted([1, 1]) == True, \"Test Case 9 Failed\"  # Unique case where 1 repeat is allowed\n    assert is_sorted([1, 1, 1]) == False, \"Test Case 10 Failed\"  # More than one duplicate\n    \n    print(\"All test cases pass\")\n\ntest_is_sorted()"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal. \n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    \n    def convert_to_float(value):\n        \"\"\"\n        Converts the given value to a float if it's a string. Handles both '.' and ',' as decimal points.\n        \"\"\"\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                raise ValueError(f\"Cannot convert {value} to float.\")\n        return value\n\n    # Convert both values to floats for comparison\n    a_float = convert_to_float(a)\n    b_float = convert_to_float(b)\n\n    # Direct comparison\n    if a_float > b_float:\n        return a\n    elif b_float > a_float:\n        return b\n    else:\n        return None\n\n# Unit tests\nimport unittest\n\nclass TestCompareOne(unittest.TestCase):\n    \n    def test_integers_and_floats(self):\n        self.assertEqual(compare_one(1, 2.5), 2.5)\n        self.assertEqual(compare_one(3, 2), 3)\n    \n    def test_integer_and_string(self):\n        self.assertEqual(compare_one(1, \"2,3\"), \"2,3\")\n        self.assertEqual(compare_one(\"5,1\", \"6\"), \"6\")\n        self.assertEqual(compare_one(\"1\", 1), None)\n\n    def test_strings_with_different_symbols(self):\n        self.assertEqual(compare_one(\"1.5\", \"2,5\"), \"2,5\")\n        \n    def test_equal_values(self):\n        self.assertEqual(compare_one(1, 1.0), None)\n        self.assertEqual(compare_one(\"2,0\", 2), None)\n   \n    def test_edge_cases(self):\n        self.assertIsNone(compare_one(\"\", \"\"))\n        self.assertIsNone(compare_one(\"1\", \"\"))\n        self.assertEqual(compare_one(0, \"0,0\"), None)\n        self.assertEqual(compare_one(\"3\", 3.0), None)\n\nif __name__ == \"__main__\":\n    unittest.main(argv=[''], exit=False)"}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n    '''\n    # Strip trailing spaces to check the actual last character\n    txt = txt.rstrip()\n\n    # Early return for empty strings or strings that become empty after trimming\n    if not txt:\n        return False\n\n    # Get the last character of the trimmed string\n    last_char = txt[-1]\n    \n    # Check if the last character is a letter and is not part of a word\n    if last_char.isalpha():\n        # Split the text by spaces to check words\n        words = txt.split()\n        \n        # If the last word is a single letter, it is not part of a word\n        if len(words[-1]) == 1:\n            return True\n    \n    return False\n\n\n# Unit Tests\ndef test_check_if_last_char_is_a_letter():\n    assert check_if_last_char_is_a_letter(\"apple pie\") == False\n    assert check_if_last_char_is_a_letter(\"apple pi e\") == True\n    assert check_if_last_char_is_a_letter(\"apple pi e \") == False\n    assert check_if_last_char_is_a_letter(\"\") == False\n    assert check_if_last_char_is_a_letter(\"a\") == True\n    assert check_if_last_char_is_a_letter(\"a \") == False\n    assert check_if_last_char_is_a_letter(\"hello world!\") == False\n    assert check_if_last_char_is_a_letter(\"hello world e\") == True\n    assert check_if_last_char_is_a_letter(\"  single e\") == True\n    assert check_if_last_char_is_a_letter(\"multiple words in a string e\") == True\n    print(\"All test cases pass\")\n\n# Running the test function\ntest_check_if_last_char_is_a_letter()"}
{"task_id": "HumanEval/139", "completion": "import math\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \n    Parameters:\n    n (int): A positive integer whose Brazilian factorial is to be calculated.\n\n    Returns:\n    int: The Brazilian factorial of the given integer n.\n    \"\"\"\n    \n    # Error handling for invalid inputs\n    if not isinstance(n, int):\n        raise TypeError(\"Input should be an integer.\")\n    if n <= 0:\n        raise ValueError(\"Input should be a positive integer greater than 0.\")\n    \n    result = 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n        \n    return result\n\n# Unit Tests\nimport unittest\n\nclass TestSpecialFactorial(unittest.TestCase):\n    def test_typical_cases(self):\n        self.assertEqual(special_factorial(1), 1)\n        self.assertEqual(special_factorial(2), 2)\n        self.assertEqual(special_factorial(3), 12)\n        self.assertEqual(special_factorial(4), 288)\n        self.assertEqual(special_factorial(5), 34560)\n    \n    def test_edge_cases(self):\n        with self.assertRaises(ValueError):\n            special_factorial(0)\n        with self.assertRaises(ValueError):\n            special_factorial(-1)\n    \n    def test_invalid_types(self):\n        with self.assertRaises(TypeError):\n            special_factorial(2.5)\n        with self.assertRaises(TypeError):\n            special_factorial(\"string\")\n        with self.assertRaises(TypeError):\n            special_factorial(None)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    import math\n\n    def is_prime(n):\n        \"\"\"\n        Helper function to check if a number is prime.\n        \n        Args:\n        n : int : The number to check for primality.\n\n        Returns:\n        bool : True if the number is prime, otherwise False.\n        \"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words whose lengths are prime numbers\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    # Join the filtered words back into a sentence\n    return \" \".join(prime_length_words)\n\n\n# Unit tests\ndef test_words_in_sentence():\n    assert words_in_sentence(\"This is a test\") == \"is\"\n    assert words_in_sentence(\"lets go for swimming\") == \"go for\"\n    assert words_in_sentence(\"a bb ccc dddd eeee fffff\") == \"a bb fffff\"\n    assert words_in_sentence(\"\") == \"\"\n    assert words_in_sentence(\"a a a a a a\") == \"a a a a a a\"\n    assert words_in_sentence(\"prime numbers\") == \"\"\n    assert words_in_sentence(\"I have a book\") == \"a\"\n    assert words_in_sentence(\"one two three four five\") == \"two\"\n\n    print(\"All tests passed!\")\n\n# Run the tests\ntest_words_in_sentence()"}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n    \n    Example:\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n\n    Arguments:\n    n : int : The number to evaluate.\n\n    Returns:\n    bool : True if n can be written as the sum of exactly 4 positive even numbers, False otherwise.\n    \"\"\"\n    # Check if input is of type int\n    if not isinstance(n, int):\n        raise ValueError(\"Input should be an integer\")\n\n    # Check edge cases\n    # The smallest sum of four positive even numbers (2 + 2 + 2 + 2) is 8\n    if n < 8:\n        return False\n\n    # Any even integer n >= 8 can be written as the sum of four positive even numbers.\n    # Think of the numbers as (2, 2, 2, x) where x = n - 6 and x is also positive and even.\n    \n    # Check if n is an even number\n    return n % 2 == 0\n\n# Unit tests\ndef test_is_equal_to_sum_even():\n    assert is_equal_to_sum_even(4) == False, \"Test case 4 failed\"\n    assert is_equal_to_sum_even(6) == False, \"Test case 6 failed\"\n    assert is_equal_to_sum_even(8) == True, \"Test case 8 failed\"\n    assert is_equal_to_sum_even(10) == True, \"Test case 10 failed\"\n    assert is_equal_to_sum_even(12) == True, \"Test case 12 failed\"\n    assert is_equal_to_sum_even(0) == False, \"Test case 0 failed\"  # Testing non-positive even edge case\n    assert is_equal_to_sum_even(7) == False, \"Test case 7 failed\"  # Testing odd number edge case\n    assert is_equal_to_sum_even(9) == False, \"Test case 9 failed\"  # Testing odd number > 8 edge case\n\n    # Testing type error\n    try:\n        is_equal_to_sum_even(\"10\")\n    except ValueError as e:\n        assert str(e) == \"Input should be an integer\", \"Type check test case failed\"\n\n    print(\"All test cases passed!\")\n\ntest_is_equal_to_sum_even()"}
{"task_id": "HumanEval/144", "completion": "from fractions import Fraction\nimport unittest\n\ndef simplify(x, n):\n    \"\"\"\n    Simplify the product of two fractions and check if it results in a whole number.\n    \n    Args:\n        x (str): String representation of the first fraction in the format 'numerator/denominator'.\n        n (str): String representation of the second fraction in the format 'numerator/denominator'.\n    \n    Returns:\n        bool: True if the product of the fractions is a whole number, False otherwise.\n    \"\"\"\n    # Convert the string inputs to Fraction objects\n    try:\n        fraction_x = Fraction(x)\n        fraction_n = Fraction(n)\n    except ValueError as ve:\n        raise ValueError(\"Invalid fraction format provided.\") from ve\n\n    # Compute the product of the two fractions\n    product = fraction_x * fraction_n\n\n    # Check if the product is a whole number\n    return product.denominator == 1\n\n# Unit test cases\nclass TestSimplify(unittest.TestCase):\n\n    def test_valid_cases(self):\n        self.assertTrue(simplify(\"1/5\", \"5/1\"))\n        self.assertFalse(simplify(\"1/6\", \"2/1\"))\n        self.assertFalse(simplify(\"7/10\", \"10/2\"))\n        self.assertTrue(simplify(\"3/4\", \"4/3\"))\n        self.assertTrue(simplify(\"6/1\", \"1/1\"))\n\n    def test_edge_cases(self):\n        self.assertTrue(simplify(\"1/1\", \"1/1\"))  # Product is 1 which is a whole number\n        self.assertFalse(simplify(\"1/2\", \"2/3\"))  # Product is 1/3 which is not a whole number\n        self.assertTrue(simplify(\"1000/1\", \"1/500\"))  # Product is 2 which is a whole number\n        self.assertTrue(simplify(\"1/1\", \"1000/1000\"))  # Product is 1 which is a whole number\n\n    def test_invalid_input(self):\n        with self.assertRaises(ValueError):\n            simplify(\"a/b\", \"c/d\")\n        with self.assertRaises(ValueError):\n            simplify(\"1/a\", \"1/2\")\n        with self.assertRaises(ValueError):\n            simplify(\"\", \"2/1\")\n\n# Trigger the unit tests\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are integers\n    for elem in lst:\n        if not isinstance(elem, int):\n            raise TypeError(\"All elements in the list must be integers.\")\n    \n    total_sum = 0\n    \n    for i, value in enumerate(lst):\n        if i % 3 == 0:\n            total_sum += value ** 2\n        elif i % 4 == 0:\n            total_sum += value ** 3\n        else:\n            total_sum += value\n    \n    return total_sum\n\n\n# Unit tests\ndef test_sum_squares():\n    assert sum_squares([1, 2, 3]) == 6\n    assert sum_squares([]) == 0\n    assert sum_squares([-1, -5, 2, -1, -5]) == -126\n    assert sum_squares([0, 0, 0, 0, 0]) == 0\n    assert sum_squares([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 641\n    assert sum_squares([3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == 784\n    \n    # Test for TypeError\n    try:\n        sum_squares(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"Input must be a list.\"\n    \n    try:\n        sum_squares([1, 2, \"string\", 4])\n    except TypeError as e:\n        assert str(e) == \"All elements in the list must be integers.\"\n\n\n# Run unit tests\ntest_sum_squares()"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n    \n    if not isinstance(lst, list):\n        raise ValueError(\"Input should be a list\")\n\n    if not lst:\n        return (None, None)\n\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        if not isinstance(num, int):\n            raise ValueError(\"List elements should be integers\")\n        \n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n    \n    return (largest_negative, smallest_positive)\n\n# Unit Test Cases\ndef test_largest_smallest_integers():\n    # Test for typical cases\n    assert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert largest_smallest_integers([-2, -4, -1, -3, -5, -7]) == (-1, None)\n    assert largest_smallest_integers([-2, 4, -1, 3, -5, 7]) == (-1, 3)\n\n    # Edge cases\n    assert largest_smallest_integers([]) == (None, None)\n    assert largest_smallest_integers([0]) == (None, None)\n    assert largest_smallest_integers([2, 0, -4, 7, 0, -1]) == (-1, 2)\n\n    # Test for invalid inputs\n    try:\n        largest_smallest_integers(None)\n    except ValueError as e:\n        assert str(e) == \"Input should be a list\"\n    \n    try:\n        largest_smallest_integers([2, 4, 'a', 3])\n    except ValueError as e:\n        assert str(e) == \"List elements should be integers\"\n\n# Run Unit Tests\ntest_largest_smallest_integers()"}
{"task_id": "HumanEval/141", "completion": "import re\n\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n    \n    # Validate input type\n    if not isinstance(file_name, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Condition 1: The file name should contain exactly one dot.\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into two parts based on the dot.\n    before_dot, after_dot = file_name.split('.')\n    \n    # Condition 2: The string before the dot should not be empty and should start with a letter.\n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n    \n    # Condition 3: The substring after the dot should be one of the specified extensions\n    valid_extensions = ['txt', 'exe', 'dll']\n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    # Condition 4: There should not be more than three digits in the file's name.\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'\n\n# Unit Tests\ndef test_file_name_check():\n    # Valid cases\n    assert file_name_check(\"example.txt\") == 'Yes'\n    assert file_name_check(\"a.b.dll\") == 'Yes'\n    assert file_name_check(\"file123.txt\") == 'Yes'\n    \n    # Invalid cases\n    assert file_name_check(\"1example.dll\") == 'No'  # starts with a digit\n    assert file_name_check(\"exampletxTexe\") == 'No'  # no dot\n    assert file_name_check(\"example.unknown\") == 'No'  # invalid extension\n    assert file_name_check(\"x.\" + \"e\" * (1000000) + \"txt\") == 'No'  # long invalid extension\n    assert file_name_check(\".txt\") == 'No'  # starts with dot\n    assert file_name_check(\"file1234.txt\") == 'No'  # more than 3 digits\n    assert file_name_check(\"file..txt\") == 'No'  # more than one dot\n    \n    # Edge cases\n    assert file_name_check(\"\") == 'No'  # empty string\n    assert file_name_check(\"..\") == 'No'  # two dots\n    assert file_name_check(\".dll\") == 'No'  # no substring before the dot\n    \n    print(\"All test cases pass\")\n\n# Execute the tests\ntest_file_name_check()"}
{"task_id": "HumanEval/140", "completion": "import re\nimport unittest\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Replace all sequences of more than 2 spaces with '-'\n    text = re.sub(r\" {3,}\", \"-\", text)\n    # Replace remaining spaces with '_'\n    text = text.replace(\" \", \"_\")\n    \n    return text\n\n\nclass TestFixSpaces(unittest.TestCase):\n    \n    def test_basic_cases(self):\n        self.assertEqual(fix_spaces(\"Example\"), \"Example\")\n        self.assertEqual(fix_spaces(\"Example 1\"), \"Example_1\")\n        self.assertEqual(fix_spaces(\" Example 2\"), \"_Example_2\")\n        self.assertEqual(fix_spaces(\" Example   3\"), \"_Example-3\")\n        self.assertEqual(fix_spaces(\" Another   Example 4\"), \"_Another-Example_4\")\n        self.assertEqual(fix_spaces(\"\"), \"\")\n    \n    def test_edge_cases(self):\n        self.assertEqual(fix_spaces(\"    \"), \"-\")\n        self.assertEqual(fix_spaces(\"  \"), \"__\")\n        self.assertEqual(fix_spaces(\" A    B \"), \"_A-B_\")\n        self.assertEqual(fix_spaces(\" A   B  \"), \"_A-B__\")\n        # Handling a very large input\n        large_input = \" \" * 10000 + \"End\"\n        self.assertEqual(fix_spaces(large_input), \"-\" + \"End\")\n    \n    def test_non_string_input(self):\n        with self.assertRaises(ValueError):\n            fix_spaces(None)\n        with self.assertRaises(ValueError):\n            fix_spaces(12345)\n        with self.assertRaises(ValueError):\n            fix_spaces([1, 2, 3])\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n    \n    # List of planets in order from the Sun\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Helper function to validate planet names\n    def is_valid_planet(planet):\n        return planet in planets\n    \n    # Check if both planets are valid\n    if not is_valid_planet(planet1) or not is_valid_planet(planet2):\n        return ()\n    \n    # Find indices of the planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Determine range between the two indices\n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    # Return the planets in between\n    return tuple(planets[index1 + 1:index2])\n\n# Unit test cases to validate implementation\n\nassert bf(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\")\nassert bf(\"Earth\", \"Mercury\") == (\"Venus\")\nassert bf(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nassert bf(\"Neptune\", \"Jupiter\") == (\"Saturn\", \"Uranus\")\nassert bf(\"Venus\", \"Mars\") == (\"Earth\")\nassert bf(\"Mercury\", \"Neptune\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\nassert bf(\"Mars\", \"Mars\") == ()\nassert bf(\"Pluto\", \"Mars\") == ()\nassert bf(\"Earth\", \"Pluto\") == ()\nassert bf(\"\", \"Mars\") == ()\nassert bf(\"Earth\", \"\") == ()\nassert bf(\"\", \"\") == ()\nassert bf(None, \"Mars\") == ()\nassert bf(\"Earth\", None) == ()\nassert bf(None, None) == ()\n\nprint(\"All test cases passed!\")"}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    \n    # Check that input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list of strings\")\n    \n    # Check that all elements in the list are of string type\n    if not all(isinstance(item, str) for item in lst):\n        raise ValueError(\"All elements in the list should be strings\")\n    \n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list based on length and then lexicographically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst\n\n# Test cases\ndef test_sorted_list_sum():\n    # Test with given examples\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \n    # Test with empty list\n    assert sorted_list_sum([]) == []\n    \n    # Test with all odd length strings\n    assert sorted_list_sum([\"a\", \"aaa\", \"a\"]) == []\n    \n    # Test with all even length strings\n    assert sorted_list_sum([\"ab\", \"bc\", \"cd\"]) == [\"ab\", \"bc\", \"cd\"]\n    \n    # Test with mixed even and odd lengths\n    assert sorted_list_sum([\"abcd\", \"ef\", \"ghij\", \"klm\", \"nopq\"]) == [\"ef\", \"abcd\", \"ghij\"]\n    \n    # Test with duplicates and varying lengths\n    assert sorted_list_sum([\"aa\", \"bb\", \"a\", \"b\", \"aa\"]) == [\"aa\", \"aa\", \"bb\"]\n    \n    # Test with different edge cases\n    assert sorted_list_sum([\"\", \"xy\", \"aaa\", \"bcc\", \"dddd\", \"ef\"]) == [\"\", \"xy\", \"ef\", \"dddd\"]\n    \n    print(\"All test cases pass\")\n\ntest_sorted_list_sum()"}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \"\"\"\n    \n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    \n    # Type checks\n    if not isinstance(n, int):\n        raise ValueError(\"The first argument (n) must be an integer.\")\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"The second (x) and third (y) arguments must be integers.\")\n    \n    # Check if n is prime and return the corresponding value\n    return x if is_prime(n) else y\n\n# Unit tests\ndef test_x_or_y():\n    assert x_or_y(7, 34, 12) == 34, \"Test case 1 failed\"\n    assert x_or_y(15, 8, 5) == 5, \"Test case 2 failed\"\n    assert x_or_y(2, 10, 20) == 10, \"Test case 3 failed\"\n    assert x_or_y(0, 3, 6) == 6, \"Test case 4 failed\"\n    assert x_or_y(-3, 1, 2) == 2, \"Test case 5 failed\"\n    assert x_or_y(1, 7, 9) == 9, \"Test case 6 failed\"\n    assert x_or_y(17, 5, 6) == 5, \"Test case 7 failed\"\n    print(\"All test cases pass\")\n\ntest_x_or_y()"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    \n    if not isinstance(number, int):\n        raise TypeError(\"The input must be an integer\")\n    \n    if not (1 <= number <= 1000):\n        raise ValueError(\"The number must be between 1 and 1000 inclusive\")\n    \n    # Roman numeral mappings in descending order.\n    roman_mapping = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'),\n        (1, 'I')\n    ]\n    \n    result = []\n    # Convert integer to roman numeral, iterating from the highest to lowest values\n    for value, numeral in roman_mapping:\n        while number >= value:\n            result.append(numeral)\n            number -= value\n    \n    # Convert the list of roman numerals to a string and make it lowercase\n    return ''.join(result).lower()\n    \n# Unit tests\ndef test_int_to_mini_roman():\n    assert int_to_mini_roman(1) == 'i'\n    assert int_to_mini_roman(4) == 'iv'\n    assert int_to_mini_roman(9) == 'ix'\n    assert int_to_mini_roman(58) == 'lviii'\n    assert int_to_mini_roman(199) == 'cxcix'\n    assert int_to_mini_roman(1000) == 'm'\n    assert int_to_mini_roman(3999) == 'mmmcmxcix'\n    print(\"All test cases pass\")\n\nif __name__ == \"__main__\":\n    test_int_to_mini_roman()\n    "}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Generate array a\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n\n    # Dictionary to store the counts of numbers based on their remainder when divided by 3\n    remainder_count = [0, 0, 0]\n\n    # Calculate the remainder counts\n    for value in a:\n        remainder_count[value % 3] += 1\n\n    # Number of triples can be computed based on remainder counts\n    count = 0\n\n    # Three numbers giving remainder 0 modulo 3\n    count += remainder_count[0] * (remainder_count[0] - 1) * (remainder_count[0] - 2) // 6\n    \n    # Three numbers giving pair [1, 1, 1] modulo 3\n    count += remainder_count[1] * (remainder_count[1] - 1) * (remainder_count[1] - 2) // 6\n\n    # Three numbers giving pair [2, 2, 2] modulo 3\n    count += remainder_count[2] * (remainder_count[2] - 1) * (remainder_count[2] - 2) // 6\n\n    # Any pair [0, 1, 2] will sum up to be a multiple of 3\n    count += remainder_count[0] * remainder_count[1] * remainder_count[2]\n\n    return count\n\n# Unit Tests\nimport unittest\n\nclass TestGetMaxTriples(unittest.TestCase):\n    def test_example_case(self):\n        self.assertEqual(get_max_triples(5), 1)\n\n    def test_small_values(self):\n        self.assertEqual(get_max_triples(1), 0)\n        self.assertEqual(get_max_triples(2), 0)\n        self.assertEqual(get_max_triples(3), 0)\n        self.assertEqual(get_max_triples(4), 0)\n        self.assertEqual(get_max_triples(6), 1)\n        self.assertEqual(get_max_triples(7), 2)\n        \n    def test_larger_values(self):\n        self.assertEqual(get_max_triples(10), 29)\n        self.assertEqual(get_max_triples(20), 1140)\n\n    def test_invalid_input(self):\n        with self.assertRaises(ValueError):\n            get_max_triples(-1)\n        with self.assertRaises(ValueError):\n            get_max_triples(0)\n        with self.assertRaises(ValueError):\n            get_max_triples(\"10\")\n\n    def test_edge_cases(self):\n        self.assertEqual(get_max_triples(100), 514149)\n        self.assertEqual(get_max_triples(150), 1715324)\n\n\n# Run the unit tests\nunittest.main(argv=[''], exit=False)\n"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    \n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list of numbers\")\n    \n    sum_of_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 == 1:\n            sum_of_squares += num ** 2\n    \n    return sum_of_squares\n\n# Unit Tests\ndef test_double_the_difference():\n    assert double_the_difference([1, 3, 2, 0]) == 10, \"Test Case 1 Failed\"\n    assert double_the_difference([-1, -2, 0]) == 0, \"Test Case 2 Failed\"\n    assert double_the_difference([9, -2]) == 81, \"Test Case 3 Failed\"\n    assert double_the_difference([0]) == 0, \"Test Case 4 Failed\"\n    assert double_the_difference([]) == 0, \"Test Case 5 Failed\"\n    assert double_the_difference([7, 5, 0, 8, -3]) == 74, \"Test Case 6 Failed\"\n    assert double_the_difference([1.5, 3.0, 7]) == 49, \"Test Case 7 Failed\"\n    \n    print(\"All test cases pass\")\n\n# Running the tests\ntest_double_the_difference()"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n    \n    if not isinstance(class_name, str):\n        raise TypeError(\"class_name must be a string\")\n    if not isinstance(extensions, list):\n        raise TypeError(\"extensions must be a list\")\n    if any(not isinstance(ext, str) for ext in extensions):\n        raise TypeError(\"All extensions must be strings\")\n    \n    if not extensions:  # handle empty list of extensions\n        return f\"{class_name}.\"\n    \n    max_strength = float('-inf')\n    strongest_extension = None\n    \n    # Find the strongest extension\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\"\n\n\n# Unit tests\ndef test_Strongest_Extension():\n    assert Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]) == \"Slices.SErviNGSliCes\"\n    assert Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\n    assert Strongest_Extension(\"test\", [\"Abc\", \"DEF\", \"acbD\"]) == \"test.DEF\"\n    assert Strongest_Extension(\"example\", []) == \"example.\"\n    assert Strongest_Extension(\"sample\", [\"\"]) == \"sample.\"\n    assert Strongest_Extension(\"case\", [\"abcd\", \"ABCD\"]) == \"case.ABCD\"\n    assert Strongest_Extension(\"mix\", [\"aaBB\", \"BBB\"]) == \"mix.BBB\"\n    \n    try:\n        Strongest_Extension(123, [\"AA\", \"Be\", \"CC\"])\n    except TypeError as e:\n        assert str(e) == \"class_name must be a string\"\n    \n    try:\n        Strongest_Extension(\"test\", \"not_a_list\")\n    except TypeError as e:\n        assert str(e) == \"extensions must be a list\"\n    \n    try:\n        Strongest_Extension(\"test\", [123, \"ABC\"])\n    except TypeError as e:\n        assert str(e) == \"All extensions must be strings\"\n\ntest_Strongest_Extension()"}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n\n    # Check if input is a list\n    if not isinstance(nums, list):\n        raise TypeError(\"Input should be a list of numbers.\")\n\n    # Handling edge case of an empty list\n    if not nums:\n        return 0\n\n    # Define a set of odd digits for quick lookup\n    odd_digits = {'1', '3', '5', '7', '9'}\n    \n    count = 0\n    \n    for num in nums:\n        # Convert number to its absolute string representation to analyze digits\n        num_str = str(abs(num))\n        \n        if len(num_str) > 0:\n            first_digit = num_str[0]\n            last_digit = num_str[-1]\n            \n            # Check the conditions: number > 10, first and last digits are odd\n            if num > 10 and first_digit in odd_digits and last_digit in odd_digits:\n                count += 1\n    \n    return count\n\n# Unit Tests\nimport unittest\n\nclass TestSpecialFilter(unittest.TestCase):\n    def test_basic_cases(self):\n        self.assertEqual(specialFilter([15, -73, 14, -15]), 1)\n        self.assertEqual(specialFilter([33, -2, -3, 45, 21, 109]), 2)\n\n    def test_no_valid_elements(self):\n        self.assertEqual(specialFilter([2, 4, 8, 12]), 0)\n        self.assertEqual(specialFilter([-1, -3, 5, 9]), 0)\n    \n    def test_empty_input(self):\n        self.assertEqual(specialFilter([]), 0)\n    \n    def test_large_numbers(self):\n        self.assertEqual(specialFilter([10000000001, 7777777777777]), 1)\n        self.assertEqual(specialFilter([99999, 50005, 81018]), 2)\n\n    def test_single_element(self):\n        self.assertEqual(specialFilter([81]), 1)\n        self.assertEqual(specialFilter([7]), 0)\n    \n    def test_error_handling(self):\n        with self.assertRaises(TypeError):\n            specialFilter(None)\n        with self.assertRaises(TypeError):\n            specialFilter(\"123\")\n        with self.assertRaises(TypeError):\n            specialFilter(123)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    \n    # Check if input is a list\n    if not isinstance(nums, list):\n        raise TypeError(\"Input should be a list of integers.\")\n    \n    # Guard clause for empty list\n    if not nums:\n        return []\n\n    # Function to calculate the sum of digits of a number\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    # Create a list of tuples (index, num, sum_of_digits)\n    indexed_nums = [(i, num, sum_of_digits(num)) for i, num in enumerate(nums)]\n\n    # Sort primarily by sum of digits, then by original index\n    sorted_nums = sorted(indexed_nums, key=lambda x: (x[2], x[0]))\n\n    # Extract the sorted list of numbers\n    result = [num for _, num, _ in sorted_nums]\n    \n    return result\n\n# Unit tests\ndef test_order_by_points():\n    assert order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert order_by_points([]) == []\n    assert order_by_points([5, 50, -5, -50]) == [-5, 5, -50, 50]\n    assert order_by_points([123, 321, 213, -231]) == [123, 213, 321, -231]\n    assert order_by_points([0, 0, 0, 0]) == [0, 0, 0, 0]\n    \n    print(\"All tests passed.\")\n\n# Run the tests\ntest_order_by_points()"}
{"task_id": "HumanEval/152", "completion": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match.\n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n    # Check for valid input types\n    if not all(isinstance(i, int) for i in game) or not all(isinstance(i, int) for i in guess):\n        raise TypeError(\"Both game and guess lists must contain integers only.\")\n    \n    # Check if lengths of inputs are the same\n    if len(game) != len(guess):\n        raise ValueError(\"Both input lists must have the same length.\")\n\n    # Initialize the result list\n    result = []\n    \n    # Iterate over the pairs of scores and guesses and calculate the difference\n    for score, g in zip(game, guess):\n        difference = abs(score - g)\n        result.append(difference)\n    \n    return result\n\n# Example usage and test cases\nprint(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))  # Expected: [0, 0, 0, 0, 3, 3]\nprint(compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2]))  # Expected: [4, 4, 1, 0, 0, 6]\n\nimport unittest\n\nclass TestCompareFunction(unittest.TestCase):\n\n    def test_basic_cases(self):\n        self.assertEqual(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]), [0, 0, 0, 0, 3, 3])\n        self.assertEqual(compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2]), [4, 4, 1, 0, 0, 6])\n\n    def test_empty_lists(self):\n        self.assertEqual(compare([], []), [])\n\n    def test_single_element(self):\n        self.assertEqual(compare([1], [1]), [0])\n        self.assertEqual(compare([1], [2]), [1])\n\n    def test_negative_numbers(self):\n        self.assertEqual(compare([-1, -5, -3], [-1, -2, -4]), [0, 3, 1])\n\n    def test_invalid_input_types(self):\n        with self.assertRaises(TypeError):\n            compare([1, 2, 3], [\"a\", \"b\", \"c\"])\n        with self.assertRaises(TypeError):\n            compare(\"123\", [1, 2, 3])\n\n    def test_mismatched_lengths(self):\n        with self.assertRaises(ValueError):\n            compare([1, 2, 3], [1, 2, 3, 4])\n\nif __name__ == \"__main__\":\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)"}
{"task_id": "HumanEval/162", "completion": "import hashlib\n\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \n    :param text: str, input string to be converted to its MD5 hash.\n    :return: str or None, the MD5 hash string or None if input is empty.\n    \n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string\")\n    \n    if text == '':\n        return None\n\n    # Use hashlib to generate the MD5 hash\n    md5_hash = hashlib.md5(text.encode())\n    return md5_hash.hexdigest()\n\n\n# Unit tests\ndef test_string_to_md5():\n    # Test typical case\n    assert string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \n    # Test empty string\n    assert string_to_md5('') is None\n    \n    # Test non-string input should raise an error\n    try:\n        string_to_md5(123)\n    except ValueError as e:\n        assert str(e) == \"Input must be a string\"\n    \n    # Test large input\n    large_text = 'a' * 1000000\n    assert string_to_md5(large_text) == hashlib.md5(large_text.encode()).hexdigest()\n    \n    print(\"All tests passed!\")\n\n\n# Uncomment the following line to run tests\n# test_string_to_md5()\n"}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n    # Input validation\n    if not isinstance(a, str) or not isinstance(b, str):\n        raise ValueError(\"Both a and b should be strings\")\n    \n    if len(b) == 0:\n        return True  # Empty string is a rotation of any string\n    \n    b_length = len(b)\n    \n    for i in range(b_length):\n        # Generate the rotation of b\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    return False\n\n# Unit Tests\nimport unittest\n\nclass TestCycpatternCheck(unittest.TestCase):\n    \n    def test_typical_cases(self):\n        self.assertFalse(cycpattern_check(\"abcd\", \"abd\"))\n        self.assertTrue(cycpattern_check(\"hello\", \"ell\"))\n        self.assertFalse(cycpattern_check(\"whassup\", \"psus\"))\n        self.assertTrue(cycpattern_check(\"abab\", \"baa\"))\n        self.assertFalse(cycpattern_check(\"efef\", \"eeff\"))\n        self.assertTrue(cycpattern_check(\"himenss\", \"simen\"))\n    \n    def test_empty_b(self):\n        self.assertTrue(cycpattern_check(\"abcdef\", \"\"))\n    \n    def test_empty_a(self):\n        self.assertFalse(cycpattern_check(\"\", \"abc\"))\n    \n    def test_b_longer_than_a(self):\n        self.assertFalse(cycpattern_check(\"abc\", \"abcd\"))\n    \n    def test_same_word(self):\n        self.assertTrue(cycpattern_check(\"abc\", \"abc\"))\n    \n    def test_edge_cases(self):\n        self.assertFalse(cycpattern_check(\"\", \"\"))\n        self.assertRaises(ValueError, cycpattern_check, None, \"abc\")\n        self.assertRaises(ValueError, cycpattern_check, \"abc\", None)\n    \nif __name__ == \"__main__\":\n    unittest.main()  # This will run all the test cases"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    \"\"\"\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n    \n    :param words: List of strings\n    :return: String with the maximum number of unique characters\n    \"\"\"\n    # Check if input is a list\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list of strings\")\n    \n    # Check if all elements in the list are strings\n    if not all(isinstance(word, str) for word in words):\n        raise ValueError(\"All elements in the list must be strings\")\n    \n    max_unique_chars = -1\n    result = \"\"\n\n    for word in words:\n        # Calculate the number of unique characters in the current word\n        unique_chars = len(set(word))\n        \n        # Update the result if the current word has more unique characters\n        # or if it has the same number of unique characters but comes first lexicographically\n        if (unique_chars > max_unique_chars or\n            (unique_chars == max_unique_chars and word < result)):\n            max_unique_chars = unique_chars\n            result = word\n            \n    return result\n\n# Unit tests\nimport unittest\n\nclass TestFindMax(unittest.TestCase):\n    def test_typical_cases(self):\n        self.assertEqual(find_max([\"name\", \"of\", \"string\"]), \"string\")\n        self.assertEqual(find_max([\"name\", \"enam\", \"game\"]), \"enam\")\n        self.assertEqual(find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]), \"aaaaaaa\")\n    \n    def test_empty_list(self):\n        self.assertEqual(find_max([]), \"\")\n    \n    def test_single_element(self):\n        self.assertEqual(find_max([\"single\"]), \"single\")\n    \n    def test_all_same_chars(self):\n        self.assertEqual(find_max([\"aaaa\", \"bbb\", \"cccc\"]), \"aaaa\")\n    \n    def test_non_string_elements(self):\n        with self.assertRaises(ValueError):\n            find_max([\"string\", 123, True])\n    \n    def test_non_list_input(self):\n        with self.assertRaises(TypeError):\n            find_max(\"string\")\n    \n    def test_large_dataset(self):\n        large_list = [\"\".join(chr(i) for i in range(97, 123))] * 1000\n        self.assertEqual(find_max(large_list), \"abcdefghijklmnopqrstuvwxyz\")\n\n# Execute the unit tests\nunittest.main(argv=[''], verbosity=2, exit=False)"}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n\n    # Input validation\n    if not all(isinstance(side, (int, float)) for side in (a, b, c)):\n        raise ValueError(\"All sides must be numbers.\")\n    if not all(side > 0 for side in (a, b, c)):\n        raise ValueError(\"All sides must be positive.\")\n    \n    # Sort sides so that c is the longest side\n    sides = sorted([a, b, c])\n    a, b, c = sides[0], sides[1], sides[2]\n    \n    # Check for right-angled triangle using Pythagorean theorem\n    return round(a**2 + b**2, 5) == round(c**2, 5)\n\n# Unit test cases\ndef test_right_angle_triangle():\n    # Typical scenarios\n    assert right_angle_triangle(3, 4, 5) == True, \"Test case 1 failed\"\n    assert right_angle_triangle(5, 12, 13) == True, \"Test case 2 failed\"\n\n    # Non right-angle triangles\n    assert right_angle_triangle(1, 2, 3) == False, \"Test case 3 failed\"\n    assert right_angle_triangle(6, 8, 9) == False, \"Test case 4 failed\"\n\n    # Incorrect type inputs\n    try:\n        right_angle_triangle(3, 4, '5')\n    except ValueError as e:\n        assert str(e) == \"All sides must be numbers.\", \"Test case 5 failed\"\n\n    # Non-positive inputs\n    try:\n        right_angle_triangle(-3, 4, 5)\n    except ValueError as e:\n        assert str(e) == \"All sides must be positive.\", \"Test case 6 failed\"\n\n    # Edge cases with floating point precision\n    assert right_angle_triangle(3.0, 4.0, 5.0) == True, \"Test case 7 failed\"\n    assert right_angle_triangle(1.5, 2.0, 2.5) == True, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Running the tests\ntest_right_angle_triangle()"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer, return a tuple that has the number of even and odd digits respectively.\n    \n    Args:\n        num (int): The input integer.\n\n    Returns:\n        tuple: A tuple where the first element is the count of even digits and the second is the count of odd digits.\n    \n    Examples:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    # Check if the input is an integer\n    if not isinstance(num, int):\n        raise ValueError(\"Input must be an integer\")\n\n    # Initialize counters\n    even_count = 0\n    odd_count = 0\n    \n    # Convert the number to its absolute value to handle negative inputs\n    num = abs(num)\n\n    # Convert the number to a string to iterate through its digits\n    num_str = str(num)\n    \n    for digit in num_str:\n        if digit in '02468':  # Check if the digit is even\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return (even_count, odd_count)\n\n# Unit Tests\ndef test_even_odd_count():\n    # Basic tests\n    assert even_odd_count(-12) == (1, 1)\n    assert even_odd_count(123) == (1, 2)\n    \n    # Edge cases\n    assert even_odd_count(0) == (1, 0)       # Single even digit\n    assert even_odd_count(1111111111) == (0, 10)  # All odd digits\n    assert even_odd_count(2222222222) == (10, 0)  # All even digits\n    assert even_odd_count(1234567890) == (5, 5)   # Mixed even and odd digits\n    \n    # Large number test\n    large_num = int(\"1\" * 10**6)  # A large number with all odd digits\n    assert even_odd_count(large_num) == (0, 10**6)\n    \n    print(\"All test cases pass\")\n\ntest_even_odd_count()"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    # Validation of inputs\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both inputs must be integers\")\n    if a < 1 or b < 1:\n        raise ValueError(\"Inputs must be positive integers\")\n\n    # Determine lower and upper bounds\n    low, high = min(a, b), max(a, b)\n\n    # Generate even digits in the specified range\n    even_digits = [i for i in range(low, high + 1) if i % 2 == 0 and i < 10]  # Only single digit, i < 10\n\n    return even_digits\n\n\n# Unit tests\ndef test_generate_integers():\n    assert generate_integers(2, 8) == [2, 4, 6, 8], \"Test case 1 failed\"\n    assert generate_integers(8, 2) == [2, 4, 6, 8], \"Test case 2 failed\"\n    assert generate_integers(10, 14) == [], \"Test case 3 failed\"\n    assert generate_integers(1, 1) == [], \"Test case 4 failed\"\n    assert generate_integers(0, 9) == [2, 4, 6, 8], \"Test case 5 failed\"\n    assert generate_integers(2, 9) == [2, 4, 6, 8], \"Test case 6 failed\"\n\n    try:\n        generate_integers(-2, 8)\n    except ValueError as e:\n        assert str(e) == \"Inputs must be positive integers\", \"Test case 7 failed\"\n\n    try:\n        generate_integers(2, '8')\n    except ValueError as e:\n        assert str(e) == \"Both inputs must be integers\", \"Test case 8 failed\"\n    \n    try:\n        generate_integers(\"a\", 8)\n    except ValueError as e:\n        assert str(e) == \"Both inputs must be integers\", \"Test case 9 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run tests\ntest_generate_integers()"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Check if there are any letters in the string\n    contains_letters = any(char.isalpha() for char in s)\n\n    if contains_letters:\n        # Reverse the case for each letter\n        result = []\n        for char in s:\n            if char.islower():\n                result.append(char.upper())\n            elif char.isupper():\n                result.append(char.lower())\n            else:\n                result.append(char)\n        return ''.join(result)\n    else:\n        # Reverse the string\n        return s[::-1]\n\n# Unit tests\nimport unittest\n\nclass TestSolve(unittest.TestCase):\n    def test_all_digits(self):\n        self.assertEqual(solve(\"1234\"), \"4321\")\n        \n    def test_all_lowercase_letters(self):\n        self.assertEqual(solve(\"ab\"), \"AB\")\n        \n    def test_mixed_letters_and_symbols(self):\n        self.assertEqual(solve(\"#a@C\"), \"#A@c\")\n        \n    def test_empty_string(self):\n        self.assertEqual(solve(\"\"), \"\")\n        \n    def test_no_letters(self):\n        self.assertEqual(solve(\"123!@#\"), \"#@!321\")\n        \n    def test_all_uppercase_letters(self):\n        self.assertEqual(solve(\"ABC\"), \"abc\")\n        \n    def test_mixed_case_and_digits(self):\n        self.assertEqual(solve(\"A1b2C\"), \"a1B2c\")\n        \n    def test_single_letter_lower(self):\n        self.assertEqual(solve(\"a\"), \"A\")\n        \n    def test_single_letter_upper(self):\n        self.assertEqual(solve(\"A\"), \"a\")\n        \n    def test_large_input(self):\n        long_string = \"a\" * 10**6\n        self.assertEqual(solve(long_string), \"A\" * 10**6)\n        \n    def test_non_string_input(self):\n        with self.assertRaises(TypeError):\n            solve(1234)\n\nif __name__ == \"__main__\":\n    unittest.main()"}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebraic \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"\n    if not isinstance(operator, list) or not isinstance(operand, list):\n        raise TypeError(\"Both operator and operand must be lists.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The length of operator list must be equal to the length of operand list minus one.\")\n    \n    if any(op not in {'+', '-', '*', '//', '**'} for op in operator):\n        raise ValueError(\"Operators must be one of '+', '-', '*', '//', '**'.\")\n\n    if any(not isinstance(num, int) or num < 0 for num in operand):\n        raise ValueError(\"Operand list must only contain non-negative integers.\")\n    \n    # Start with the first operand\n    result = operand[0]\n    \n    # Apply each operator with the corresponding operand\n    for i, op in enumerate(operator):\n        if op == '+':\n            result += operand[i + 1]\n        elif op == '-':\n            result -= operand[i + 1]\n        elif op == '*':\n            result *= operand[i + 1]\n        elif op == '//':\n            if operand[i + 1] == 0:\n                raise ValueError(\"Division by zero is not allowed.\")\n            result //= operand[i + 1]\n        elif op == '**':\n            result **= operand[i + 1]\n    \n    return result\n\n# Unit test cases\ndef test_do_algebra():\n    assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert do_algebra(['-', '//'], [10, 2, 3]) == 2\n    assert do_algebra(['*', '+'], [5, 3, 2]) == 17\n    assert do_algebra(['**'], [2, 3]) == 8\n    assert do_algebra(['+', '*', '//', '**'], [1, 2, 3, 4, 2]) == 2\n    try:\n        do_algebra(['+'], [1])\n    except ValueError as e:\n        assert str(e) == \"The length of operator list must be equal to the length of operand list minus one.\"\n    try:\n        do_algebra(['/', '*'], [1, 2, 3])\n    except ValueError as e:\n        assert str(e) == \"Operators must be one of '+', '-', '*', '//', '**'.\"\n    try:\n        do_algebra(['+'], [2, -3])\n    except ValueError as e:\n        assert str(e) == \"Operand list must only contain non-negative integers.\"\n    try:\n        do_algebra(['//'], [5, 0])\n    except ValueError as e:\n        assert str(e) == \"Division by zero is not allowed.\"\n    print(\"All test cases passed.\")\n    \n# Run the tests\ntest_do_algebra()"}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    \n    # Type checks\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if not isinstance(need, int):\n        raise TypeError(\"need must be an integer\")\n    if not isinstance(remaining, int):\n        raise TypeError(\"remaining must be an integer\")\n    \n    # Constraint checks\n    if not (0 <= number <= 1000):\n        raise ValueError(\"number must be between 0 and 1000\")\n    if not (0 <= need <= 1000):\n        raise ValueError(\"need must be between 0 and 1000\")\n    if not (0 <= remaining <= 1000):\n        raise ValueError(\"remaining must be between 0 and 1000\")\n    \n    # Calculate the total carrots eaten and leftover carrots\n    total_eaten = number + min(need, remaining)\n    remaining_left = max(0, remaining - need)\n    \n    return [total_eaten, remaining_left]\n\n# Tests to validate the implementation\ndef test_eat():\n    # Typical scenarios\n    assert eat(5, 6, 10) == [11, 4]\n    assert eat(4, 8, 9) == [12, 1]\n    assert eat(1, 10, 10) == [11, 0]\n    assert eat(2, 11, 5) == [7, 0]\n    \n    # Edge cases\n    assert eat(0, 0, 0) == [0, 0]\n    assert eat(1000, 0, 1000) == [1000, 1000]\n    assert eat(0, 1000, 1000) == [1000, 0]\n    assert eat(4, 8, 0) == [4, 0]\n    \n    # Error cases\n    try:\n        eat(\"a\", 5, 10)\n    except TypeError:\n        assert True\n    \n    try:\n        eat(7, \"b\", 10)\n    except TypeError:\n        assert True\n\n    try:\n        eat(7, 8, \"c\")\n    except TypeError:\n        assert True\n    \n    try:\n        eat(1001, 5, 5)\n    except ValueError:\n        assert True\n    \n    try:\n        eat(5, 1001, 5)\n    except ValueError:\n        assert True\n            \n    try:\n        eat(5, 5, 1001)\n    except ValueError:\n        assert True\n\ntest_eat()"}
