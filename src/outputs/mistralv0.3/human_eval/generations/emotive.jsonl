{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    result = []\n    for number in range(max(a, b), min(a, b) - 1, -1):\n        if number % 2 == 0 and 0 < number <= 99:\n            result.append(number)\n        elif number >= 100 and (number % 2 == 0 and number % 10 == 0):\n            result.append(number)\n    return sorted(result) if result else []"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return \"\".join(strings)"}
{"task_id": "HumanEval/6", "completion": "from collections import deque\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    stack = deque()\n    levels = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            level = 1 + (len(stack) - stack.index(char))\n            levels.append(level)\n        elif char == ')':\n            stack.pop()\n            levels[-1] = max(levels[-1] - 1, 0)\n    return levels"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    # Create a copy of the list for sorting and sort it in descending order\n    sorted_lst = sorted(lst, reverse=True)\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over the sorted list and append elements based on the strange sorting rule\n    for i in range(len(sorted_lst)):\n        # Find the minimum value from the remaining unprocessed elements\n        min_val = min(lst, key=lambda x: (x not in result))\n        # If such a minimum value is found, append it to the result and remove it from the original list\n        if min_val:\n            result.append(min_val)\n            lst.remove(min_val)\n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    if not xs:\n        raise ValueError(\"The list cannot be empty.\")\n\n    result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * (i + 1))\n    result.insert(0, 0)\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    # Check if the list is empty or has only one element, as both cases are considered monotonically increasing/decreasing\n    if len(l) <= 1:\n        return True\n\n    # Initialize variables for storing the first element and its comparison type (increasing or decreasing)\n    prev_element = l[0]\n    comparison_type = 'increasing' if l[1] > prev_element else 'decreasing'\n\n    # Iterate through the list, comparing each element with the next one and checking if the comparison type is consistent\n    for i in range(1, len(l)):\n        current_element = l[i]\n        if (comparison_type == 'increasing' and current_element <= prev_element) or \\\n           (comparison_type == 'decreasing' and current_element > prev_element):\n            return False\n        prev_element = current_element\n\n    # If no inconsistency was found, the list is monotonically increasing/decreasing\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(dict.fromkeys(numbers))"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    result = 1\n    for i in range(2, n + 1):\n        result *= i * special_factorial(i - 1)\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value if isinstance(value, int) else None for value in values if value is not None]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    sum_of_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0:\n            if num % 2 != 0:\n                squared_num = num ** 2\n                sum_of_squares += squared_num\n    return sum_of_squares"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    return sum(sum(abs(digit) for digit in str(num)) > 0 for num in arr)"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]):\n    if not numbers:\n        return (0, 1)\n\n    sum_val = sum(numbers)\n    product_val = 1\n    for num in numbers:\n        product_val *= num\n\n    return (sum_val, product_val)"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i != 0:\n            i += 1\n        else:\n            n //= i\n\n    return n if n > 1 else 1"}
{"task_id": "HumanEval/129", "completion": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    def dfs(i: int, j: int, visited: set, path: List[int], total: int):\n        if len(path) > k or total > k:\n            return\n        if len(path) == k and total == k:\n            # Check if the current path is lexicographically smaller than any other found paths\n            if not paths or path < paths[0]:\n                paths = [path]\n        if (i, j) in visited or i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] in visited:\n            return\n        visited.add((i, j))\n        dfs(i + 1, j, visited, path + [grid[i][j]], total + grid[i][j])\n        dfs(i - 1, j, visited, path, total)\n        dfs(i, j + 1, visited, path, total)\n        dfs(i, j - 1, visited, path, total)\n        visited.remove((i, j))\n\n    paths = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            dfs(i, j, set(), [grid[i][j]], grid[i][j])\n    return paths[0] if paths else []"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n    return result or s[::-1]  # If the string contains no letters, reverse it"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if isprime(len(word))]\n    return \" \".join(prime_words)\n\ndef isprime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n\n    if num < 0:\n        num *= -1\n\n    while num > 0:\n        rem = num % 10\n        if rem == 0:\n            continue\n        elif rem % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    # Initialize counters for even and odd palindromes\n    even_count = 0\n    odd_count = 0\n\n    # Iterate through the range of numbers from 1 to n, inclusive\n    for i in range(1, n+1):\n        # Check if the number is a palindrome and its length is odd or even\n        if str(i) == str(i)[::-1] and len(str(i)) % 2 == 0:\n            even_count += 1\n        elif str(i) == str(i)[::-1]:\n            odd_count += 1\n\n    # Return the tuple with the number of even and odd palindromes found\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack[-1] != \"<\":\n                return False\n            stack.pop()\n    return len(stack) == 0"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n\n        start = i + 1\n        end = len(nums)\n\n        while start < end:\n            mid = (start + end) // 2\n            subarray_sum = current_sum - nums[mid-1:mid]\n\n            if subarray_sum >= 0:\n                end = mid\n            else:\n                start = mid + 1\n\n        min_subarray_length, min_subarray_sum = start - i, subarray_sum\n\n        if min_subarray_length > 0 and min_subarray_sum < min_sum:\n            min_sum = min_subarray_sum\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack, result = [], []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return []  # Invalid parentheses structure\n            stack.pop()\n    if stack:\n        return []  # Unbalanced parentheses\n\n    while stack:\n        result.append(''.join(stack))\n        stack.pop(0)\n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    # Create a set from the input list to remove duplicates and make searching faster\n    unique_numbers = set(l)\n\n    for num1 in unique_numbers:\n        for num2 in unique_numbers:\n            if num1 + num2 in unique_numbers:\n                return True\n\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    result = []\n    for i in range(len(game)):\n        diff = abs(game[i] - guess[i])\n        result.append(diff)\n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, len(lst[i]) - j - 1))\n\n    # Sort by rows and then columns\n    result.sort(key=lambda x: x[0])\n    for i in range(len(result)):\n        for j in range(i):\n            if result[i][0] == result[j][0] and result[i][1] < result[j][1]:\n                result[i], result[j] = result[j], result[i]\n    return result"}
