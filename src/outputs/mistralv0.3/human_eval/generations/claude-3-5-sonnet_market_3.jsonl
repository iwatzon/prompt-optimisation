{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n\n    # Ensure a and b are positive integers\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        raise ValueError(\"Both a and b must be positive integers.\")\n\n    # Convert a and b to strings for easier digit extraction\n    a_str = str(a)\n    b_str = str(b)\n\n    # Initialize an empty list to store the even digits\n    result = []\n\n    # Iterate through each digit of a, then b (since we're interested in smaller numbers first)\n    for i in range(len(a_str)):\n        digit = int(a_str[i])\n        if digit % 2 == 0:\n            result.append(digit)\n\n        # If the current digit is greater than the smallest digit in b, we're done\n        if int(a_str[i]) > min(b_str):\n            break\n\n    # Iterate through the remaining digits of b (if any) and append even ones to the result list\n    for i in range(len(b_str)):\n        digit = int(b_str[i])\n        if digit % 2 == 0:\n            result.append(digit)\n\n    # Sort the result list in ascending order and return it\n    return sorted(result)"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenate list of strings into a single string. Handles empty lists and None values.\n\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    >>> concatenate(None)\n    Traceback (most recent call last):\n        ...\n    TypeError: Object of type 'NoneType' is not iterable\n    \"\"\"\n    if strings is None:\n        raise TypeError(\"Object of type 'NoneType' is not iterable\")\n\n    result = ''\n    for string in strings:\n        if isinstance(string, str):\n            result += string\n        else:\n            raise TypeError(f\"Expected string, got {type(string)} instead.\")\n\n    return result"}
{"task_id": "HumanEval/6", "completion": "from typing import List\nfrom collections import deque\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> parse_nested_parens('(()()) ((())) () ((())()())')\n        [2, 3, 1, 3]\n    \"\"\"\n\n    def is_open(char):\n        return char == '('\n\n    def is_close(char):\n        return char == ')'\n\n    def get_level(char):\n        if not char:\n            return 0\n        return 1 + (1 if is_open(char) else -1)\n\n    result = []\n    stack = deque()\n    for char in paren_string:\n        level = get_level(char)\n        if level > 0:\n            stack.append(level)\n        elif level < 0 and not stack:\n            result.append(0)\n        elif level < 0:\n            top_level = stack.pop()\n            result.append(max(top_level, level))\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n\n    # First, we sort the list in ascending order. This is a common preprocessing step for many sorting algorithms.\n    sorted_lst = sorted(lst)\n\n    # Then, we create an empty list to store the result.\n    result = []\n\n    # We iterate over the sorted list and add elements to the result list according to the strange sorting rule.\n    for i in range(len(sorted_lst)):\n        # If the current index is 0, we add the minimum value (first element) of the sorted list.\n        if i == 0:\n            result.append(sorted_lst[i])\n        # Otherwise, we find the maximum remaining value and add it to the result list.\n        else:\n            max_remaining = max(sorted_lst[i:])\n            result.append(max_remaining)\n\n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"\n    xs represent coefficients of a polynomial in descending powers order.\n    Return the derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n    if not xs:\n        raise ValueError(\"The list cannot be empty to find the derivative.\")\n\n    result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i - 1] * i)\n    result.insert(0, sum(xs[1:]))\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"Return True if the elements in the list are either all increasing or all decreasing.\"\"\"\n\n    # Initialize variables to store the first element and its comparison value\n    first = l[0]\n    comparison_value = first\n\n    for num in l[1:]:\n        # If the current number is less than the comparison value, it means we've encountered a decreasing sequence.\n        if num < comparison_value:\n            # Check if the list contains any increasing sequences. If not, return False.\n            if not any(x > comparison_value for x in l):\n                return False\n            # Update the comparison value and continue checking the rest of the list.\n            comparison_value = num\n        # If the current number is greater than or equal to the comparison value, it means we're still within an increasing sequence.\n        else:\n            comparison_value = min(comparison_value, num)\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    if not l:\n        raise ValueError(\"The input list is empty.\")\n\n    max_value = l[0]\n\n    for element in l:\n        if element > max_value:\n            max_value = element\n\n    return max_value"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n    # Create a set to store unique numbers and convert it back into a list at the end\n    unique_numbers = set(numbers)\n\n    return list(unique_numbers)"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value if isinstance(value, int) else None for value in values if value is not None]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n     If the input list is empty, return 0.\n    '''\n\n    # Filter out non-integer and negative values from the list\n    filtered_lst = [num for num in lst if isinstance(num, int) and num >= 0]\n\n    # Calculate the sum of squares of odd numbers in the filtered list\n    square_sum = sum(x**2 for x in filtered_lst if x % 2 != 0)\n\n    return square_sum * 2"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Count the number of elements in an array whose sum of digits is greater than 0.\n    If a number is negative, then its first signed digit will be considered as part of the sum.\n    \"\"\"\n\n    def sum_of_digits(n):\n        if n < 0:\n            n = abs(n)\n        total = 0\n        while n > 0:\n            total += n % 10\n            n //= 10\n        return total\n\n    return len([num for num in arr if sum_of_digits(num) > 0])"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n\n    sum_value = sum(numbers)\n    product_value = reduce((lambda x, y: x * y), numbers)\n\n    return (sum_value, product_value)"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n\n    Args:\n        strings (List[str]): The list of strings to be filtered.\n        substring (str): The substring to search in the strings.\n\n    Returns:\n        List[str]: A new list containing only the strings from the input list that contain the given substring.\n\n    Raises:\n        ValueError: If the input list or substring is empty.\n\n    Note: This function uses the built-in 'in' operator to check if a string contains the substring, and list comprehension for filtering.\n    \"\"\"\n\n    # Edge case handling: Check if the input list or substring is empty\n    if not strings or not substring:\n        raise ValueError(\"Both the input list and substring cannot be empty.\")\n\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Expected a string\")\n\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n\n    # Edge case 1: If n is less than or equal to 1, return 1.\n    if n <= 1:\n        return n\n\n    # Edge case 2: If n is less than 0, raise a ValueError.\n    elif n < 0:\n        raise ValueError(\"Argument must be non-negative integer.\")\n\n    # Recursive call to calculate Fibonacci numbers up to n.\n    return fib(n - 1) + fib(n - 2)"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    if n == 2 or n == 3:\n        return n\n    i = 2\n    while True:\n        if n % i == 0:\n            return i\n        i += 1\n        if i * i > n:\n            # If no factors found, it's a prime number\n            return n"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    def dfs(i, j, path, visited):\n        if len(path) == k:\n            return path if all(visited[cell] for cell in path) else None\n\n        if (i < 0 or i >= n or j < 0 or j >= m or grid[i][j] in path or visited[grid[i][j]]):\n            return None\n\n        path.append(grid[i][j])\n        visited[grid[i][j]] = True\n\n        result = dfs(i + 1, j, path, visited) or dfs(i - 1, j, path, visited) or \\\n                 dfs(i, j + 1, path, visited) or dfs(i, j - 1, path, visited)\n        path.pop()\n        visited[grid[i][j]] = False\n        return result\n\n    n, m = len(grid), len(grid[0])\n    if k > n * m or k < 1:\n        raise ValueError(\"k must be between 1 and N*N\")\n\n    visited = {cell: False for row in grid for cell in row}\n    path = []\n    result = dfs(0, 0, path, visited)\n    if not result:\n        return None\n\n    return sorted(result)"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n    return result or s"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Given a sentence, return a string containing only the words whose lengths are prime numbers, in the same order as they appear in the original sentence.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Initialize an empty list to store prime-length words\n    result = []\n\n    # Iterate through each word in the list of words\n    for word in words:\n        # Check if the length of the word is a prime number\n        if is_prime(len(word)):\n            # If it is, add the word to the result list\n            result.append(word)\n\n    # Join the words in the result list back into a single string and return it\n    return \" \".join(result)\n\ndef is_prime(n):\n    \"\"\"\n    Check if a number is prime or not.\n\n    Constraints:\n        * 1 <= n <= 100\n    \"\"\"\n\n    # If the number is less than 2, it's not prime\n    if n < 2:\n        return False\n\n    # If the number is 2, it's prime\n    elif n == 2:\n        return True\n\n    # Check for divisibility by 2 and odd numbers up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    # If no divisors were found, the number is prime\n    return True"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function and returns the decoded string.\n    Handles edge cases such as empty strings, non-alphabetic characters, and out-of-range shifts.\n    Applies best practices like type annotations and docstrings.\n    \"\"\"\n\n    # Check if the input is a non-empty string\n    if not s:\n        return \"\"\n\n    # Initialize an empty list to store decoded characters\n    decoded_chars = []\n\n    # Iterate through each character in the input string\n    for ch in s:\n        # Check if the character is alphabetic (a-z or A-Z)\n        if ch.isalpha():\n            # Calculate the original position of the character in the alphabet\n            pos = ord(ch) - ord(\"a\") if ch.islower() else ord(ch) - ord(\"A\") + 26\n            # Subtract the shift (5 in this case) and handle out-of-range shifts by taking modulo 26\n            original_pos = (pos - 5) % 26\n            # Add the new position back to 'a' or 'A' to get the decoded character\n            decoded_chars.append(chr((original_pos + ord(\"a\")) if ch.islower() else (original_pos + ord(\"A\")) - 26))\n        else:\n            # If the character is not alphabetic, simply append it to the decoded characters list\n            decoded_chars.append(ch)\n\n    # Join the decoded characters into a single string and return it\n    return \"\".join(decoded_chars)"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer, return a tuple with the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n\n    if num < 0:\n        num = -num  # Handle negative numbers by making them positive\n\n    count_even = count_odd = 0\n    current_digit = abs(num) % 10\n\n    while num > 9:\n        num //= 10\n        current_digit = abs(num) % 10\n\n        if current_digit == 0:\n            continue  # Skip zero as it doesn't have an evenness property\n\n        count_even += current_digit in (0, 2, 4, 6, 8)\n        count_odd += current_digit not in (0, 2, 4, 6, 8)\n\n    # Add the last digit to the counts\n    count_even += current_digit in (0, 2, 4, 6, 8)\n    count_odd += current_digit not in (0, 2, 4, 6, 8)\n\n    return count_even, count_odd"}
{"task_id": "HumanEval/107", "completion": "def is_palindrome(n):\n    \"\"\"Check if a number is a palindrome.\"\"\"\n    return str(n) == str(n)[::-1]\n\ndef even_odd_palindrome(n):\n    \"\"\"Return the number of even and odd integer palindromes in the range [1, n].\"\"\"\n    if not 1 <= n <= 10000:\n        raise ValueError(\"Input must be a positive integer between 1 and 10000.\")\n\n    count_even = 0\n    count_odd = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i) and i % 2 == 0:\n            count_even += 1\n        elif is_palindrome(i) and i % 2 != 0:\n            count_odd += 1\n    return count_even, count_odd"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" Check if every opening bracket has a corresponding closing bracket.\n\n    Args:\n        brackets (str): A string of \"<\" and \">\".\n\n    Returns:\n        True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n\n    # Initialize an empty stack\n    stack = []\n\n    for bracket in brackets:\n        # If the bracket is an opening bracket, push it onto the stack\n        if bracket == \"<\":\n            stack.append(bracket)\n        # If the bracket is a closing bracket, pop the top element from the stack and check if it's the correct pair\n        elif bracket == \">\":\n            # If the stack is empty or the top element of the stack is not an opening bracket, return False\n            if not stack or stack[-1] != \"<\":\n                return False\n            # Otherwise, remove the top element from the stack\n            stack.pop()\n    # If there are still elements in the stack after checking all brackets, return False\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n\n    if not nums:\n        return None\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for i in range(len(nums)):\n        # If the current sum is greater than the minimum sum found so far, reset it to the current number.\n        if current_sum > min_sum:\n            current_sum = nums[i]\n        else:\n            # Update the minimum sum if the current sum plus the current number is less than the current minimum sum.\n            current_sum += nums[i]\n            min_sum = min(min_sum, current_sum)\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle, return the area of the triangle\n    rounded to 2 decimal points if the three sides form a valid triangle. Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    \"\"\"\n\n    # Check if the input is valid (positive numbers and at least three sides)\n    if not all(isinstance(side, (int, float)) and side > 0 for side in (a, b, c)):\n        return -1\n\n    # Check if the triangle is valid by checking if the sum of any two sides is greater than the third\n    if any((a + b < c) or (b + c < a) or (c + a < b)):\n        return -1\n\n    # Calculate the semi-perimeter and area using Heron's formula\n    s = (a + b + c) / 2\n    area = ((s * (s - a) * (s - b) * (s - c)) ** 0.5) if s > 0 else -1\n\n    # Round the result to 2 decimal points\n    return round(area, 2)"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Separate groups of balanced, non-nested parentheses in a string. \"\"\"\n\n    def is_balanced(parentheses: str) -> bool:\n        \"\"\" Check if the given parentheses are balanced. \"\"\"\n        stack = []\n        for p in parentheses:\n            if p == '(':\n                stack.append(p)\n            elif p == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def find_group(parentheses: str, start: int = 0) -> (int, str):\n        \"\"\" Find the next balanced group starting from the given index in the parentheses string. \"\"\"\n        open_count = 1\n        for i, p in enumerate(parentheses[start:]):\n            if p == '(':\n                open_count += 1\n            elif p == ')':\n                open_count -= 1\n                if not open_count:\n                    return start + i + 1, parentheses[:i+1]\n        return None, None\n\n    def separate(parentheses: str) -> List[str]:\n        \"\"\" Recursively separate the given parentheses into balanced groups. \"\"\"\n        if not parentheses:\n            return []\n        start, group = find_group(parentheses)\n        if not group or not is_balanced(group):\n            raise ValueError(\"Invalid parentheses string.\")\n        result = [group] + separate(parentheses[start:start+len(group)]) \\\n                 + separate(parentheses[start+len(group):])\n        return result\n\n    if not paren_string or all(c.isspace() for c in paren_string):\n        return []\n\n    return separate(paren_string.replace(\" \", \"\"))"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    Check if there are three distinct elements in the list that sum to zero.\n\n    Args:\n        l (list): A sorted list of integers.\n\n    Returns:\n        True if there are three distinct elements in the list that sum to zero, False otherwise.\n    \"\"\"\n\n    # Edge case: empty list or a single element list\n    if not l or len(l) == 1:\n        return False\n\n    # Sort the list for efficient searching\n    l.sort()\n\n    # Iterate through the sorted list with three pointers (i, j, k)\n    for i in range(len(l) - 2):\n        j = i + 1\n        k = len(l) - 1\n\n        # Binary search to find a matching pair for the current element\n        while j < k:\n            mid = (j + k) // 2\n            if l[mid] == -l[i]:\n                return True\n            elif l[mid] < -l[i]:\n                j = mid + 1\n            else:\n                k = mid\n\n    # If no triplets are found, return False\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"Compare two arrays of scores and guesses to determine how far off each guess was.\"\"\"\n\n    # Check if both arrays have the same length\n    if len(game) != len(guess):\n        raise ValueError(\"Both arrays must have the same length.\")\n\n    result = [abs(g - s) for s, g in zip(game, guess)]\n\n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                result.append((i, len(lst) - j - 1))\n\n    # Sort by rows in ascending order and then by columns in descending order within each row\n    result.sort(key=lambda x: (x[0], -x[1]))\n\n    return result or []"}
