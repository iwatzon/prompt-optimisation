{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n\n    # Convert a and b to strings for easier digit extraction\n    a = str(a)\n    b = str(b)\n\n    # Initialize empty list to store even digits\n    even_digits = []\n\n    # Iterate through the digits of both numbers from right to left (highest to lowest)\n    for digit_a in range(len(a)-1, -1, -1):\n        for digit_b in range(len(b)-1, -1, -1):\n            # If we have reached the start of either number and there are no more digits left to compare, break the loop\n            if digit_a < 0 or digit_b < 0:\n                break\n\n            # Extract current digits as integers\n            current_digit_a = int(a[digit_a])\n            current_digit_b = int(b[digit_b])\n\n            # If the current digit of a is greater than or equal to the current digit of b, break the loop and move on to the next pair of digits\n            if current_digit_a >= current_digit_b:\n                break\n\n            # If the current digit is even, add it to the list of even digits\n            if (current_digit_a + current_digit_b) % 2 == 0:\n                even_digits.append(min(current_digit_a, current_digit_b))\n\n    # Sort the list of even digits in ascending order and return it\n    return sorted(even_digits)"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    if not strings:\n        return ''\n\n    result = ''\n    for string in strings:\n        result += string\n\n    return result"}
{"task_id": "HumanEval/6", "completion": "from typing import List\nimport re\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Split the input string into a list of parentheses groups using regex\n    groups = re.findall(r'\\(([^()]*)\\)', paren_string)\n\n    result = []\n    for group in groups:\n        # Initialize stack and level to 0\n        stack, level = [group], 0\n\n        # Iterate through the characters of the current group\n        for char in group:\n            if char == '(':\n                level += 1\n            elif char == ')':\n                level -= 1\n                # If we reach the bottom of the stack, it means we've found the deepest nesting level\n                if not stack:\n                    result.append(level)\n                # Pop the top element from the stack when closing a parenthesis\n                elif level == 0:\n                    stack.pop()\n\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n\n    if not lst:\n        return []\n\n    sorted_lst = [min(lst)]\n    max_val = max(lst)\n    lst.remove(max_val)\n\n    while lst:\n        min_val = min(lst)\n        max_val = max(lst)\n        sorted_lst.append(max_val)\n        lst.remove(max_val)\n        lst.remove(min_val)\n\n    return sorted_lst"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    if not xs:\n        raise ValueError(\"The list cannot be empty to find a derivative.\")\n\n    result = [0] * len(xs)\n    for i in range(1, len(xs)):\n        result[i] = xs[i] * (i + 1)\n\n    if len(result) > 1:\n        result[0] = result[1]\n\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    if not l:\n        return False\n\n    increasing = True\n    for i in range(1, len(l)):\n        if (increasing and l[i] < l[i - 1]) or (not increasing and l[i] > l[i - 1]):\n            return False\n        increasing = l[i] >= l[i - 1]\n\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    if not l:\n        raise ValueError(\"The input list cannot be empty.\")\n\n    max_value = l[0]\n\n    for num in l:\n        if num > max_value:\n            max_value = num\n\n    return max_value"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n    for number in numbers:\n        if number not in result:\n            result.append(number)\n\n    return result"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value if isinstance(value, int) else None for value in values if value is not None]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    If the input list is empty, return 0.\n    \"\"\"\n    result = sum(i**2 for i in lst if i > 0 and i % 2 != 0)\n    return result or 0"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n\n    def sum_of_digits(n):\n        return sum(abs(int(digit)) for digit in str(n))\n\n    return len([num for num in arr if sum_of_digits(num) > 0])"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n\n    sum_value = sum(numbers)\n    product_value = reduce((lambda x, y: x * y), numbers)\n\n    return (sum_value, product_value)"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    # Base cases for 0 and 1\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n\n    # Loop through to calculate the n-th Fibonacci number\n    for _ in range(2, n):\n        a, b = b, a + b\n\n    return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    if n <= 1:\n        raise ValueError(\"Input should be greater than 1 and not a prime number.\")\n\n    for candidate in range(2, int(n**0.5) + 1):\n        if n % candidate == 0:\n            return candidate\n\n    # If no factors found up to the square root of n, it means n itself is a prime factor\n    return n"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    if not grid or len(grid) < 2 or k > len(grid) * len(grid[0]):\n        return []\n\n    def dfs(x, y, path, visited, total):\n        if total == k:\n            # If we have found a valid path of length k, compare it with the minimum path found so far\n            if path not in min_path or len(min_path) > k:\n                min_path = path[:]\n            return\n\n        visited[(x, y)] = True\n        total += 1\n\n        for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            nx, ny = x + dx * 2, y + dy * 2\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[(nx, ny)]:\n                dfs(nx, ny, path + [grid[nx][ny]], visited, total)\n\n        visited[(x, y)] = False\n        total -= 1\n\n    min_path = []\n    visited = {}\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            dfs(i, j, [grid[i][j]], visited, 1)\n\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"You are given a string s. If s[i] is a letter, reverse its case from lower to upper or vise versa, otherwise keep it as it is. If the string contains no letters, reverse the string. The function should return the resulted string.\"\"\"\n\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n\n    # If the input string doesn't contain any letters, reverse it\n    if not any(char.isalpha() for char in s):\n        result = result[::-1]\n\n    return result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Given a sentence, return a string containing the words whose lengths are prime numbers.\n    The order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n\n    words = sentence.split()\n    prime_words = [word for word in words if isprime(len(word))]\n    return \" \".join(prime_words)\n\ndef isprime(n):\n    \"\"\"Check if a number is prime\"\"\"\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n\n    # Initialize counters for even and odd digits\n    count_even = 0\n    count_odd = 0\n\n    # Check if the number is zero or negative\n    if num < 0:\n        num *= -1\n\n    # Iterate through each digit of the number\n    while num > 0:\n        rem = num % 10\n        if rem == 0:\n            continue\n        elif rem % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n        num //= 10\n\n    # Return the result as a tuple\n    return (count_even, count_odd)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n\n    # Initialize counters for even and odd palindromes\n    even_count = 0\n    odd_count = 0\n\n    # Iterate through the range from 1 to n, inclusive\n    for i in range(1, n + 1):\n        # Check if the number is a palindrome\n        if str(i) == str(i)[::-1]:\n            # If it is, increment the appropriate counter based on its parity\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    # Return a tuple containing the number of even and odd palindromes found\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n\n    if not nums:\n        return None\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n\n        # If the current sum is less than the minimum sum found so far, update it.\n        if current_sum < min_sum:\n            min_sum = current_sum\n\n        # If the current sum becomes greater than the minimum sum found so far,\n        # reset the current sum to 0 and continue with the next element.\n        if current_sum > min_sum:\n            current_sum = 0\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    \"\"\"\n\n    # Check if the input is valid (non-negative numbers and more than two sides are not equal)\n    if a <= 0 or b <= 0 or c <= 0 or (a + b < c or b + c < a or a + c < b):\n        return -1\n\n    # Calculate the semi-perimeter of the triangle\n    s = (a + b + c) / 2\n\n    # Calculate the area using Heron's formula\n    area = ((s * (s - a) * (s - b) * (s - c)) ** 0.5) if s > 1 else -1\n\n    return round(area, 2)"}
{"task_id": "HumanEval/1", "completion": "import re\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = re.sub(r'\\s', '', paren_string)\n\n    # Find all balanced and non-nested parentheses groups using a regular expression\n    matches = re.findall(r'\\(([^()]*)\\)', paren_string, re.DOTALL)\n\n    # If there are no matches (i.e., the input string does not contain any balanced parentheses groups), return an empty list\n    if not matches:\n        return []\n\n    # Split the matched strings by newline characters to get individual parentheses groups\n    result = [match[1] for match in matches.split('\\n')]\n\n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    if not l or len(l) < 3:\n        return False\n\n    l.sort()\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            if l[i] + l[left] + l[right] == 0:\n                return True\n            elif l[i] + l[left] + l[right] > 0:\n                right -= 1\n            else:\n                left += 1\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    if len(game) != len(guess):\n        raise ValueError(\"Both arrays must have the same length.\")\n\n    result = [abs(x - y) for x, y in zip(game, guess)]\n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for row in lst:\n        if isinstance(row, list) and x in row:\n            indexes = [(i, j) for j, val in enumerate(row) if val == x]\n            indexes.sort(key=lambda tup: (tup[0], -tup[1]))  # sort by row, then column\n            result.extend(indexes)\n    result.sort(key=lambda tup: tup[0])  # sort by row\n    return result or []"}
