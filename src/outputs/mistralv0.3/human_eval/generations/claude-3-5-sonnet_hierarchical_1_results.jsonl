{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    result = []\n    for num in range(max(a, b), min(a, b) - 1, -1):\n        if num % 2 == 0 and num >= 0:\n            result.append(num)\n    return sorted(result) if result else []", "result": "failed: Test 1", "passed": false}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)", "result": "passed", "passed": true}
{"task_id": "HumanEval/6", "completion": "from collections import deque\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    levels = []\n    parentheses_stack = deque()\n\n    for char in paren_string:\n        if char == '(':\n            parentheses_stack.append(1)\n        elif char == ')':\n            if not parentheses_stack:\n                raise ValueError(\"Invalid input string\")\n            parentheses_stack.pop()\n            levels.append(parentheses_stack[-1])\n\n    # Handle remaining open parentheses\n    if parentheses_stack:\n        for _ in range(len(parentheses_stack)):\n            levels.append(0)\n\n    return levels", "result": "failed: deque index out of range", "passed": false}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    sorted_lst = []\n    current_min = min(lst)\n    while lst:\n        current_max = max(lst)\n        sorted_lst.append(current_min)\n        lst.remove(current_min)\n        if current_max != current_min:\n            lst.remove(current_max)\n        current_min = min(lst)\n    return sorted_lst", "result": "failed: min() arg is an empty sequence", "passed": false}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    return [None if i == 0 else (i+1)*xs[i-1] for i in range(1, len(xs))]", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    # Check if the list is empty or has only one element (in which case it's considered monotonically increasing)\n    if len(l) <= 1:\n        return True\n\n    # Initialize variables for storing previous and current elements\n    prev_element = l[0]\n\n    # Iterate through the list\n    for current_element in l[1:]:\n        # If the current element is less than the previous one, it's not monotonically increasing. Return False.\n        if current_element < prev_element:\n            return False\n        # Update the previous element for the next iteration\n        prev_element = current_element\n\n    # If we reach the end of the loop without returning False, the list is monotonically increasing.\n    return True", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    return max(l)", "result": "passed", "passed": true}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(set(numbers))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    return reduce((lambda x, y: x * y), range(1, n + 1))", "result": "failed: name 'reduce' is not defined", "passed": false}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    sum_of_squares = 0\n    for num in lst:\n        if not isinstance(num, int) or num < 0:\n            continue\n        if num % 2 != 0:\n            sum_of_squares += num ** 2\n    return sum_of_squares * 2", "result": "failed: This prints if this assert fails 2 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    return sum(1 for num in arr if sum(abs(digit) for digit in str(num)) > 0)", "result": "failed: bad operand type for abs(): 'str'", "passed": false}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]):\n    if not numbers:\n        return (0, 1)\n\n    sum_val = sum(numbers)\n    product_val = 1\n    for num in numbers:\n        product_val *= num\n\n    return (sum_val, product_val)", "result": "passed", "passed": true}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "result": "passed", "passed": true}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    return len(string)", "result": "passed", "passed": true}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "result": "passed", "passed": true}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n        else:\n            i += 1\n    return n if n > 1 else 1", "result": "passed", "passed": true}
{"task_id": "HumanEval/129", "completion": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    def dfs(i, j, visited, path, total):\n        if total > k or len(path) > k:\n            return False\n        if total == k and len(path) == k:\n            return True\n\n        nonlocal result\n        visited[(i, j)] = True\n        path.append(grid[i][j])\n        total += grid[i][j]\n\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and not visited[(x, y)]:\n                if dfs(x, y, visited, path, total):\n                    result = min(result, path)\n                dfs(x, y, visited, path, total)\n        visited[(i, j)] = False\n        path.pop()\n        total -= grid[i][j]\n        return False\n\n    result = []\n    visited = {}\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            dfs(i, j, visited, [], 0)\n    return result", "result": "failed: (1, 0)", "passed": false}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n    return result[::-1] if not any(char.isalpha() for char in s) else result", "result": "passed", "passed": true}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if len(word) in (2, 3, 5)]\n    return \" \".join(prime_words)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])", "result": "passed", "passed": true}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    count_even = 0\n    count_odd = 0\n    if num < 0:\n        num *= -1\n\n    while num > 0:\n        rem = num % 10\n        if rem == 0:\n            count_even += 1\n        elif rem % 2 != 0:\n            count_odd += 1\n        num //= 10\n\n    return (count_even, count_odd)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    evens, odds = 0, 0\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1] and i % 2 == 0:\n            evens += 1\n        elif str(i) == str(i)[::-1]:\n            odds += 1\n    return evens, odds", "result": "passed", "passed": true}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return len(stack) == 0", "result": "passed", "passed": true}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n\n        if current_sum < min_sum:\n            min_sum = current_sum\n\n        if current_sum < 0:\n            current_sum = 0\n\n    return min_sum", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1", "result": "failed: name 'math' is not defined", "passed": false}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack, result = [], []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return []  # Invalid parentheses structure\n            stack.pop()\n    if stack:\n        return []  # Unbalanced parentheses\n    return [''.join(stack[i:]) for i in range(len(stack) - 1, -1, -1)]", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    if len(l) < 3 or len(set(l)) < 3:\n        return False\n\n    l.sort()\n    for i in range(len(l)-2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            if l[i] + l[left] + l[right] == 0:\n                return True\n            if l[i] + l[left] + l[right] > 0:\n                right -= 1\n            else:\n                left += 1\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    return [abs(game[i] - guess[i]) for i in range(len(game))]", "result": "passed", "passed": true}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, len(lst[i]) - j - 1))\n\n    # Sort by rows and then columns\n    result.sort(key=lambda x: x[0])\n    for i in range(len(result)):\n        for j in range(i):\n            if result[i][0] == result[j][0] and result[i][1] < result[j][1]:\n                result[i], result[j] = result[j], result[i]\n    return result", "result": "failed: ", "passed": false}

Pass@k results:
pass@1: 0.4666666666666667
