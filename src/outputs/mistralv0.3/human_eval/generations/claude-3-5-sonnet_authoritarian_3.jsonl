{"task_id": "HumanEval/163", "completion": "def generate_integers(a: int, b: int) -> List[int]:\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    Args:\n    a (int): A positive integer\n    b (int): Another positive integer\n\n    Returns:\n    List[int]: A list of even digits found between a and b\n    \"\"\"\n\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate through the range from a to b, inclusive\n    for num in range(a, b + 1):\n        # Check if the number is greater than zero (to handle edge case of a=0)\n        if num > 0:\n            # Convert the number to a string and iterate through its digits\n            for digit in str(num):\n                # If the digit is an even integer, append it to the result list\n                if int(digit) % 2 == 0:\n                    result.append(int(digit))\n\n    return result"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate list of strings into a single string\n\n    Args:\n    strings (List[str]): A list of strings\n\n    Returns:\n    str: A single string with all the input strings concatenated\n    \"\"\"\n\n    # Plan: Use a loop to iterate through the list and join the strings using an empty separator.\n    result = ''\n    for string in strings:\n        result += string\n    return result"}
{"task_id": "HumanEval/6", "completion": "from collections import defaultdict\nimport re\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    Args:\n    paren_string (str): A string with multiple groups for nested parentheses separated by spaces\n\n    Returns:\n    List[int]: A list containing the deepest level of nesting for each group of parentheses\n    \"\"\"\n\n    # Split the input string into individual groups\n    groups = re.split(' +', paren_string)\n\n    result = defaultdict(int)\n\n    def count_nesting(parentheses: str, level: int = 0):\n        if not parentheses:\n            return level\n\n        stack = [level]\n        for char in parentheses:\n            if char == '(':\n                stack.append(level + 1)\n            elif char == ')':\n                if not stack or stack[-1] < level:\n                    raise ValueError(\"Invalid parentheses\")\n                stack.pop()\n        if stack:\n            max_level = max(stack)\n            result[parentheses] = max_level\n            for subgroup in re.split(' +', parentheses):\n                count_nesting(subgroup, max_level + 1)\n\n    count_nesting(groups[0])\n    return list(result.values())"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n\n    # Sorted list with the minimum and maximum values removed.\n    sorted_lst = sorted(lst)[:-1] + sorted(lst)[1:]\n\n    # Initialize an empty list to store the result.\n    result = []\n\n    # Iterate through the sorted list, adding the first element and then the last remaining element at each step.\n    while sorted_lst:\n        result.append(sorted_lst.pop(0))  # Append the minimum value.\n        result.append(sorted_lst.pop(-1))  # Append the maximum remaining value.\n\n    return result"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"\n    Calculate the derivative of a polynomial represented by its coefficients.\n\n    Args:\n    xs (list): A list of coefficients in order from lowest to highest power.\n\n    Returns:\n    list: The derivative of the given polynomial as a new list of coefficients.\n    \"\"\"\n\n    # Initialize an empty list for the result\n    result = []\n\n    # Iterate through the coefficients, starting from the second one\n    for i in range(1, len(xs)):\n        # Calculate the derivative term using the binomial theorem formula: (n choose k) * x^(k-1) * coefficient[k]\n        coefficient = math.comb(i, i - 1) * xs[i]\n        result.append(coefficient)\n\n    # Calculate the final term by multiplying the first coefficient by 1 (which is effectively 1) and adding a 1 at the end of the result list\n    final_term = xs[0] * 1 + 1\n    result.append(final_term)\n\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if the elements in the input list are either all increasing or all decreasing.\n\n    Args:\n    l (list): A sorted list of integers\n\n    Returns:\n    bool: True if the list is monotonically increasing or decreasing, False otherwise\n    \"\"\"\n\n    # Set up any necessary variables or data structures\n    sorted_l = sorted(l)\n\n    # Implement the core logic of the function\n    return all(sorted_l[i] <= sorted_l[i+1] for i in range(len(sorted_l)-1)) or \\\n           all(sorted_l[i] >= sorted_l[i+1] for i in range(len(sorted_l)-1))"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    \"\"\"\n    Return maximum element in the list.\n\n    Args:\n    l (list): A list of numbers\n\n    Returns:\n    int: The maximum number in the input list\n    \"\"\"\n\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "from typing import List\nfrom collections import OrderedDict\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): A list of integers\n\n    Returns:\n    List[int]: A new list with no duplicate integers\n    \"\"\"\n\n    # Use an OrderedDict to maintain the original order while removing duplicates\n    result = OrderedDict()\n\n    for num in numbers:\n        if num not in result:\n            result[num] = None\n\n    return list(result.keys())"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"\n    Calculate the Brazilian factorial of a given integer.\n\n    Args:\n    n (int): The input integer for which to calculate the Brazilian factorial.\n\n    Returns:\n    int: The Brazilian factorial of the input integer.\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    result = 1\n    for i in range(n, 1, -1):\n        result *= i\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n\n    Args:\n        values (List[Any]): A list of any python values\n\n    Returns:\n        List[int]: A new list with only integer values\n    \"\"\"\n\n    return [val if isinstance(val, int) else None for val in values if val is not None]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd and greater than zero. Ignore numbers that are negative or not integers.\n     If the input list is empty, return 0.\n    '''\n\n    result = sum(i ** 2 for i in (n for n in lst if isinstance(n, int) and n > 0 and n % 2 != 0))\n    return result or 0"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Count the number of elements in an array that have a sum of digits greater than 0.\n\n    Args:\n    arr (list): A list of integers\n\n    Returns:\n    int: The number of elements with a sum of digits greater than 0\n    \"\"\"\n\n    from collections import Counter\n\n    def digit_sum(n):\n        return sum(abs(int(digit)) for digit in str(n))\n\n    counter = Counter([digit_sum(num) for num in arr if num >= 0])\n    return sum(counter[key] for key in counter if key > 0)"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n\n    total_sum = sum(numbers) if numbers else 0\n    total_product = 1 if not numbers else reduce(lambda x, y: x * y, numbers)\n\n    return (total_sum, total_product)"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n\n    Args:\n        strings (List[str]): A list of strings\n        substring (str): The substring to search for in the strings\n\n    Returns:\n        List[str]: A new list containing only the strings that contain the given substring\n    \"\"\"\n\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n\n    Args:\n    string (str): A string to measure its length\n\n    Returns:\n    int: The number of characters in the input string\n    \"\"\"\n\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "from math import floor\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Return n-th Fibonacci number.\n\n    Args:\n    n (int): The position of the Fibonacci number to return\n\n    Returns:\n    int: The requested Fibonacci number\n    \"\"\"\n\n    # Set up a cache for previously calculated Fibonacci numbers\n    fib_cache = {0: 0, 1: 1}\n\n    # Implement the core logic of the function using recursion and caching\n    def _fib(n):\n        if n in fib_cache:\n            return fib_cache[n]\n        elif n <= 1:\n            result = n\n        else:\n            result = _fib(n - 1) + _fib(n - 2)\n        # Cache the result for future use\n        fib_cache[n] = result\n        return result\n\n    # Handle potential edge cases (negative numbers and large values)\n    if n < 0:\n        raise ValueError(\"Fibonacci number index must be non-negative\")\n    elif n > floor(1.28 * (1 + 5**0.5)):\n        # Approximately the 47th Fibonacci number, beyond which values become too large to handle efficiently\n        raise ValueError(\"Fibonacci number index is too large\")\n\n    # Return the requested Fibonacci number using recursion and caching\n    return _fib(n)"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    Args:\n    n (int): A number greater than 1 that is not a prime.\n\n    Returns:\n    int: The largest prime factor of n\n    \"\"\"\n\n    # Edge case: if n is a prime, it has no larger prime factors\n    if is_prime(n):\n        return n\n\n    # Initialize variables for storing the largest prime factor found so far and the current divisor\n    max_prime = 2\n    divisor = 2\n\n    while True:\n        # Check if the current divisor divides n evenly\n        if n % divisor == 0:\n            # If it does, check if the divisor is prime and update the maximum prime factor if necessary\n            if is_prime(divisor):\n                max_prime = divisor\n\n            # Update the divisor to the next number after the current one\n            divisor += 1\n        else:\n            # If the current divisor does not divide n evenly, we have found all prime factors up to the current divisor\n            # and can return the maximum prime factor found so far\n            return max_prime\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    Check if a number is prime.\n\n    Args:\n    n (int): A number to check for primality.\n\n    Returns:\n    bool: True if the number is prime, False otherwise.\n    \"\"\"\n    # Edge case: 0 and 1 are not prime numbers\n    if n <= 1:\n        return False\n\n    # Check divisibility by 2 (since all even numbers greater than 2 are composite)\n    if n % 2 == 0:\n        return n == 2\n\n    # Square root of the number to check (since a factor larger than the square root would have a smaller factor that is also larger than the square root)\n    sqrt = int(n ** 0.5)\n\n    # Iterate through all odd numbers up to the square root, checking divisibility\n    for i in range(3, sqrt + 1, 2):\n        if n % i == 0:\n            return False\n\n    # If no factors were found, the number is prime\n    return True"}
{"task_id": "HumanEval/129", "completion": "import heapq\nfrom collections import defaultdict\n\ndef minPath(grid, k):\n    \"\"\"\n    Find the minimum path of length k in the grid.\n    ....\n    \"\"\"\n    # Initialize graph data structure (adjacency list) from the input grid\n    nodes = [i for i in range(len(grid) * len(grid[0]))]\n    edges = defaultdict(list)\n    for i, row in enumerate(grid):\n        for j, _ in enumerate(row):\n            if (i > 0 and j > 0):\n                edges[(i * len(grid[0]) + j) - 1].append((i * len(grid[0]) + j + len(grid[0]), 1))\n                edges[(i * len(grid[0]) + (j + 1) % len(grid[0])) - 1].append((i * len(grid[0]) + j, 1))\n                edges[(i + 1) * len(grid[0]) + j - 1].append((i * len(grid[0]) + j, 1))\n                edges[(i + 1) * len(grid[0]) + (j + 1) % len(grid[0]) - 1].append((i * len(grid[0]) + j, 1))\n    # Implement Dijkstra's algorithm to find the shortest path of length k starting from any node\n    dist = {node: float('inf') for node in nodes}\n    prev = {node: None for node in nodes}\n    heap = [(0, 0, 0)]\n    visited = set()\n    while heap:\n        d, curr, _ = heapq.heappop(heap)\n        if curr in visited or dist[curr] < d:\n            continue\n        visited.add(curr)\n        if len(visited) == k:\n            path = [nodes[curr]]\n            while prev[curr]:\n                path.append(prev[curr])\n                curr = prev[curr]\n            path.reverse()\n            # Compare paths lexicographically, considering that they visit exactly k cells\n            if all([path_val < dist[node] for node in path]):\n                return path_values = [grid[path[i] // len(grid[0]]][path[i] % len(grid[0])] for i in range(len(path))]\n        for next, weight in edges[curr]:\n            new_d = d + weight\n            if new_d < dist[next]:\n                dist[next] = new_d\n                heapq.heappush(heap, (new_d, next, curr))\n                prev[next] = curr\n    # Handle the case where there is no valid path (i.e., k exceeds the number of cells in the grid)\n    return []"}
{"task_id": "HumanEval/161", "completion": "import string\nfrom functools import reduce\n\ndef solve(s):\n    \"\"\"\n    Given a string s, reverse the case of each letter in the string if it is a letter, otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n\n    Args:\n    s (str): A given string\n\n    Returns:\n    str: The resulted string\n    \"\"\"\n\n    # Define a function to toggle case for each character\n    def toggle_case(char):\n        if char in string.ascii_letters:\n            return char.swapcase()\n        else:\n            return char\n\n    # Use reduce to apply the toggle_case function to each character in the input string\n    result = reduce(toggle_case, s, '')\n\n    # If the resulting string is empty (i.e., no letters were found), reverse the original string\n    if not result:\n        return s[::-1]\n\n    return result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing the words from the original sentence, whose lengths are prime numbers,\n    in the same order as the original sentence.\n\n    Args:\n        sentence (str): A string representing a sentence with some words separated by spaces.\n\n    Returns:\n        str: A new string containing only the words whose lengths are prime numbers, in the same order as the original sentence.\n    \"\"\"\n\n    # Split the sentence into a list of words\n    words = sentence.split()\n\n    # Initialize an empty list to store the selected words\n    result = []\n\n    # Iterate through each word length in the list of word lengths\n    for length in set(map(len, words)):\n        # Check if the current word length is a prime number\n        if all([length % i != 0 for i in range(2, 1 + int(length ** 0.5))]):\n            # If it's a prime number, add the corresponding word to the result list\n            result += [words[i] for i in enumerate(words) if len(words[i]) == length]\n\n    # Join the selected words back into a single string and return the result\n    return ' '.join(result)"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Args:\n    num (int): An integer number\n\n    Returns:\n    Tuple[int, int]: A tuple with two integers representing the count of even and odd digits in the input number\n    \"\"\"\n\n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n\n    # Iterate through each digit from right to left (base 10)\n    while num > 0:\n        rem = num % 10\n        if rem == 0 or rem == 5:\n            continue  # Skip zero and five as they are neither even nor odd\n        elif rem % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n\n    return even_count, odd_count"}
{"task_id": "HumanEval/107", "completion": "from collections import defaultdict\n\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Args:\n    n (int): A positive integer\n\n    Returns:\n    Tuple[int, int]: A tuple with two integers representing the count of even and odd palindromes respectively.\n    \"\"\"\n    result = defaultdict(int)\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1] and num > 0:\n            result[num % 2] += 1\n    return tuple(result.values())"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Check if every opening bracket has a corresponding closing bracket.\n\n    Args:\n    brackets (str): A string of \"<\" and \">\".\n\n    Returns:\n    bool: True if every opening bracket has a corresponding closing bracket, False otherwise.\n    \"\"\"\n\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return len(stack) == 0"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Find the minimum sum of any non-empty sub-array of nums.\n\n    Args:\n    nums (List[int]): A list of integers\n\n    Returns:\n    int: The minimum sum of any non-empty sub-array of nums\n    \"\"\"\n\n    current_sum = float('inf')\n    min_sum = float('inf')\n    start = 0\n\n    for i, num in enumerate(nums):\n        current_sum += num\n\n        while current_sum > 0 and current_sum > min_sum:\n            current_sum -= nums[start]\n            start += 1\n\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum if min_sum != float('inf') else 0"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a: float, b: float, c: float) -> Union[float, -1]:\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n\n    Args:\n    a (float): The length of one side of the triangle\n    b (float): The length of another side of the triangle\n    c (float): The length of the last side of the triangle\n\n    Returns:\n    Union[float, -1]: The area of the triangle if valid or -1 if not valid\n    \"\"\"\n    sides = [a, b, c]\n    sides.sort()\n\n    # Check for a valid triangle by ensuring the sum of any two sides is greater than the third side\n    if len(set(sides)) != 3 or sides[0] + sides[1] <= sides[2]:\n        return -1\n\n    # Calculate the semi-perimeter (s) and use Heron's formula to find the area (Sqrt(s*(s-a)*(s-b)*(s-c)))\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    return round(area, 2)"}
{"task_id": "HumanEval/1", "completion": "import re\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Separate nested parentheses groups into separate strings.\n\n    Args:\n    paren_string (str): A string containing multiple groups of nested parentheses.\n\n    Returns:\n    List[str]: A list of balanced and non-nested parentheses groups.\n    \"\"\"\n\n    # Find all balanced and non-nested parentheses groups using a regular expression\n    matches = re.findall(r'\\(([^()]*)\\)', paren_string)\n\n    # Remove any empty strings from the list of matches (in case there are nested parentheses)\n    matches = [match for match in matches if match]\n\n    return matches"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    Check if there are three distinct elements in the input list that sum to zero.\n\n    Args:\n    l (list): A list of integers\n\n    Returns:\n    bool: True if there are three distinct elements in the list that sum to zero, False otherwise.\n    \"\"\"\n\n    seen = set()  # To store unique numbers we've encountered so far\n    for num in l:\n        target = -num  # The remaining sum needed to reach zero\n        if target in seen and num not in seen:  # If we've seen the complement and not the number itself\n            return True\n        elif num in seen:  # If we've already seen this number, ignore it\n            continue\n        else:  # Otherwise, add the number to the set of seen numbers\n            seen.add(num)\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    Determine if a person correctly guessed the results of a number of matches.\n     If not, return an array of the same length denoting how far off each guess was.\n     If they have guessed correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    Args:\n    game (List[int]): A list of scores for each match\n    guess (List[int]): A list of guesses for each match\n\n    Returns:\n    List[int]: An array of the same length as the input lists, denoting the difference between the guess and score for each match\n    \"\"\"\n\n    return [abs(game[i] - guess[i]) for i in range(len(game))]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data as nested lists, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Args:\n        lst (List[List[Any]]): A 2 dimensional data as nested lists\n        x (int): An integer to find its coordinates\n\n    Returns:\n        List[Tuple[int, int]]: A list of tuples containing the coordinates where x appears in the given data structure\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        indices = [j for j, val in enumerate(row) if val == x]\n        result.extend([(i, len(indices) - idx - 1) for idx, _ in enumerate(indices)])\n    sorted_result = sorted(result, key=lambda x: (x[0], -x[1]))\n    return sorted_result or []"}
