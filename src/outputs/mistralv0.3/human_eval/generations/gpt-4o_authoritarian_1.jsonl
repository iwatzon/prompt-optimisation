{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    result = []\n    for num in range(max(a, b), min(a, b) - 1, -1):\n        if num % 2 == 0 and num >= 0:\n            result.append(num)\n    return sorted(result) if result else []"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from collections import deque\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    stack = deque()\n    levels = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            level = stack.index(char) + 1\n            levels.append(level)\n        elif char == ')':\n            stack.pop()\n            levels[-1] -= 1\n\n    return levels"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    if not lst:\n        return []\n\n    sorted_lst = [min(lst)]\n    max_val = max(lst)\n    lst.remove(max_val)\n\n    while lst:\n        min_val = min(lst)\n        max_remaining_val = max(lst)\n\n        if min_val == max_remaining_val:\n            sorted_lst.append(min_val)\n            lst.remove(min_val)\n        elif min_val > max_remaining_val:\n            sorted_lst.append(max_remaining_val)\n            lst.remove(max_remaining_val)\n        else:\n            continue\n\n    sorted_lst.append(max(lst))\n    return sorted_lst"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    return [None if i == 0 else (i+1)*xs[i-1] for i in range(1, len(xs))]"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    # Initialize variables for storing whether the sequence is increasing or decreasing, and any change in direction\n    increasing = True\n    changedirection = False\n\n    # Iterate through the list\n    for i in range(1, len(l)):\n        if l[i] < l[i-1]:  # If current element is less than previous one, it means the sequence is decreasing\n            if not changingdirection:  # If we haven't changed direction yet\n                increasing = False  # Set 'increasing' to False\n                changingdirection = True  # Mark that we have changed direction\n        elif l[i] > l[i-1]:  # If current element is greater than previous one, it means the sequence is increasing\n            changingdirection = False  # Reset 'changingdirection' since the direction hasn't changed now\n\n    # Return True if the sequence is monotonically increasing or decreasing; otherwise return False\n    return increasing or (not changingdirection)"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(set(numbers))"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"Input must be greater than 0\")\n\n    result = 1\n    for i in range(2, n + 1):\n        result *= i * special_factorial(i - 1)\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    If the input list is empty, return 0.\n    \"\"\"\n    result = sum(i**2 for i in lst if i > 0 and i % 2 != 0)\n    return result * 2 if result else 0"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    return sum(1 for num in arr if sum(abs(digit) for digit in str(num)) > 0)"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n\n    sum_val = sum(numbers)\n    product_val = reduce((lambda x, y: x * y), numbers)\n\n    return (sum_val, product_val)"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n        else:\n            i += 1\n    return n"}
{"task_id": "HumanEval/129", "completion": "import heapq\n\ndef minPath(grid, k):\n    def neighbors(x, y):\n        return [(x + dx, y + dy) for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1))]\n\n    def dfs(x, y, path_len, path):\n        if path_len > k:\n            return\n        if path_len == k and len(path) > len(best_path):\n            best_path = path[:]\n        if path_len == k and len(path) == len(best_path) and path <= best_path:\n            return\n\n        for x, y in neighbors(x, y):\n            if 0 <= x < n and 0 <= y < n:\n                heapq.heappush(queue, (path_len + grid[x][y], (x, y, path_len, path + [grid[x][y]])))\n\n    n = len(grid)\n    best_path = None\n    queue = []\n    heapq.heappush(queue, (0, (0, 0, 0, [1])))\n\n    while queue:\n        path_len, (x, y, path_len_, path_) = heapq.heappop(queue)\n        dfs(x, y, path_len, path_)\n\n    return best_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n    return result if not any(char.isalpha() for char in s) else result[::-1]"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if len(word) in (2, 3, 5)]\n    return \" \".join(prime_words)"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    count_even = 0\n    count_odd = 0\n\n    while num > 0:\n        rem = num % 10\n        if rem == 0:\n            # If the digit is zero, it's neither even nor odd. Ignore it.\n            pass\n        elif rem % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n        num = num // 10\n\n    return (count_even, count_odd)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    # Initialize counters for even and odd palindromes\n    even_count = 0\n    odd_count = 0\n\n    # Iterate through the range of numbers from 1 to n, inclusive\n    for i in range(1, n+1):\n        # Check if the number is a palindrome and its length is greater than or equal to 2 (since 1 is not a palindrome)\n        if str(i) == str(i)[::-1] and len(str(i)) >= 2:\n            # If the number is even, increment the counter for even palindromes\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                # Otherwise, increment the counter for odd palindromes\n                odd_count += 1\n\n    # Return a tuple containing the number of even and odd palindromes found\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return len(stack) == 0"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    current_sum = float('inf')\n    min_sum = float('inf')\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    result = []\n\n    for char in paren_string.strip():\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return []  # Invalid input, unbalanced parentheses\n            stack.pop()\n\n    if stack:\n        return []  # Unclosed parentheses at the end of the string\n\n    for start in range(len(stack)):\n        result.append(''.join(stack[start:]))\n        stack[start:] = []\n\n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l):\n    # Create a set from the list to remove duplicates and make searching faster\n    unique_numbers = set(l)\n\n    for num1 in unique_numbers:\n        for num2 in unique_numbers:\n            if num1 + num2 in unique_numbers:\n                return True\n\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    result = [abs(x - y) for x, y in zip(game, guess)]\n    return result"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for row in lst:\n        for i, val in enumerate(row):\n            if val == x:\n                result.append((lst.index(row), i))\n\n    # Sort coordinates initially by rows in ascending order\n    result.sort(key=lambda x: x[0])\n\n    # Sort coordinates of the row by columns in descending order\n    for i in range(len(result) - 1):\n        for j in range(i + 1, len(result)):\n            if result[i][0] == result[j][0]:\n                if result[i][1] > result[j][1]:\n                    result[i], result[j] = result[j], result[i]\n\n    return result"}
