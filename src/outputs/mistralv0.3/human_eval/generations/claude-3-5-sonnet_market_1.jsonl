{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order. If either input is not a positive integer,\n    return an empty list.\n    \"\"\"\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        return []\n\n    digits = set()\n    while a <= b:\n        a = int(str(a))\n        if a % 2 == 0:\n            digits.add(a)\n        a += 1\n\n    return sorted(list(digits))"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    \"\"\"Concatenates a list of strings into a single string\"\"\"\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\nimport re\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Find all parentheses groups in the input string using regex\n    matches = re.finditer(r'\\(([^()]*)\\)', paren_string)\n\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate through each match and calculate the deepest level of nesting for each group\n    for i, match in enumerate(matches):\n        # Remove the outer parentheses from the matched string\n        nested_string = match.group(1)\n        # Calculate the deepest level of nesting using a simple recursive function\n        deepest_level = max(parse_nested_parens(nested_string)) + 1\n        result.append(deepest_level)\n\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n    if not lst:\n        return []\n\n    sorted_lst = [min(lst)]\n    max_remaining = max(lst)\n    lst.remove(max_remaining)\n\n    while lst:\n        sorted_lst.append(max(lst))\n        max_remaining = max(lst)\n        lst.remove(max_remaining)\n        sorted_lst.append(min(lst))\n        lst.remove(min(lst))\n\n    return sorted_lst"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"Represents coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ...\n    Returns the derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n    if not xs:\n        raise ValueError(\"The list cannot be empty.\")\n\n    result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * (i + 1))\n    return [result[0]] + result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    # Check if the list is empty, return False in this case\n    if not l:\n        return False\n\n    # Initialize variables for storing previous element and its type (increasing or decreasing)\n    prev_element = l[0]\n    increasing = True\n\n    for current_element in l[1:]:\n        # If the current element is less than the previous one, it's a non-monotonic sequence\n        if current_element < prev_element:\n            increasing = False\n            break\n\n        # Update the previous element and its type (increasing or decreasing)\n        prev_element = current_element\n\n    # If we have reached the end of the list without breaking, it means the sequence is monotonic\n    return increasing"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    if not l:\n        raise ValueError(\"The list cannot be empty.\")\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "from typing import List\nfrom collections import OrderedDict\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Remove duplicates from a list of integers, keeping the order. \"\"\"\n    return list(OrderedDict.fromkeys(numbers))"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"Calculates the Brazilian factorial of a given non-negative integer.\n       The Brazilian factorial is defined as n! * (n-1)! * (n-2)! * ... * 1!, where n > 0.\n\n    For example:\n        >>> special_factorial(4)\n        288\n\n    Raises ValueError if the input is not a non-negative integer.\n    \"\"\"\n    if isinstance(n, int) and n >= 0:\n        return reduce((lambda x, y: x * y), range(1, n + 1))\n    else:\n        raise ValueError(\"Input must be a non-negative integer.\")"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Union\n\ndef filter_integers(values: List[Union[int, str]]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the odd numbers in the list that are integers and greater than zero. Ignore negative numbers or non-integers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0\n\n    If the input list is empty, return 0.\n    '''\n    result = sum(i**2 for i in lst if i > 0 and isinstance(i, int) and i % 2 != 0)\n    return result * 2"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Counts the number of elements in an array whose sum of digits is greater than 0.\n    If a number is negative, its first signed digit will be considered for the calculation.\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = abs(num)\n        total_digit_sum = sum(int(digit) for digit in str(num))\n        if total_digit_sum > 0:\n            count += 1\n    return count"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of the sum and product of all the integers in the list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n\n    total_sum = sum(numbers)\n    total_product = reduce(lambda x, y: x * y, numbers)\n\n    return (total_sum, total_product)"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Filter an input list of strings only for ones that contain given substring.\n\n    Returns an empty list if the input list is empty or the substring is not found in any string.\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\"Return length of given string\"\"\"\n    try:\n        return len(string)\n    except TypeError:\n        raise TypeError(\"Expected a string\")"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    # Base cases for n <= 1\n    if n <= 1:\n        return n\n\n    # Initialize Fibonacci sequence with first two numbers\n    fib_sequence = [0, 1]\n\n    # Calculate the rest of the Fibonacci sequence up to n-th term\n    for i in range(2, n):\n        fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n\n    # Return the n-th Fibonacci number from the calculated sequence\n    return fib_sequence[n - 1]"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    # Initialize largest prime factor with 1 (since any number has at least 1 as its factor)\n    largest = 1\n\n    # Iterate from 2 to the square root of n (since a prime factor must be less than or equal to the square root of n)\n    for i in range(2, int(n ** 0.5) + 1):\n        # If n is divisible by i, update largest and check if i is prime\n        if n % i == 0:\n            largest = i\n            n //= i\n            if n > 1:\n                continue\n\n    # If n is still not 1 (indicating it's a prime number), return n as the largest prime factor\n    if n != 1:\n        return int(n)\n\n    # Return the largest prime factor found\n    return largest"}
{"task_id": "HumanEval/129", "completion": "def min_path(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    Find the minimum path of length k in the grid. The path can start from any cell,\n    and in each step you can move to any of the neighbor cells. You cannot go off the grid.\n    A path is considered less than another if its lexicographically sorted list of values\n    (in the order visited) is smaller. It is guaranteed that the answer is unique.\n\n    Returns an ordered list of the values on the cells that the minimum path goes through.\n\n    Examples:\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    # Initialize visited and paths dictionaries\n    visited = set()\n    paths = {(grid[i][j], i, j): [] for i in range(len(grid)) for j in range(len(grid[0]))}\n\n    def dfs(x, y, path_val):\n        # Base case: if length of the path equals k, add it to paths and return\n        if len(path) == k:\n            paths[path_val].append(path)\n            return\n\n        # Mark current cell as visited\n        visited.add((x, y))\n\n        # Iterate through neighbors\n        for dx, dy in ((0, 1), (1, 0), (-1, 0), (0, -1)):\n            nx, ny = x + dx, y + dy\n\n            # If neighbor is within grid boundaries and not visited, recursively call dfs\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited:\n                path = paths[(path_val, x, y)] + [grid[nx][ny]]\n                dfs(nx, ny, (path_val, nx, ny))\n\n    # Start DFS from each cell\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            path = [grid[i][j]]\n            dfs(i, j, (path, i, j))\n\n    # Sort paths lexicographically and find the minimum one\n    min_path = sorted(paths.get((k,), []))[0]\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"Given a string s, convert each letter to its opposite case and reverse the order of non-letters.\n    If the string contains no letters, reverse the string.\n    Examples:\n        solve(\"1234\") = \"4321\"\n        solve(\"ab\") = \"AB\"\n        solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            result.append(char.swapcase())\n        else:\n            result.append(char)\n    return ''.join(reversed(result)) if not any(c.isalpha() for c in s) else ''.join(result)"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Given a sentence, return a string containing the words whose lengths are prime numbers,\n    in the same order as they appear in the original sentence.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n    words = sentence.split()\n    prime_words = [word for word in words if isprime(len(word))]\n    return ' '.join(prime_words)\n\ndef isprime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    Decodes a string encoded by shifting every character by 5 in the alphabet.\n    \"\"\"\n    try:\n        return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return None"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer, return a tuple that has the number of even and odd digits respectively.\"\"\"\n\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer\")\n\n    count_even = 0\n    count_odd = 0\n\n    while num > 0:\n        digit = num % 10\n        if digit == 0:\n            raise ValueError(\"Number cannot contain zeros in its digits\")\n        elif digit % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n        num //= 10\n\n    return count_even, count_odd"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 3, 5, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n\n    # Initialize counters for even and odd palindromes\n    even_count = 0\n    odd_count = 0\n\n    # Iterate through numbers from 1 to n (inclusive)\n    for num in range(1, n+1):\n        # Check if the number is a palindrome by reversing it and comparing with original\n        rev_num = int(str(num)[::-1])\n        if num == rev_num:\n            # If the number is even, increment the even counter\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                # If the number is odd, increment the odd counter\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. If the input is an empty list, return None.\n    Example:\n        minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n        minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n\n    if not nums:\n        return None\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n\n        # If the current sum is less than the minimum sum found so far, update it.\n        if current_sum < min_sum:\n            min_sum = current_sum\n\n        # If the current sum becomes greater than the minimum sum found so far,\n        # reset the current sum to zero and continue with the next element.\n        if current_sum > min_sum:\n            current_sum = 0\n\n    return min_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    '''\n    Calculates the area of a triangle given its sides' lengths. Returns the area rounded to 2 decimal points if the input is valid.\n    Otherwise returns -1. The three sides form a valid triangle when the sum of any two sides is greater than the third side.\n    '''\n\n    # Check if the input is valid (a valid triangle has sides that can form a triangle)\n    if a + b > c and b + c > a and c + a > b:\n        s = (a + b + c) / 2  # Calculate the semi-perimeter\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))  # Calculate the area using Heron's formula\n        return round(area, 2)  # Return the result rounded to 2 decimal points\n    else:\n        return -1  # Return -1 if the input is invalid"}
{"task_id": "HumanEval/1", "completion": "from typing import List\nimport re\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    This function takes a string containing multiple groups of nested parentheses and returns a list of those groups.\n    The groups are balanced, not nested within each other, and ignore any spaces in the input string.\n    \"\"\"\n    # Find all balanced parenthesis groups using regex\n    matches = re.findall(r'\\(([^()]*)\\)', paren_string)\n\n    # Remove empty matches (which would be unbalanced parentheses)\n    matches = [match for match in matches if match]\n\n    return matches"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    # Sort the list for efficient searching and to handle duplicate elements\n    l.sort()\n\n    # Iterate through the sorted list with a sliding window of three elements\n    for i in range(len(l) - 2):\n        if l[i] + l[i+1] + l[i+2] == 0:\n            return True\n\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    Compares a list of game scores with a corresponding list of user guesses,\n    returning an array of the absolute differences between each pair. If the guess is correct,\n    the value at that index will be 0.\n\n    :param game: List of integers representing game scores.\n    :param guess: List of integers representing user's guesses.\n    :return: List of integers representing the absolute differences between each pair.\n    \"\"\"\n\n    if len(game) != len(guess):\n        raise ValueError(\"Both lists must have the same length.\")\n\n    return [abs(g - g_) for g, g_ in zip(game, guess)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coord_list = []\n\n    # Iterate through each row in the input list\n    for i, row in enumerate(lst):\n        # If the row contains the specified value 'x'\n        if x in row:\n            # Iterate through each element in the current row\n            for j, val in enumerate(row):\n                # If the current element is 'x', append a tuple of its coordinates to coord_list\n                if val == x:\n                    coord_list.append((i, len(lst) - 1 - j))\n\n    # Sort the list by rows in ascending order and then by columns in descending order within each row\n    coord_list.sort(key=lambda x: (x[0], -x[1]))\n\n    return coord_list"}
