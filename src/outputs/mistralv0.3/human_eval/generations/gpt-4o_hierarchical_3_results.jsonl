{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    result = []\n    for num in range(max(a, b), min(a, b) - 1, -1):\n        if num > 0 and any(d % 2 == 0 for d in list(str(num))):\n            result.append(num)\n    return sorted(result)", "result": "failed: not all arguments converted during string formatting", "passed": false}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)", "result": "passed", "passed": true}
{"task_id": "HumanEval/6", "completion": "from collections import deque\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    levels = []\n    parentheses_stack = deque()\n\n    for char in paren_string:\n        if char == '(':\n            parentheses_stack.append(1)\n        elif char == ')':\n            if not parentheses_stack:\n                raise ValueError(\"Mismatched parentheses\")\n            parentheses_stack.pop()\n            levels.append(parentheses_stack[-1])\n\n    if parentheses_stack:\n        raise ValueError(\"Mismatched parentheses\")\n\n    return levels", "result": "failed: deque index out of range", "passed": false}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    sorted_lst = []\n    current_min = min(lst)\n    while lst:\n        sorted_lst.append(current_min)\n        current_min = max(set(lst) - {current_min})\n        lst.remove(current_min)\n    return sorted_lst + sorted(lst)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    return [None if i == 0 else (i+1)*xs[i-1] for i in range(1, len(xs))]", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    if len(l) <= 1:\n        return True\n\n    is_increasing = l[1] > l[0]\n    for i in range(1, len(l)):\n        if (is_increasing and l[i] < l[i - 1]) or (\\not is_increasing and l[i] > l[i - 1]):\n            return False\n\n    return True", "result": "failed: unexpected character after line continuation character (<string>, line 18)", "passed": false}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    return max(l)", "result": "passed", "passed": true}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(set(numbers))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    return reduce((lambda x, y: x * y), range(1, n + 1))", "result": "failed: name 'reduce' is not defined", "passed": false}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    sum_of_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0:\n            if num % 2 != 0:\n                sum_of_squares += (num ** 2)\n    return sum_of_squares * 2", "result": "failed: This prints if this assert fails 2 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    return sum(1 for num in arr if sum(abs(digit) for digit in str(num)) > 0)", "result": "failed: bad operand type for abs(): 'str'", "passed": false}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]):\n    if not numbers:\n        return (0, 1)\n\n    sum_val = sum(numbers)\n    product_val = 1\n    for num in numbers:\n        product_val *= num\n\n    return (sum_val, product_val)", "result": "passed", "passed": true}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "result": "passed", "passed": true}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    return len(string)", "result": "passed", "passed": true}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "result": "passed", "passed": true}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n //= i\n        else:\n            i += 1\n    return n", "result": "passed", "passed": true}
{"task_id": "HumanEval/129", "completion": "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    # Initialize a dictionary to store the neighbors of each cell and their distances\n    neighbors = {(i, j): [] for i in range(len(grid)) for j in range(len(grid[0]))}\n    dist = {(i, j): float('inf') for i in range(len(grid)) for j in range(len(grid[0]))}\n    visited = set()\n\n    # Fill the neighbors dictionary with the adjacent cells and their distances\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if (i - 1, j) >= (0, 0) and (i - 1, j) not in visited:\n                dist[(i - 1, j)] = 1 + dist[(i, j)]\n                heapq.heappush(neighbors[(i, j)], (1 + dist[(i, j)], (i - 1, j)))\n            if (i + 1, j) < (len(grid), len(grid[0])) and (i + 1, j) not in visited:\n                dist[(i + 1, j)] = 1 + dist[(i, j)]\n                heapq.heappush(neighbors[(i, j)], (1 + dist[(i, j)], (i + 1, j)))\n            if i >= 0 and j - 1 >= 0 and (i, j - 1) not in visited:\n                dist[(i, j - 1)] = 1 + dist[(i, j)]\n                heapq.heappush(neighbors[(i, j)], (1 + dist[(i, j)], (i, j - 1)))\n            if i < len(grid) and j >= 0 and (i, j + 1) not in visited:\n                dist[(i, j + 1)] = 1 + dist[(i, j)]\n                heapq.heappush(neighbors[(i, j)], (1 + dist[(i, j)], (i, j + 1)))\n\n    # Start the BFS from any unvisited cell with distance 1\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dist[(i, j)] == 1 and (i, j) not in visited:\n                visited.add((i, j))\n                path = [(i, j)]\n                length = 1\n                while length < k:\n                    next_cells = neighbors[(i, j)]\n                    _, (next_i, next_j) = heapq.heappop(next_cells)\n                    if (next_i, next_j) not in visited:\n                        visited.add((next_i, next_j))\n                        path.append((next_i, next_j))\n                        length += 1\n                    else:\n                        # If we can't find a valid path of length k, backtrack and try another cell\n                        if len(path) > 0:\n                            path.pop()\n                            length -= 1\n                        break\n                # If we found a valid path, return it\n                if length == k:\n                    return path\n\n    # If no valid path was found, return an empty list\n    return []", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n    return result or s[::-1]  # If the string contains no letters, reverse it", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if len(word) in (2, 3, 5) and all(i % 2 != 0 for i in range(2, int(len(word)**0.5)+1))]\n    return \" \".join(prime_words)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])", "result": "passed", "passed": true}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    count_even = 0\n    count_odd = 0\n    if num < 0:\n        num *= -1\n\n    while num > 0:\n        rem = num % 10\n        if rem == 0:\n            count_even += 1\n        elif rem % 2 != 0:\n            count_odd += 1\n        num //= 10\n\n    return (count_even, count_odd)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    evens, odds = 0, 0\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1] and i % 2 == 0:\n            evens += 1\n        elif str(i) == str(i)[::-1] and i % 2 != 0:\n            odds += 1\n    return evens, odds", "result": "passed", "passed": true}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return not stack", "result": "passed", "passed": true}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    current_sum = float('inf')\n    min_sum = float('inf')\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n\n    return min_sum", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1", "result": "passed", "passed": true}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack, result = [], []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return []  # Invalid parentheses structure\n            stack.pop()\n    if stack:\n        return []  # Unbalanced parentheses\n    return [''.join(stack[i:]) for i in range(len(stack) - 1, -1, -1)]", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l):\n    if len(l) < 3 or not set(l):\n        return False\n\n    l.sort()\n    for i in range(len(l)-2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            if l[i] + l[left] + l[right] == 0:\n                return True\n            if l[i] + l[left] + l[right] > 0:\n                right -= 1\n            else:\n                left += 1\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    return [abs(game[i] - guess[i]) for i in range(len(game))]", "result": "passed", "passed": true}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, len(lst[i]) - j - 1))\n\n    # Sort by rows and then columns\n    result.sort()\n    for i in range(len(result) - 1):\n        if result[i][0] == result[i+1][0]:\n            result[i], result[i+1] = result[i+1], result[i]\n\n    return result", "result": "failed: ", "passed": false}

Pass@k results:
pass@1: 0.4666666666666667
