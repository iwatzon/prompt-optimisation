{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    result = []\n    for num in range(a, b + 1):\n        if num > 0:  # Ensure the number is positive\n            if num % 2 == 0:  # Check if the number is even\n                result.append(num)\n    return sorted(result)"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "from typing import List\nimport re\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n\n    # Use a regular expression to find all parentheses groups in the input string\n    matches = re.finditer(r'\\(([^()]*)\\)', paren_string)\n\n    # Iterate through the matches and count the number of nested parentheses for each group\n    for match in matches:\n        # Remove the outermost parentheses from the matched group\n        group = match.group(1)\n        level = 1 + len(re.findall(r'\\(([^()]*)\\)', group))\n        result.append(level)\n\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n\n    sorted_lst = [min(lst)]\n    max_val = max(lst)\n    lst.remove(max_val)\n\n    while lst:\n        sorted_lst.append(max(lst))\n        max_val = max(lst)\n        lst.remove(max_val)\n        lst.remove(min(lst))\n\n    for min_val in sorted(set(lst)):\n        sorted_lst.append(min_val)\n\n    return sorted_lst"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list) -> list:\n    \"\"\"\n    Returns the derivative of a polynomial represented by its coefficients.\n    The derivative is calculated using the formula for the derivative of a polynomial.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    result = []\n    for i in range(1, len(xs)):\n        coefficient = xs[i]\n        power = i\n        new_coefficient = coefficient * power\n        result.append(new_coefficient)\n        if i < len(xs) - 1:\n            next_coefficient = xs[i + 1]\n            next_power = power + 1\n            next_new_coefficient = next_coefficient * next_power\n            result.append(next_new_coefficient)\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Returns True if the elements in the given list are either all increasing or all decreasing.\n    \"\"\"\n    if len(l) <= 1:\n        return True\n\n    is_increasing = l[0] < l[1]\n    for i in range(1, len(l)):\n        if (is_increasing and l[i] <= l[i - 1]) or (not is_increasing and l[i] >= l[i - 1]):\n            return False\n\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list) -> int:\n    \"\"\"Return maximum element in the list.\"\"\"\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return list(set(numbers))"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    result = 1\n    for i in range(n, 0, -1):\n        result *= i\n    return result"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n     If the input list is empty, return 0.\n    '''\n    result = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0:\n            if num % 2 != 0:\n                result += num ** 2\n    return result"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = abs(num)\n            digits = [abs(int(digit)) for digit in str(num)]\n        else:\n            digits = [num % 10]\n        count += sum(digits) > 0\n    return count"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n        Empty sum should be equal to 0 and empty product should be equal to 1.\n        >>> sum_product([])\n        (0, 1)\n        >>> sum_product([1, 2, 3, 4])\n        (10, 24)\n    \"\"\"\n    total_sum = 0\n    total_product = 1\n\n    for number in numbers:\n        total_sum += number\n        total_product *= number\n\n    return (total_sum, total_product)"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    # Initialize variables for storing the largest prime found so far,\n    # and the current divisor being checked.\n    largest_prime = 0\n    divisor = 2\n\n    # Loop through all possible divisors from 2 up to the square root of n.\n    while divisor * divisor <= n:\n        # If n is divisible by the current divisor, update the largest prime if necessary,\n        # and move on to the next divisor.\n        if n % divisor == 0:\n            largest_prime = divisor\n            n //= divisor\n        else:\n            # If n is not divisible by the current divisor, increment the divisor.\n            divisor += 1\n\n    # Since we have exhausted all possible divisors up to the square root of n,\n    # the remaining factor must be a prime number itself. Update the largest prime if necessary.\n    if n > 1:\n        largest_prime = n\n\n    return largest_prime"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    # Initialize a dictionary to store the visited cells and their count\n    visited = {cell: 0 for row in grid for cell in row}\n\n    def dfs(x, y, path, count):\n        if count > k or (count == k and len(path) > len(min_path)):\n            return\n        if count == k:\n            min_path = path.copy()\n            return\n\n        # Check if the current cell is already visited and its count is greater than 0\n        if visited[(x, y)] > 0:\n            return\n\n        # Mark the current cell as visited and increment its count\n        visited[(x, y)] += 1\n        path.append((x, y))\n        dfs(x + 1, y, path, count + 1)  # Move right\n        dfs(x - 1, y, path, count + 1)  # Move left\n        dfs(x, y + 1, path, count + 1)  # Move down\n        dfs(x, y - 1, path, count + 1)  # Move up\n        visited[(x, y)] -= 1\n\n    min_path = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            dfs(i, j, [(i, j)], 1)\n\n    return min_path"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    Given a string s, if the character at index i is a letter, reverse its case from lower to upper or vice versa.\n    If the string contains no letters, reverse the string. The function should return the resulted string.\n    Examples:\n        solve(\"1234\") = \"4321\"\n        solve(\"ab\") = \"AB\"\n        solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.swapcase()\n        else:\n            result += char\n    return result[::-1] if not any(char.isalpha() for char in s) else result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n    words = sentence.split()\n    prime_words = [word for word in words if len(word) in (2, 3, 5)]\n    return \" \".join(prime_words)"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n\n    # Convert the number to a string for easier processing\n    num_str = str(abs(num))\n\n    # Iterate through each digit in the number\n    for digit in num_str:\n        if int(digit) % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n    return (count_even, count_odd)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    evens = 0\n    odds = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1] and i % 2 == 0:\n            evens += 1\n        elif str(i) == str(i)[::-1] and i % 2 != 0:\n            odds += 1\n    return (evens, odds)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    \"\"\"\n    Returns True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n\n    opening_bracket = \"<\"\n    closing_bracket = \">\"\n    stack = []\n\n    for bracket in brackets:\n        if bracket == opening_bracket:\n            stack.append(bracket)\n        elif bracket == closing_bracket and stack and stack[-1] == opening_bracket:\n            stack.pop()\n        else:\n            return False\n\n    return not stack  # Return True if the stack is empty, meaning all brackets are closed"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    current_sum = float('inf')\n    smallest_sum = float('inf')\n\n    for num in nums:\n        current_sum = min(current_sum + num, num)\n        smallest_sum = min(smallest_sum, current_sum)\n\n    return smallest_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater\n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n\n    # Calculate semi-perimeter (s) of the triangle\n    s = (a + b + c) / 2\n\n    # Check if the given sides form a valid triangle\n    if s > max((a, b, c)) or s < min((a, b, c)):\n        return -1\n\n    # Calculate area using Heron's formula\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n\n    # Round the result to 2 decimal points\n    return round(area, 2)"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n\n    stack, result = [], []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return []  # Invalid parentheses structure\n            stack.pop()\n            if stack:\n                last = stack[-1]\n                if last == '(':\n                    result[-1] += char\n                else:\n                    result.append(char)\n    if stack:\n        return []  # Unclosed parentheses\n\n    return [item for item in result if item]"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    Returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n    \"\"\"\n    numbers = set(l) # convert list to a set to remove duplicates\n    for num1 in numbers:\n        for num2 in numbers:\n            if num1 + num2 in numbers: # check if third number exists\n                return True\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    Compares two arrays of scores and guesses to determine the absolute difference between each pair.\n    Returns an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n    return [abs(game[i] - guess[i]) for i in range(len(game))]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data (nested lists), find all occurrences of the integer x and return list of tuples in sorted order.\n    Each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order, then sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                result.append((i, j))\n    result.sort(key=lambda x: x[0])\n    for i in range(len(result)):\n        result[i] = (result[i][0], len(lst) - result[i][1] - 1)\n    return sorted(result, key=lambda x: x[1], reverse=True)"}
