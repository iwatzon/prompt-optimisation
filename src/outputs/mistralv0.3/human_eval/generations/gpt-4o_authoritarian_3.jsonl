{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    result = []\n    for num in range(a, b + 1):\n        if num > 0:  # Ensure the number is positive\n            if any(d % 2 == 0 for d in list(str(num))):  # Check if the number has an even digit\n                result.append(num)\n    return sorted(result)"}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)"}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string: str) -> List[int]:\n    stack = []\n    result = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if not stack:\n                result.append(1)\n            else:\n                result[-1] += 1\n\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n    if not lst:\n        return []\n\n    sorted_lst = [min(lst)]\n    max_val = max(lst)\n    lst.remove(max_val)\n\n    while lst:\n        min_val = min(lst)\n        max_val = max(lst)\n        sorted_lst.append(max_val)\n        lst.remove(max_val)\n        lst.remove(min_val)\n\n    return sorted_lst + [max(lst)]"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    return [None if i == 0 else (i+1)*xs[i-1] for i in range(1, len(xs))]"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\"\"\"\n    if len(l) <= 1:\n        return True\n\n    is_increasing = l[0] < l[1]\n    for i in range(1, len(l)):\n        if (is_increasing and l[i] < l[i - 1]) or (\\not is_increasing and l[i] > l[i - 1]):\n            return False\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    return max(l)"}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(set(numbers))"}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n\n    return result"}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    Parameters:\n    lst (list): The input list of numbers.\n\n    Returns:\n    int: The sum of squares of the odd, non-negative and integer numbers in the list.\n    '''\n    result = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0 and num % 2 != 0:\n            result += num ** 2\n    return result"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    result = 0\n    for num in arr:\n        if num < 0:\n            num = abs(num)\n            digits = [abs(digit) for digit in str(num)]\n        else:\n            digits = list(str(num))\n        sum_of_digits = sum(map(int, digits))\n        if sum_of_digits > 0:\n            result += 1\n    return result"}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]):\n    sum_val = 0\n    product_val = 1\n\n    for num in numbers:\n        sum_val += num\n        product_val *= num\n\n    return (sum_val, product_val)"}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    if n <= 1:\n        return n\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n\n    # Initialize largest prime factor with n itself, since it's the largest so far\n    largest = n\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            n //= i\n            largest = max(largest, i)\n\n    # If n is still not 1, it means n itself is the largest prime factor\n    return max(largest, n)"}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    \"\"\"\n    Finds the minimum path of length k in a given grid.\n\n    Parameters:\n    grid (list): A list representing the grid with N rows and N columns.\n                Each inner list contains the values of the cells in that row.\n    k (int): The desired length of the path.\n\n    Returns:\n    list: An ordered list of the values on the cells that the minimum path goes through.\n    \"\"\"\n    # Initialize a dictionary to store visited cells and their count\n    visited = {cell: 0 for row in grid for cell in row}\n    paths = []\n\n    def dfs(current, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n\n        # Check if the current cell has been visited more than once or if it exceeds the remaining count\n        if visited[current] > 1 or visited[current] + 1 > k - len(path):\n            return\n\n        # Mark the current cell as visited and increment its count\n        visited[current] += 1\n\n        # Recursively explore neighboring cells\n        for neighbor in [(current[0] + 1, current[1]), (current[0], current[1] + 1), (current[0] - 1, current[1]), (current[0], current[1] - 1)]:\n            if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] not in path:\n                dfs(neighbor, path + [grid[neighbor[0]][neighbor[1]]])\n\n        # Backtrack by decrementing the count of the current cell\n        visited[current] -= 1\n\n    # Start the depth-first search from any cell in the grid\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            dfs((i, j), [grid[i][j]])\n\n    # Sort the paths lexicographically and return the minimum one\n    paths.sort()\n    return paths[0]"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    Given a string s, if it contains any letters, reverse their case from lower to upper or vice versa.\n    If the string does not contain any letters, reverse the entire string.\n    The function should return the resulted string.\n    Examples:\n        solve(\"1234\") = \"4321\"\n        solve(\"ab\") = \"AB\"\n        solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += char.upper() if char.islower() else char.lower()\n        else:\n            result += char\n    return result[::-1] if not any(char.isalpha() for char in s) else result"}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    \"\"\"\n    Returns a string that contains the words from the original sentence,\n    whose lengths are prime numbers, in the same order as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n    words = sentence.split()\n    prime_words = [word for word in words if len(word) in (2, 3, 5)]\n    return ' '.join(prime_words)"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function and returns the decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) - 5 + 26) % 26 + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n\n    if num < 0:\n        num *= -1\n\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n        num //= 10\n\n    return (count_even, count_odd)"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    evens = 0\n    odds = 0\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1] and i % 2 == 0:\n            evens += 1\n        elif str(i) == str(i)[::-1] and i % 2 != 0:\n            odds += 1\n    return (evens, odds)"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    \"\"\"\n    Checks if the given string of '<' and '>' has properly balanced brackets.\n\n    Parameters:\n    brackets (str): A string containing only '<' and '>'.\n\n    Returns:\n    bool: True if every opening bracket has a corresponding closing brackets, False otherwise.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack.pop() != \"<\":\n                return False\n    return not stack"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    current_sum = float('inf')\n    smallest_sum = float('inf')\n\n    for num in nums:\n        current_sum = min(current_sum + num, num)\n        smallest_sum = min(smallest_sum, current_sum)\n\n    return smallest_sum"}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    if a + b > c and b + c > a and c + a > b:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    result = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return []  # Invalid input, unbalanced parentheses\n            stack.pop()\n\n    if stack:\n        return []  # Unclosed parentheses at the end of the string\n\n    for start in range(len(stack)):\n        result.append(''.join(stack[start:]))\n        stack[start:] = []\n\n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    Checks if there are three distinct elements in the list that sum to zero.\n\n    Returns:\n        bool: True if there are three distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    for i in range(len(l) - 2):\n        for j in range(i + 1, len(l) - 1):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0 and i != j != k:\n                    return True\n    return False"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    Compares two arrays of scores and guesses to determine the absolute difference between each pair.\n\n    Parameters:\n    game (list): A list of scores from a series of matches.\n    guess (list): A list of corresponding guesses for each match in `game`.\n\n    Returns:\n    list: A list of the same length as `game` and `guess`, containing the absolute difference between each pair.\n    \"\"\"\n    return [abs(g - s) for g, s in zip(guess, game)]"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of an integer 'x' in a given nested list (2D data),\n    and returns a sorted list of tuples representing the coordinates of those occurrences.\n    The coordinates are in the format (row, column) starting from 0.\n    The rows are sorted in ascending order, and within each row, the columns are sorted in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                result.append((i, j))\n    result.sort(key=lambda x: x[0])\n    for sublist in sorted(lst, key=len):\n        result_sublist = [coord for coord in result if sublist[coord[1]] == x]\n        result_sublist.sort(key=lambda x: -x[1])\n        result[:] = result + result_sublist\n    return result"}
