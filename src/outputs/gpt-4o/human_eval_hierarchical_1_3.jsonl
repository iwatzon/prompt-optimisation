{"task_id": "HumanEval/5", "completion": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n    \n    Args:\n    numbers (List[int]): The input list of numbers.\n    delimiter (int): The delimiter to insert between elements.\n\n    Returns:\n    List[int]: A new list with the delimiter interspersed between every two elements.\n    \n    Examples:\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    \n    # Handle edge case where the list is empty or has only one element\n    if not numbers or len(numbers) == 1:\n        return numbers\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through the input list\n    for i in range(len(numbers)):\n        result.append(numbers[i])  # Add the current number to the result list\n        if i < len(numbers) - 1:  # Check if this is not the last element\n            result.append(delimiter)  # Add the delimiter after the current element\n    \n    return result\n\n\n# Test cases to illustrate the function usage and to handle edge cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings only for ones that contain given substring.\n    \n    Args:\n        strings (List[str]): List of strings to be filtered.\n        substring (str): Substring to filter the strings by.\n        \n    Returns:\n        List[str]: List of strings that contain the given substring.\n        \n    Examples:\n        >>> filter_by_substring([], 'a')\n        []\n        >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n        ['abc', 'bacd', 'array']\n    \"\"\"\n    # Return a list containing all strings that include the substring.\n    # List comprehensions are efficient and concise for this purpose.\n    return [string for string in strings if substring in string]"}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    \n    # Remove white spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # This will store the result groups of balanced parentheses\n    result = []\n    # This will hold the current group we are processing\n    current_group = []\n    # This will help in tracking balanced parentheses\n    balance = 0\n    \n    # Iterate character by character through the string\n    for char in paren_string:\n        # Add the current character to the current group\n        current_group.append(char)\n        \n        # Update balance count: increment for '(' and decrement for ')'\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        \n        # When balance becomes zero, we have a complete group\n        if balance == 0 and current_group:\n            result.append(''.join(current_group))  # Join the list to form the group string\n            current_group = []  # Reset current group for next potential group\n    \n    return result\n\n# Example usage:\nprint(separate_paren_groups('( ) (( )) (( )( ))'))\n# Output: ['()', '(())', '(()())']"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    \n    Args:\n        number (float): Positive floating point number to truncate.\n\n    Returns:\n        float: Decimal part of the number.\n    \n    Raises:\n        ValueError: If the number is negative.\n    \n    Examples:\n        >>> truncate_number(3.5)\n        0.5\n        >>> truncate_number(4.0)\n        0.0\n        >>> truncate_number(0.123)\n        0.123\n    \"\"\"\n\n    # Ensure the number is positive\n    if number < 0:\n        raise ValueError(\"The number should be positive.\")\n    \n    # Extract the integer part of the number using int()\n    integer_part = int(number)\n    \n    # Subtract the integer part from the original number to get the decimal part\n    decimal_part = number - integer_part\n    \n    return decimal_part\n\n# Test cases to ensure function behaves as expected.\nassert truncate_number(3.5) == 0.5\nassert truncate_number(4.0) == 0.0\nassert truncate_number(0.123) == 0.123\nassert truncate_number(0.999) == 0.999\nassert truncate_number(123.456) == 0.456\n\ntry:\n    truncate_number(-3.5)\nexcept ValueError as e:\n    assert str(e) == \"The number should be positive.\"\n\nprint(\"All test cases pass.\")"}
{"task_id": "HumanEval/0", "completion": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the array first. This allows us to only compare adjacent numbers.\n    # Sorting is O(n log n), and the pairwise comparison is O(n),\n    # leading to an overall complexity of O(n log n).\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between each adjacent pair\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    # If no pair is found that satisfies the condition, return False\n    return False\n\n# Example usages for manual testing\nif __name__ == \"__main__\":\n    print(has_close_elements([1.0, 2.0, 3.0], 0.5))  # Expected output: False\n    print(has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3))  # Expected output: True\n    # Testing edge cases\n    print(has_close_elements([], 0.1))  # Expected output: False, empty list\n    print(has_close_elements([1.0], 0.1))  # Expected output: False, single element list\n    print(has_close_elements([1.0, 1.05], 0.1))  # Expected output: True, two elements within threshold\n    print(has_close_elements([1.0, 1.2, 1.4], 0.25))  # Expected output: True, closely spaced elements"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n\n    :param numbers: List of integers\n    :return: Tuple containing the sum and product of the integers in the list\n\n    Examples:\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        # If the list is empty, return (0, 1)\n        return 0, 1\n    \n    # Initialize sum and product\n    total_sum = 0\n    total_product = 1\n\n    # Iterate through the list once for efficiency\n    for number in numbers:\n        total_sum += number\n        total_product *= number\n    \n    return total_sum, total_product\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    - strings: List of strings to find the longest string from.\n    \n    Returns:\n    Optional[str]: The longest string from the input list or None if the list is empty.\n    \n    Examples:\n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    \n    # Check if the list is empty and return None immediately to save unnecessary processing\n    if not strings:\n        return None\n    \n    # Initialize variables to track the maximum length and the longest string found.\n    max_length = 0\n    longest_string = None\n    \n    for s in strings:\n        # If the current string's length is greater than the max length found so far,\n        # update the max_length and the longest_string.\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_string = s\n    \n    return longest_string\n\n# The approach chosen iterates through the list in a single pass (O(n) complexity)\n# and utilizes constant space for tracking the longest string found."}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n\n    >>> string_xor('010', '110')\n    '100'\n    >>> string_xor('111', '000')\n    '111'\n    >>> string_xor('10101', '10101')\n    '00000'\n    >>> string_xor('', '')\n    ''\n    >>> string_xor('1', '0')\n    '1'\n    >>> string_xor('1100', '101')\n    ValueError: Input strings must be of the same length.\n    \"\"\"\n    \n    # Ensure both strings are of the same length\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length.\")\n    \n    # Use a list comprehension for efficient string construction\n    result = [str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b)]\n    \n    # Join the list into a single string\n    return ''.join(result)"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" \n    Return list of all prefixes from shortest to longest of the input string\n    \n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \n    Edge cases:\n    >>> all_prefixes('')\n    []\n    >>> all_prefixes('a')\n    ['a']\n    >>> all_prefixes('12345')\n    ['1', '12', '123', '1234', '12345']\n    \"\"\"\n    # Initialize an empty list to hold the prefixes\n    prefixes = []\n    \n    # Iterate over the string to create incremental prefixes\n    for i in range(1, len(string) + 1):\n        # Append the substring which is the prefix up to the current index\n        prefixes.append(string[:i])\n    \n    return prefixes\n\n# Example use cases to demonstrate the function\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n"}
{"task_id": "HumanEval/9", "completion": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found until a given moment\n    in the sequence.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n    \n    Returns:\n    List[int]: A list of rolling maximum elements.\n    \n    Raises:\n    ValueError: If the input is an empty list.\n    \n    Examples:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \n    >>> rolling_max([3, 1, 4, 1, 5, 9, 2, 6, 5])\n    [3, 3, 4, 4, 5, 9, 9, 9, 9]\n    \n    >>> rolling_max([])\n    Traceback (most recent call last):\n      ...\n    ValueError: The input list is empty.\n    \"\"\"\n    \n    if not numbers:\n        raise ValueError(\"The input list is empty.\")\n    \n    # Initialize the result list with the first element's max\n    result = []\n    current_max = float('-inf')\n    \n    for number in numbers:\n        # Update the current max found so far\n        if number > current_max:\n            current_max = number\n        \n        # Append the current max to the result list\n        result.append(current_max)\n    \n    return result\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    \n    # Additional edge cases\n    print(rolling_max([7, 7, 7, 7]))  # Expected: [7, 7, 7, 7]\n    print(rolling_max([-5, -4, -9, -1]))  # Expected: [-5, -4, -4, -1]\n    print(rolling_max([1000, 100, 10, 1]))  # Expected: [1000, 1000, 1000, 1000]"}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    \n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    balance = 0  # Initialize the balance to zero\n    \n    # Iterate through each operation in the list\n    for operation in operations:\n        balance += operation  # Update the balance by adding the current operation\n        \n        if balance < 0:  # Check if the balance falls below zero\n            return True  # Return True if it does\n    \n    return False  # Return False if balance never falls below zero\n\n# Example usage\n#print(below_zero([1, 2, 3]))  # Should return False\n#print(below_zero([1, 2, -4, 5]))  # Should return True"}
{"task_id": "HumanEval/10", "completion": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return string\n\n    # Function to find the longest palindromic suffix\n    def longest_palindromic_suffix(s: str) -> str:\n        for i in range(len(s)):\n            # Check if s[i:] is a palindrome\n            if is_palindrome(s[i:]):\n                return s[i:]\n        return \"\"\n\n    longest_suffix = longest_palindromic_suffix(string)\n    # Prefix is the part of the string before the palindromic suffix\n    prefix = string[:len(string) - len(longest_suffix)]\n    # Append the reverse of the prefix to the original string to form the shortest palindrome\n    return string + prefix[::-1]\n\n# Testing our function with examples and edge cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    print(make_palindrome(\"race\"))  # Expected: \"racecar\"\n    print(make_palindrome(\"aab\"))   # Expected: \"aabaa\"\n    print(make_palindrome(\"abcd\"))  # Expected: \"abcdcba\"\n    print(make_palindrome(\"aa\"))    # Expected: \"aa\"\n    print(make_palindrome(\"a\"))     # Expected: \"a\"\n    print(make_palindrome(\"\"))      # Expected: \"\""}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \n    Input to this function is a string representing multiple groups of nested parentheses separated by spaces.\n    For each group, output the deepest level of nesting of parentheses.\n    E.g., (()()) has maximum two levels of nesting while ((())) has three.\n\n    Arguments:\n    paren_string -- A string composed of multiple groups of parentheses separated by spaces.\n\n    Returns:\n    A list of integers where each integer represents the deepest level of nesting of the corresponding group of parentheses.\n\n    Example:\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def max_depth(paren_group: str) -> int:\n        \"\"\"Helper function to calculate the maximum depth of a single group of parentheses.\"\"\"\n        current_depth = 0\n        max_depth = 0\n        \n        for char in paren_group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n                if current_depth < 0:\n                    raise ValueError(f\"Unbalanced parentheses detected in group: {paren_group}\")\n        \n        if current_depth != 0:\n            raise ValueError(f\"Unbalanced parentheses detected in group: {paren_group}\")\n\n        return max_depth\n\n    if not paren_string or not isinstance(paren_string, str):\n        raise ValueError(\"Input must be a non-empty string\")\n        \n    groups = paren_string.split()\n    return [max_depth(group) for group in groups]\n\n# Testing the function with a given example and edge cases\nif __name__ == \"__main__\":\n    # Example from the docstring\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))  # Output: [2, 3, 1, 3]\n    \n    # Additional edge cases\n    print(parse_nested_parens(''))  # Raises ValueError: Input must be a non-empty string\n    print(parse_nested_parens('(()) () (()()(())) ((()))'))  # Output: [2, 1, 3, 3]\n    try:\n        print(parse_nested_parens('(() ())))'))  # Raises ValueError due to unbalanced parentheses\n    except ValueError as e:\n        print(e)\n    try:\n        print(parse_nested_parens('(()) ((())) (()(()))))'))  # Raises ValueError due to unbalanced parentheses\n    except ValueError as e:\n        print(e)"}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Edge case: If the input list is empty, return 0.0 as MAD cannot be computed\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    n = len(numbers)\n    mean = sum(numbers) / n\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean) for x in numbers) / n\n    \n    return mad\n\n# Test cases to ensure that the function works as expected in different scenarios\nif __name__ == \"__main__\":\n    # Basic test case\n    print(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]))  # Expected output: 1.0\n    \n    # Edge case: Empty list\n    print(mean_absolute_deviation([]))  # Expected output: 0.0\n    \n    # Edge case: Single-element list\n    print(mean_absolute_deviation([42.0]))  # Expected output: 0.0\n    \n    # Test case: All elements are the same\n    print(mean_absolute_deviation([5.0, 5.0, 5.0, 5.0]))  # Expected output: 0.0\n    \n    # Test case: Mixed positive and negative numbers\n    print(mean_absolute_deviation([-1.0, 0.0, 1.0, 2.0, -2.0]))  # Expected output: 1.2\n\n    # Test case: Large list of numbers\n    import random\n    large_list = [random.uniform(-1000, 1000) for _ in range(1000000)]\n    print(mean_absolute_deviation(large_list))  # Performance test, output is variable"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n    string (str): The input string to be analyzed.\n    \n    Returns:\n    int: The number of distinct characters in the string.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \n    Raises:\n    TypeError: If the input is not a string.\n    \"\"\"\n    \n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Normalize the string to lowercase to disregard case in character comparison\n    normalized_string = string.lower()\n    \n    # Use a set to keep track of distinct characters\n    distinct_characters = set(normalized_string)\n    \n    # The number of distinct characters is the size of the set\n    return len(distinct_characters)\n\n# Example edge cases and tests\nassert count_distinct_characters('xyzXYZ') == 3, \"Test case 1 failed\"\nassert count_distinct_characters('Jerry') == 4, \"Test case 2 failed\"\nassert count_distinct_characters('') == 0, \"Test case 3 failed\"  # Edge case: empty string\nassert count_distinct_characters('AaAaAa') == 1, \"Test case 4 failed\"  # Case insensitivity\nassert count_distinct_characters('123123') == 3, \"Test case 5 failed\"  # Non alphabetic characters\n\nprint(\"All tests passed!\")\n\n# Final function\n# In a real world scenario, we wouldn't include the test cases and print statement in the final submission,\n# but they are here to demonstrate correctness."}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" \n    Find how many times a given substring can be found in the original string. Count overlapping cases.\n    \n    Parameters:\n    - string (str): The string in which to search for the substring.\n    - substring (str): The substring to search for within the original string.\n\n    Returns:\n    - int: The number of times the substring is found in the string, counting overlapping occurrences.\n    \n    Note:\n    - If substring is empty, zero occurrences are assumed.\n    \n    Examples:\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    \n    # Edge case: If substring is empty, return 0\n    if not substring:\n        return 0\n    \n    count = 0\n    start = 0\n    while True:\n        # Try to find substring in string starting at index 'start'\n        start = string.find(substring, start)\n        \n        # If substring is not found, break the loop\n        if start == -1:\n            break\n        \n        # Found an occurrence, increment the count\n        count += 1\n        \n        # Move start ahead by one character to ensure overlaps are counted\n        start += 1\n    \n    return count\n\n# Example Usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    # Using list comprehension to filter integers, which is concise and efficient O(n)\n    return [value for value in values if isinstance(value, int)]\n\n# Example usage and edge cases\nif __name__ == \"__main__\":\n    # Test with different types of values\n    print(filter_integers(['a', 3.14, 5]))  # Should output: [5]\n    print(filter_integers([1, 2, 3, 'abc', {}, []]))  # Should output: [1, 2, 3]\n    # Edge cases\n    print(filter_integers([]))  # Should output: []\n    print(filter_integers([None, 'string', 0.1]))  # Should output: []\n    print(filter_integers([1, -1, 0, 123456789]))  # Should output: [1, -1, 0, 123456789]"}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    # Edge case: Handle None input gracefully\n    if string is None:\n        raise ValueError(\"Input cannot be None\")\n\n    # Initialize length counter\n    length = 0\n    \n    # Iterate through each character in the string to calculate its length\n    for char in string:\n        length += 1\n    \n    # Return the computed length\n    return length"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\"\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    Args:\n        n (int): The end number for the sequence.\n    Returns:\n        str: A space-delimited string of numbers from 0 to n.\n   \n    >>> string_sequence(0)\n    '0'\n   \n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n   \n    Raises:\n        ValueError: If n is negative.\n    \"\"\"\n\n    # Ensure n is a non-negative integer\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    # Create a range from 0 to n and convert to string with spaces in between\n    return ' '.join(map(str, range(n + 1)))\n\n# Test cases to demonstrate function behavior\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n# Example usage:\n# print(string_sequence(10))"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b.\n    \n    This function uses the Euclidean algorithm to find the GCD, which is efficient \n    with a time complexity of O(log(min(a, b))).\n\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(0, 5)\n    5\n    >>> greatest_common_divisor(5, 0)\n    5\n    >>> greatest_common_divisor(0, 0)\n    Traceback (most recent call last):\n        ...\n    ValueError: GCD is undefined for both numbers being zero.\n    \"\"\"\n    if a == 0 and b == 0:\n        # Edge case: GCD is undefined when both numbers are zero\n        raise ValueError(\"GCD is undefined for both numbers being zero.\")\n    \n    # Use absolute values to handle negatives correctly\n    a, b = abs(a), abs(b)\n\n    while b != 0:\n        a, b = b, a % b  # Repeatedly apply Euclidean algorithm\n        # Invariant: After each iteration, (a, b) -> (b, a % b)\n        # The loop ends when b becomes zero, at which point a is the GCD\n    \n    return a\n\n\n# Sample additional edge cases and tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Concatenate a list of strings into a single string.\n\n    Args:\n    strings (List[str]): List of strings to concatenate.\n\n    Returns:\n    str: Concatenated string.\n    \n    Examples:\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    # Join method of string is efficient and handles edge cases (e.g., empty list).\n    return ''.join(strings)"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    \n    Parameters:\n    numbers (List[float]): List of float numbers to be rescaled\n    \n    Returns:\n    List[float]: A transformed list where the smallest number is 0 and the largest number is 1\n    \n    Example:\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    \n    # Edge case handling for list with less than two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Determine the minimum and maximum values in the list\n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    # Edge case handling where all numbers are the same\n    if min_val == max_val:\n        raise ValueError(\"All elements in the list are the same, can't rescale.\")\n    \n    # Calculate the range (max - min)\n    range_val = max_val - min_val\n    \n    # Apply the rescaling formula: (number - min_val) / range_val\n    rescaled_numbers = [(num - min_val) / range_val for num in numbers]\n    \n    return rescaled_numbers\n\n# Example usage:\n# print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))\n# Output: [0.0, 0.25, 0.5, 0.75, 1.0]"}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings only for ones that start with a given prefix.\n\n    Args:\n        strings (List[str]): List of strings to be filtered.\n        prefix (str): Prefix to filter the strings by.\n\n    Returns:\n        List[str]: List of strings that start with the given prefix.\n    \n    Examples:\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    # Using list comprehension for concise and efficient filtering\n    result = [s for s in strings if s.startswith(prefix)]\n    \n    # Return the filtered list\n    return result\n\n# Run test cases via docstring examples\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/19", "completion": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \n    Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', and 'nine'.\n    Return the string with numbers sorted from smallest to largest.\n    \n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    # Mapping of number words to their respective integer values\n    number_map = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    # Inverse mapping for quick look-up int to word\n    inv_number_map = {v: k for k, v in number_map.items()}\n    \n    # Split the input string into individual number words\n    number_list = numbers.split()\n    \n    # Check for invalid inputs and raise an error\n    for word in number_list:\n        if word not in number_map:\n            raise ValueError(f\"Invalid number word: {word}\")\n    \n    # Convert number words to their integer equivalents for sorting\n    number_vals = [number_map[word] for word in number_list]\n    \n    # Sort the list of integers\n    number_vals.sort()\n    \n    # Convert sorted integers back to their word equivalents\n    sorted_numbers = [inv_number_map[val] for val in number_vals]\n    \n    # Join the sorted list back into a space-separated string\n    return ' '.join(sorted_numbers)\n\n\n# Example usage with edge cases and error handling:\n# Valid case\nprint(sort_numbers(\"three one five\"))  # Output: 'one three five'\n\n# Edge case: empty string - should return an empty string\nprint(sort_numbers(\"\"))  # Output: ''\n\n# Edge case: all numbers the same\nprint(sort_numbers(\"four four four\"))  # Output: 'four four four'\n\n# Edge case: contains all numbers\nprint(sort_numbers(\"nine eight seven six five four three two one zero\"))  # Output: 'zero one two three four five six seven eight nine'\n\n# Error handling: invalid input (should raise ValueError)\ntry:\n    print(sort_numbers(\"three one eleven\"))\nexcept ValueError as e:\n    print(e)  # Output: Invalid number word: eleven"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    \"\"\" \n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    \n    Args:\n    string (str): The input string whose case needs to be flipped.\n    \n    Returns:\n    str: A new string with the case of alphabetic characters flipped.\n    \n    Examples:\n    >>> flip_case('Hello')\n    'hELLO'\n    >>> flip_case('WORLD123')\n    'world123'\n    >>> flip_case('')\n    ''\n    >>> flip_case('1234')\n    '1234'\n    >>> flip_case('@#XyZ')\n    '@#xYz'\n    \"\"\"\n    \n    # Use a list comprehension to flip the case for each character in the string.\n    # This avoids repeated string concatenations which can be inefficient.\n    flipped_chars = [char.lower() if char.isupper() else char.upper() for char in string]\n    \n    # Join the list back into a string and return.\n    return ''.join(flipped_chars)\n\n\n# Run some tests to verify the function works correctly\nif __name__ == \"__main__\":\n    # Example cases\n    assert flip_case('Hello') == 'hELLO'\n    assert flip_case('WORLD123') == 'world123'\n    assert flip_case('') == ''\n    assert flip_case('1234') == '1234'\n    assert flip_case('@#XyZ') == '@#xYz'\n    \n    print(\"All test cases passed!\")"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    Args:\n        n (int): The number to find the largest divisor for.\n        \n    Returns:\n        int: The largest divisor smaller than n.\n        \n    Raises:\n        ValueError: If n is less than or equal to 1.\n        \n    Examples:\n        >>> largest_divisor(15)\n        5\n        >>> largest_divisor(10)\n        5\n        >>> largest_divisor(7)\n        1\n        >>> largest_divisor(2)\n        1\n    \"\"\"\n    \n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1 to find a divisor smaller than n.\")\n    \n    # Starting from the second largest number down to 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i  # Return the first divisor found\n    \n    return 1  # Fallback case for any input n > 1 should always have 1 as a divisor\n\n# Example Call\n# print(largest_divisor(15))  # Output: 5"}
{"task_id": "HumanEval/25", "completion": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input number should be an integer greater than 1.\")\n\n    factors = []\n    divisor = 2\n\n    while n >= 2:\n        # Check if the current number is divisible by the divisor\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n\n        # Optimisation: If divisor squared is greater than the number and it's not 1, then number itself is prime\n        if divisor * divisor > n:\n            if n > 1:\n                factors.append(n)\n                break\n    \n    return factors\n\n# Examples\nprint(factorize(8))   # Output: [2, 2, 2]\nprint(factorize(25))  # Output: [5, 5]\nprint(factorize(70))  # Output: [2, 5, 7]"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Edge case: integers less than 2 are not prime numbers\n    if n <= 1:\n        return False\n    \n    # Check for factors from 2 to the square root of n\n    # If any factor is found in this range, n is not prime\n    # We use int(n**0.5) + 1 for the inclusive range up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\n# Examples for testing, as indicated in the docstring\nprint(is_prime(6))  # False\nprint(is_prime(101))  # True\nprint(is_prime(11))  # True\nprint(is_prime(13441))  # True\nprint(is_prime(61))  # True\nprint(is_prime(4))  # False\nprint(is_prime(1))  # False"}
{"task_id": "HumanEval/26", "completion": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Args:\n    numbers (List[int]): A list of integers where duplicates need to be removed.\n    \n    Returns:\n    List[int]: A list with duplicates removed.\n    \n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Edge Case: Empty list input\n    if not numbers:\n        return []\n    \n    # Dictionary to keep track of the count of each number in the list\n    count_dict = {}\n    \n    # First pass to populate the count dictionary\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n\n    # List comprehension to include only numbers which occur once\n    result = [number for number in numbers if count_dict[number] == 1]\n    \n    return result\n\n# Testing with a provided example\nprint(remove_duplicates([1, 2, 3, 2, 4]))  # Should output: [1, 3, 4]\n\n# Additional test cases\nprint(remove_duplicates([4, 5, 6, 5, 4, 3]))  # Should output: [6, 3]\nprint(remove_duplicates([1, 1, 1, 2, 2, 3]))  # Should output: [3]\nprint(remove_duplicates([]))  # Should output: []\nprint(remove_duplicates([10, 20, 30]))  # Should output: [10, 20, 30]"}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n        l (list): A list of elements, which can be any comparable type\n\n    Returns:\n        list: A sorted list of unique elements\n\n    Example:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements_set = set(l)\n    \n    # Convert the set back to a list and sort it\n    sorted_unique_elements = sorted(unique_elements_set)\n    \n    return sorted_unique_elements\n\n\n# Example usage:\nprint(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]))  # [0, 2, 3, 5, 9, 123]\nprint(unique([]))  # Edge case: Empty list should return an empty list\nprint(unique([1, 1, 1]))  # Edge case: List with all identical elements\nprint(unique([-1, -5, 3, 0]))  # Edge case: List with negative values"}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    \n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the numbers list to prepare for finding the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (float('-inf'), float('inf'))\n    \n    # Traverse the sorted list and find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        \n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair\n\n# Example usage:\n# print(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))  # Output: (2.0, 2.2)\n# print(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]))  # Output: (2.0, 2.0)"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n\n    which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper limit (non-inclusive).\n\n    Returns:\n    int: The count of digit '7' in qualifying numbers.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    \n    # Check if input is of the correct type\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    def count_sevens(num: int) -> int:\n        \"\"\"Helper function to count occurrences of digit '7' in an integer.\"\"\"\n        return str(num).count('7')\n\n    count_7 = 0\n\n    # Traverse all numbers less than n and check divisibility\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            # Count '7's in numbers that are divisible by 11 or 13\n            count_7 += count_sevens(i)\n    \n    return count_7\n\n# Example test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the values at even indices\n    even_values_sorted = sorted(even_values)\n    \n    # Create a new list that will store the final sorted list with maintained odd values.\n    result = l[:]\n    \n    # Replace the values at even indices with sorted even values\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = even_values_sorted[even_index]\n        even_index += 1\n    \n    return result"}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the\n    indices that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Handle the case where the input is not a list\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Handle the case where the input list is empty\n    if not l:\n        return []\n\n    # Extract the elements at indices divisible by three\n    div_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    div_by_three_sorted = sorted(div_by_three)\n    \n    # Reconstruct the output list l'\n    result = []\n    sorted_index = 0\n\n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Insert sorted element at positions divisible by three\n            result.append(div_by_three_sorted[sorted_index])\n            sorted_index += 1\n        else:\n            # Retain original element at other positions\n            result.append(l[i])\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    It returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n\n    # If there are less than 3 elements in the list, we cannot find three distinct elements that sum to zero\n    if len(l) < 3:\n        return False\n\n    # Sort the list to enable two-pointer technique\n    l.sort()\n\n    # Iterate through the list, selecting each element 'a'\n    for i in range(len(l) - 2):\n        # If the current value is the same as the previous one, skip it to avoid duplicates\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n        \n        # Initialize two pointers\n        left = i + 1\n        right = len(l) - 1\n\n        # Use two-pointer technique to find 'b' and 'c' such that a + b + c = 0\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1  # Need a larger number, move the left pointer to the right\n            else:\n                right -= 1  # Need a smaller number, move the right pointer to the left\n\n    # If no triplet found that sums to zero, return False\n    return False\n\n\n# The above solution uses a triplet-finding approach which involves sorting the list and utilizing\n# the two-pointer technique to achieve O(n^2) time complexity. It ensures that the solution is\n# efficient and avoids common pitfalls such as duplicate calculations."}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \n    Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return a list of integers corresponding to how many beats does each\n    note last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quarter note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    # Legend dict to translate musical ASCII symbols to beats\n    note_to_beats = {\n        'o': 4,    # whole note\n        'o|': 2,   # half note\n        '.|': 1    # quarter note\n    }\n    \n    # Split the music string based on whitespace to get individual notes\n    notes = music_string.split()\n    \n    # Map each note to its corresponding beat count using the dictionary\n    beats = []\n    for note in notes:\n        if note in note_to_beats:\n            beats.append(note_to_beats[note])\n        else:\n            raise ValueError(f\"Unknown musical note '{note}' encountered.\")\n    \n    return beats\n\n# If you have a testing framework, you would typically run this as part of a test suite\n# For illustrative purposes, a manual example\nif __name__ == \"__main__\":\n    example1 = 'o o| .| o| o| .| .| .| .| o o'\n    print(parse_music(example1)) # Should output [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\n    example2 = 'o o .| o .| o| o| .| .| o o .|'\n    print(parse_music(example2)) # Should output [4, 4, 1, 4, 1, 2, 2, 1, 1, 4, 4, 1]\n\n    try:\n        # Example with an invalid note\n        print(parse_music('o o .| x o|'))\n    except ValueError as e:\n        print(e)  # Should raise \"Unknown musical note 'x' encountered.\""}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    # Use a set to track the elements we have seen so far.\n    seen_elements = set()\n    \n    for number in l:\n        # Check if the negation of the current number is already in the seen set.\n        if -number in seen_elements:\n            return True\n        # Add the current number to the seen set.\n        seen_elements.add(number)\n    \n    # If no pairs sum to zero, return False.\n    return False\n\n# Example usage:\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/39", "completion": "from math import isqrt\n\ndef is_prime(num: int) -> bool:\n    \"\"\"\n    Helper function to check if a number is prime.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef generate_fibonacci():\n    \"\"\"\n    Generator function to produce Fibonacci numbers indefinitely.\n    The sequence starts at 1, 1, 2, 3, 5, 8, 13, ...\n    \"\"\"\n    a, b = 1, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns the n-th number that is a Fibonacci number and is also prime.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # Counter for found prime Fibonacci numbers\n    count = 0\n    \n    # Iterate over the Fibonacci sequence using a generator\n    for fib_num in generate_fibonacci():\n        if is_prime(fib_num):\n            count += 1\n            if count == n:\n                return fib_num\n\n# Example usage:\nprint(prime_fib(1))  # should return 2\nprint(prime_fib(2))  # should return 3\nprint(prime_fib(3))  # should return 5\nprint(prime_fib(4))  # should return 13\nprint(prime_fib(5))  # should return 89"}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    # Validate that the input is a list, otherwise raise an appropriate error\n    if not isinstance(l, list):\n        raise TypeError(\"Input should be a list.\")\n    \n    # Validate all elements in the list for correctness (must be integers)\n    if not all(isinstance(item, int) for item in l):\n        raise ValueError(\"All elements in the list must be integers.\")\n    \n    # Use list comprehension for concise and efficient iteration\n    return [item + 1 for item in l]\n\n# Including additional test cases to cover edge conditions\ndef test_incr_list():\n    # Edge case: empty list\n    assert incr_list([]) == []\n    \n    # Edge case: list with one element\n    assert incr_list([0]) == [1]\n    \n    # Edge case: large numbers\n    assert incr_list([1000000000]) == [1000000001]\n    \n    # Invalid input cases\n    try:\n        incr_list(\"not a list\")\n    except TypeError as e:\n        assert str(e) == \"Input should be a list.\"\n    \n    try:\n        incr_list([1, 2, \"3\"])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be integers.\"\n    \n    print(\"All tests passed!\")\n\n# Run the additional tests\ntest_incr_list()"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    \n    This function filters the given list and returns a list that contains\n    only the positive numbers from the original list.\n\n    Args:\n    l (list): A list of integers.\n\n    Returns:\n    list: A list containing only positive integers from the input list.\n\n    Examples:\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    # Validate input to ensure it is a list\n    if not isinstance(l, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Using list comprehension for concise, efficient, and Pythonic way to filter positive numbers\n    return [num for num in l if isinstance(num, (int, float)) and num > 0]\n\n# Edge case demonstrations:\n# Expecting an empty list because input list is empty\nprint(get_positive([]))  # []\n\n# Expecting a ValueError because input is not a list\ntry:\n    print(get_positive(\"not a list\"))\nexcept ValueError as e:\n    print(e)  # Input must be a list.\n\n# Expecting an empty list because there are no positive numbers\nprint(get_positive([-1, -2, -3, 0]))  # []\n\n# Expecting [1.2, 3.4] because they are the only positive numbers\nprint(get_positive([-1, 1.2, -3.4, 3.4, 0]))  # [1.2, 3.4]"}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    \"\"\"\n    Given the length of a base (a) and height (h), return the area of a triangle.\n    \n    The formula for the area of a triangle is: (base * height) / 2.\n\n    Assumptions:\n    1. Both a and h should be non-negative real numbers.\n    2. Both a and h should be greater than zero to form a valid triangle.\n    \n    >>> triangle_area(5, 3)\n    7.5\n\n    Edge Cases:\n    - If a or h is zero or negative, this implementation will raise a ValueError.\n    \n    \"\"\"\n\n    # Validate inputs\n    if a <= 0 or h <= 0:\n        raise ValueError(\"Both base and height must be positive numbers.\")\n\n    # Compute the area of the triangle using the standard formula\n    area = (a * h) / 2\n    \n    return area\n\n# Example usage and edge case tests:\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    \n    # Additional tests\n    try:\n        print(triangle_area(0, 5))  # Should raise ValueError\n    except ValueError as e:\n        print(e)  # Output: Both base and height must be positive numbers.\n\n    try:\n        print(triangle_area(-1, 5))  # Should raise ValueError\n    except ValueError as e:\n        print(e)  # Output: Both base and height must be positive numbers.\n\n    print(triangle_area(5, 3))  # Should output: 7.5\n    print(triangle_area(10, 10))  # Should output: 50.0"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    \n    If the list is empty, raise a ValueError with a message indicating so.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    >>> try:\n    ...     max_element([])\n    ... except ValueError as e:\n    ...     print(e)\n    List is empty\n    \n    To maintain efficiency, this function will traverse the list only once,\n    resulting in a time complexity of O(n).\n\n    Args:\n    l (list): A list of comparable elements\n\n    Returns:\n    element: The maximum element from the list\n    \n    Raises:\n    ValueError: If the list is empty\n    \"\"\"\n    if not l:  # Edge case handling for empty list\n        raise ValueError(\"List is empty\")\n    \n    # Initialize the maximum element with the first element of the list\n    max_elem = l[0]\n\n    # Traverse through the list starting from the second element\n    for item in l[1:]:\n        if item > max_elem:\n            max_elem = item\n\n    return max_elem\n\nprint(max_element([1, 2, 3]))  # Example test case\nprint(max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))  # Example test case\ntry:\n    print(max_element([]))  # Edge case test for empty list\nexcept ValueError as e:\n    print(e)  # Expected to print: List is empty"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n\n    # Edge case: An empty string is considered a palindrome\n    if not text:\n        return True\n    \n    # Using two-pointer technique to check if the string is a palindrome\n    left, right = 0, len(text) - 1\n\n    while left < right:\n        # Compare characters from both ends\n        if text[left] != text[right]:\n            return False\n        # Move towards the center\n        left += 1\n        right -= 1\n    \n    # If all characters matched, it's a palindrome\n    return True\n\n# Example test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    This function calculates and returns the number of collisions between two sets \n    of cars moving towards each other on a straight, infinitely long road. Each set \n    has `n` cars, and collisions occur when a car moving left to right meets a car \n    moving right to left.\n\n    Parameters:\n    n (int): The number of cars in each set moving in opposite directions.\n\n    Returns:\n    int: The total number of collisions between the two sets of cars.\n\n    Examples:\n    >>> car_race_collision(0)\n    0\n    >>> car_race_collision(1)\n    1\n    >>> car_race_collision(2)\n    4\n    >>> car_race_collision(3)\n    9\n    \"\"\"\n    # Validate the input\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    # The total number of collisions is the product of the number of cars in each group\n    return n * n\n"}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int) -> int:\n    \"\"\"\n    Compute the n-th element of the fib4 number sequence.\n    - fib4(0) -> 0\n    - fib4(1) -> 0\n    - fib4(2) -> 2\n    - fib4(3) -> 0\n    - fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\n    Args:\n        n (int): The position in the fib4 sequence to compute.\n\n    Returns:\n        int: The n-th element of the fib4 sequence.\n\n    Raises:\n        ValueError: If n is less than 0.\n\n    Examples:\n        >>> fib4(5)\n        4\n        >>> fib4(6)\n        8\n        >>> fib4(7)\n        14\n    \"\"\"\n    \n    # edge case handling\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Base case values\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    # Using a list to store the computed values for efficiency\n    fib4_values = [0, 0, 2, 0]\n    \n    # Iteratively compute fib4 values from 4 up to n\n    for i in range(4, n + 1):\n        next_value = fib4_values[-1] + fib4_values[-2] + fib4_values[-3] + fib4_values[-4]\n        fib4_values.append(next_value)\n    \n    # The n-th element in the fib4 sequence\n    return fib4_values[n]\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str):\n    \"\"\"\n    Returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # Split the string into groups of 3 characters each\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # Rotate characters in each group if group length is 3\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    Takes as input a string encoded with the encode_cyclic function. Returns decoded string.\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    # Split the encoded string into groups of 3 characters each\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    \n    # Rotate characters in each group backwards (third position to first)\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    \n    return \"\".join(groups)\n\n# Test cases to ensure the encode and decode functions work as expected\n\n# Example where length of string is multiple of 3\nassert encode_cyclic(\"abcdef\") == \"bcaefd\"\nassert decode_cyclic(\"bcaefd\") == \"abcdef\"\n\n# Example where length of string is not a multiple of 3\nassert encode_cyclic(\"abcdefg\") == \"bcaefdg\"\nassert decode_cyclic(\"bcaefdg\") == \"abcdefg\"\n\n# Example with a single character (edge case)\nassert encode_cyclic(\"a\") == \"a\"\nassert decode_cyclic(\"a\") == \"a\"\n\n# Example with two characters (edge case)\nassert encode_cyclic(\"ab\") == \"ab\"\nassert decode_cyclic(\"ab\") == \"ab\"\n\n# Example with zero characters (empty string, edge case)\nassert encode_cyclic(\"\") == \"\"\nassert decode_cyclic(\"\") == \"\"\n\n# Example with special characters and spaces\nassert encode_cyclic(\"ab c!123\") == \"bca c1!23\"\nassert decode_cyclic(\"bca c1!23\") == \"ab c!123\""}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    >>> add(-1, -1)\n    -2\n    >>> add(-1, 1)\n    0\n    >>> add(0, 0)\n    0\n    \"\"\"\n    # Validate input types\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both x and y must be integers\")\n    \n    # Use built-in addition for simplicity and efficiency\n    result = x + y\n\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Edge case: when modulus `p` is less than or equal to 1, it is invalid\n    if p <= 1:\n        raise ValueError(\"Modulus p must be greater than 1.\")\n\n    # Edge case: when exponent `n` is negative, it is invalid\n    if n < 0:\n        raise ValueError(\"Exponent n must be non-negative.\")\n\n    # Using Python's built-in pow() function with three arguments,\n    # which efficiently computes (base^exp) % mod using modular exponentiation.\n    # This method is fast (O(log n) time complexity) and prevents overflow issues.\n    return pow(2, n, p)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # We will use Python's set data structure to check if the characters in both strings are the same.\n    # The time complexity of converting a string to a set is O(n), where n is the length of the string.\n    # Set comparison is an O(1) operation if the lengths of the sets are already known.\n    \n    # Converting both strings to sets\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Comparing the sets\n    return set_s0 == set_s1\n\n# Testing the function\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    brackets is a string of \"<\" and \">\".\n    Return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    # Initialize a counter to track the balance of brackets\n    balance = 0\n    \n    # Iterate over each character in the input string\n    for char in brackets:\n        # Increment balance for an opening bracket\n        if char == '<':\n            balance += 1\n        # Decrement balance for a closing bracket\n        elif char == '>':\n            balance -= 1\n        \n        # If balance goes negative, there are more closing brackets than opening ones\n        if balance < 0:\n            return False\n    \n    # Check that all opening brackets have been closed\n    return balance == 0"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int):\n    \"\"\"\n    Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    # Input validation to ensure `l` is a non-empty list of numbers and `t` is a number\n    if not isinstance(l, list) or not all(isinstance(x, (int, float)) for x in l):\n        raise ValueError(\"First argument must be a list of numbers\")\n    if not isinstance(t, (int, float)):\n        raise ValueError(\"Second argument must be a number\")\n    \n    # Using the built-in all() function to check if all elements are below the threshold\n    # This is efficient with time complexity O(n) where n is the length of the list `l`\n    return all(x < t for x in l)\n\n# Example usage and tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list) -> bool:\n    \"\"\"\n    Return True if list elements are monotonically increasing or decreasing.\n    \n    A list is monotonically increasing if for all elements l[i] <= l[i+1].\n    A list is monotonically decreasing if for all elements l[i] >= l[i+1].\n\n    Parameters:\n    l (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n    if not l or len(l) == 1:  # An empty list or a single-element list is considered monotonic.\n        return True\n\n    # Determine the direction by comparing the first non-equal pair\n    increasing = decreasing = None\n\n    for i in range(1, len(l)):\n        if l[i] != l[i - 1]:\n            increasing = l[i] > l[i - 1]\n            decreasing = not increasing\n            break\n\n    if increasing is None:\n        # All elements in the list are the same.\n        return True\n\n    for i in range(1, len(l)):\n        if (increasing and l[i] < l[i - 1]) or (decreasing and l[i] > l[i - 1]):\n            return False\n        \n    return True"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Change numerical base of input number x to the specified base.\n    Return string representation after the conversion.\n    The base numbers must be less than 10.\n\n    Parameters:\n    x (int): The number to convert.\n    base (int): The base to convert the number to. Must be greater than 1 and less than 10.\n\n    Returns:\n    str: The number x represented in the specified base.\n\n    Raises:\n    ValueError: If base is less than 2 or greater than 9, or if x is negative.\n\n    Examples:\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n\n    # Input validation\n    if x < 0:\n        raise ValueError(\"The number to convert must be non-negative.\")\n    if base < 2 or base >= 10:\n        raise ValueError(\"Base must be between 2 and 9, inclusive.\")\n\n    # Edge case for zero\n    if x == 0:\n        return \"0\"\n\n    # Result string to build the new base representation\n    result = []\n    \n    # Loop to compute the new base representation\n    while x > 0:\n        remainder = x % base  # fetch the remainder\n        result.append(str(remainder))  # append digit to result list\n        x = x // base  # reduce x to the quotient\n    \n    # Since we build the result in reverse order, reverse it before returning\n    result.reverse()\n    \n    return ''.join(result)\n\n# Test cases to demonstrate the function works as expected.\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    \n    The median is the middle number in a sorted, ascending or descending, list of numbers \n    and can be more descriptive of that data set than the average. If there is an even \n    number of observations, the median is the average of the two middle values.\n    \n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    >>> median([])  \n    Traceback (most recent call last):\n        ...\n    ValueError: median() arg is an empty sequence\n    >>> median([3])  \n    3\n    >>> median([3, 1])\n    2.0\n    \"\"\"\n    \n    if not l:  # Check for empty list\n        raise ValueError(\"median() arg is an empty sequence\")\n    \n    n = len(l)\n    l_sorted = sorted(l)  # Sort the list to find the median\n    middle = n // 2  # Find the middle point\n\n    if n % 2 == 1:\n        # For odd number of elements, return the middle one\n        return l_sorted[middle]\n    else:\n        # For even number of elements, return the average of the middle two\n        return (l_sorted[middle - 1] + l_sorted[middle]) / 2\n\n# Test cases to demonstrate the implementation\nprint(median([3, 1, 2, 4, 5]))  # Expected output: 3, as it is the middle element in the sorted list [1, 2, 3, 4, 5]\nprint(median([-10, 4, 6, 1000, 10, 20]))  # Expected output: 15.0, as the average of two middle elements in the sorted list [-10, 4, 6, 10, 20, 1000] is (6+10)/2\nprint(median([3]))  # Expected output: 3, with only one element in the list\nprint(median([3, 1]))  # Expected output: 2.0, as the average of two elements in the sorted list [1, 3]\n"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str) -> str:\n    \"\"\"\n    Returns encoded string by shifting every character by 5 in the alphabet.\n    Only lowercase alphabet characters are shifted; others remain unchanged.\n    \"\"\"\n    def shift_char(ch: str, shift: int) -> str:\n        if 'a' <= ch <= 'z':\n            # Find new position with wrapping\n            return chr(((ord(ch) - ord('a') + shift) % 26) + ord('a'))\n        # Non-alphabet characters remain unchanged\n        return ch\n    \n    return \"\".join(shift_char(ch, 5) for ch in s)\n\n\ndef decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with encode_shift function. Returns decoded string.\n    Uses the inverse operation of shifting every character back by 5 in the alphabet.\n    \"\"\"\n    def shift_char(ch: str, shift: int) -> str:\n        if 'a' <= ch <= 'z':\n            # Find new position with wrapping\n            return chr(((ord(ch) - ord('a') - shift) % 26) + ord('a'))\n        # Non-alphabet characters remain unchanged\n        return ch\n\n    return \"\".join(shift_char(ch, 5) for ch in s)\n\n\n# Example usage\nencoded = encode_shift(\"hello\")\nprint(encoded)  # Output should be \"mjqqt\"\n\ndecoded = decode_shift(encoded)\nprint(decoded)  # Output should be \"hello\""}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    \n    # Define a set of vowels for quick lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Use a list comprehension to build a list of characters that are not in vowels\n    result = [char for char in text if char not in vowels]\n    \n    # Join the list of characters back into a string and return\n    return ''.join(result)\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int) -> int:\n    \"\"\"\n    Return n-th Fibonacci number.\n\n    The Fibonacci sequence is defined as:\n    F(0) = 0, F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n \u2265 2\n\n    This implementation uses an iterative approach to achieve O(n) time complexity and O(1) space complexity.\n    \n    Args:\n    n (int): Index of the Fibonacci number to be found.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If the input 'n' is negative.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    >>> fib(0)\n    0\n    >>> fib(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Input must be a non-negative integer\n    \"\"\"\n    if n < 0:\n        # Edge case: Negative input\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    # Base cases: F(0) = 0, F(1) = 1\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n\n    # Calculate Fibonacci iteratively to avoid the overhead and inefficiency of recursion\n    for i in range(2, n + 1):\n        a, b = b, a + b  # Update to the next number in the sequence\n\n    return b"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"Sum numbers from 1 to n, inclusive.\n    \n    This function computes the sum of the first n natural numbers using the\n    arithmetic series formula: sum = n * (n + 1) // 2. This method is extremely\n    efficient, with a constant time complexity O(1), because it does not require\n    any iteration over the range.\n\n    Args:\n        n (int): A positive integer up to which numbers will be summed.\n\n    Returns:\n        int: The sum of numbers from 1 to n.\n\n    Raises:\n        ValueError: If the input is not a positive integer.\n    \n    Examples:\n        >>> sum_to_n(30)\n        465\n        >>> sum_to_n(100)\n        5050\n        >>> sum_to_n(5)\n        15\n        >>> sum_to_n(10)\n        55\n        >>> sum_to_n(1)\n        1\n    \"\"\"\n    # Validate the input to ensure it is a positive integer.\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Use the arithmetic series sum formula to calculate the sum.\n    return n * (n + 1) // 2\n\n# Examples to validate the function\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod() # This will run the test cases in the docstring"}
{"task_id": "HumanEval/32", "completion": "import math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef derivative(xs: list, x: float):\n    \"\"\"\n    Computes the derivative of the polynomial with coefficients xs at point x.\n    return d/dx(xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n)\n    \"\"\"\n    return sum([i * coeff * math.pow(x, i-1) for i, coeff in enumerate(xs) if i > 0])\n\ndef find_zero(xs: list, tol: float = 1e-7, max_iter: int = 1000):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must be of even length.\")\n\n    x = 0  # Initial guess can be zero, or some heuristic based starting point\n    for _ in range(max_iter):\n        fx = poly(xs, x)\n        if abs(fx) < tol:\n            return x\n        dfx = derivative(xs, x)\n        if dfx == 0:\n            raise ValueError(\"Derivative is zero. No solution found.\")\n        x -= fx / dfx  # Newton-Raphson step\n    \n    raise ValueError(\"Exceeded maximum iterations. No solution found.\")\n\n# Test cases\nprint(round(find_zero([1, 2]), 2)) # Expected output: -0.5\nprint(round(find_zero([-6, 11, -6, 1]), 2)) # Expected output: 1.0"}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to leverage set intersection, which is\n    # efficient and automatically handles unique elements.\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the intersection of the two sets.\n    common_elements = set1.intersection(set2)\n\n    # Convert the set back to a sorted list.\n    # This step is O(n log n) complexity due to sorting.\n    # Getting the best of both worlds: set operation for common elements (O(min(len(set1), len(set2))))\n    # and sorting for the final result.\n    return sorted(common_elements)\n\n# Test cases for additional edge cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Edge case: One or both lists are empty\n    print(common([], []))  # Expected output: []\n    print(common([1, 2, 3], []))  # Expected output: []\n    print(common([], [1, 2, 3]))  # Expected output: []\n\n    # Edge case: Lists with fully matching elements\n    print(common([1, 2, 3], [1, 2, 3]))  # Expected output: [1, 2, 3]\n\n    # Edge case: Lists with no common elements\n    print(common([1, 2, 3], [4, 5, 6]))  # Expected output: []\n\n    # Edge case: Lists with some common and some unique elements\n    print(common([1, 2, 3, 4], [3, 4, 5, 6]))  # Expected output: [3, 4]"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n        n: An integer greater than 1 which is not a prime number.\n    \n    Returns:\n        The largest prime factor of n.\n\n    Examples:\n        >>> largest_prime_factor(13195)\n        29\n        >>> largest_prime_factor(2048)\n        2\n    \"\"\"\n    \n    def smallest_prime_factor(n: int) -> int:\n        \"\"\"Helper function to find the smallest prime factor of n.\"\"\"\n        # 2 is the smallest prime number\n        if n % 2 == 0:\n            return 2\n        # Check for smallest odd prime factor\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return i\n        return n # If no factor found, n is prime\n\n    largest_factor = 1\n    \n    # Continuously divide n by its smallest prime factor until n becomes 1\n    while n > 1:\n        spf = smallest_prime_factor(n)\n        largest_factor = max(largest_factor, spf)\n        n //= spf\n    \n    return largest_factor\n\n# Test cases to verify the implementation\nassert largest_prime_factor(13195) == 29, \"Test Case 1 Failed\"\nassert largest_prime_factor(2048) == 2, \"Test Case 2 Failed\"\nassert largest_prime_factor(100) == 5, \"Test Case 3 Failed\"\nassert largest_prime_factor(81) == 3, \"Test Case 4 Failed\"\nassert largest_prime_factor(49) == 7, \"Test Case 5 Failed\"\n\nprint(\"All test cases passed!\")"}
{"task_id": "HumanEval/67", "completion": "import re\n\ndef fruit_distribution(s, n):\n    \"\"\"\n    Calculate the number of mango fruits in the basket.\n    \n    Parameters:\n    s (str): A string representing the number of apples and oranges.\n    n (int): The total number of fruits in the basket.\n    \n    Returns:\n    int: The number of mango fruits in the basket.\n    \"\"\"\n    \n    # Use regular expressions to find all numbers in the string\n    numbers = re.findall(r'\\d+', s)\n    \n    # Sum all retrieved numbers (which represent apples and oranges)\n    total_known_fruits = sum(map(int, numbers))\n    \n    # Calculate the number of mango fruits\n    mango_fruits = n - total_known_fruits\n    \n    return mango_fruits\n\n# Examples to validate the implementation\nprint(fruit_distribution(\"5 apples and 6 oranges\", 19))  # Output: 8\nprint(fruit_distribution(\"0 apples and 1 oranges\", 3))   # Output: 2\nprint(fruit_distribution(\"2 apples and 3 oranges\", 100)) # Output: 95\nprint(fruit_distribution(\"100 apples and 1 oranges\", 120)) # Output: 19"}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    \"\"\"\n    This function takes a string as input and returns the sum of the ASCII values of the uppercase\n    characters only.\n\n    Args:\n    s (str): Input string\n\n    Returns:\n    int: Sum of ASCII values of uppercase characters\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Add the ASCII value of the uppercase character to the total sum\n            total_sum += ord(char)\n    \n    # Return the computed sum of ASCII values of uppercase characters\n    return total_sum\n\n# Test cases to validate the solution\nassert digitSum(\"\") == 0\nassert digitSum(\"abAB\") == 131\nassert digitSum(\"abcCd\") == 67\nassert digitSum(\"helloE\") == 69\nassert digitSum(\"woArBld\") == 131\nassert digitSum(\"aAaaaXa\") == 153\nassert digitSum(\"NoUpper\") == 0  # Edge case with no uppercase letters\nassert digitSum(\"ALLCAPS\") == sum(map(ord, \"ALLCAPS\"))  # Edge case with all uppercase letters"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    # Defensive programming: handle edge case of empty list first\n    if not lst:\n        return []\n\n    # Sort the list first to easily access min and max values sequentially\n    lst.sort()\n    \n    result = []\n\n    # Use two pointers: one starting from the beginning (low), one from the end (high)\n    low, high = 0, len(lst) - 1\n\n    # Alternate between the lowest and highest remaining values until pointers meet\n    while low <= high:\n        result.append(lst[low])\n        low += 1\n        if low <= high:\n            result.append(lst[high])\n            high -= 1\n\n    return result\n\n# Example usage:\nprint(strange_sort_list([1, 2, 3, 4]))  # Output: [1, 4, 2, 3]\nprint(strange_sort_list([5, 5, 5, 5]))  # Output: [5, 5, 5, 5]\nprint(strange_sort_list([]))            # Output: []"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str):\n    \"\"\"\n    Checks whether each opening bracket '(' in the input string has a corresponding closing bracket ')'.\n\n    Args:\n    brackets (str): A string consisting of '(' and ')'.\n\n    Returns:\n    bool: True if every opening bracket has a corresponding closing bracket in the correct order, False otherwise.\n\n    The function ensures correctness by implementing a stack-based approach which efficiently matches brackets,\n    providing a runtime complexity of O(n), where n is the length of the input string.\n\n    Examples:\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    # Using a counter to track the balance of brackets\n    balance = 0\n    \n    for char in brackets:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        \n        # If balance goes negative, it means there's an unmatched closing bracket\n        if balance < 0:\n            return False\n    \n    # All opening brackets must have been closed (balance should be zero)\n    return balance == 0\n\n# Example Assertions to test the function\nif __name__ == \"__main__\":\n    assert correct_bracketing(\"(\") == False\n    assert correct_bracketing(\"()\") == True\n    assert correct_bracketing(\"(()())\") == True\n    assert correct_bracketing(\")(()\") == False\n    assert correct_bracketing(\"\") == True  # Edge case: empty string should return True\n    assert correct_bracketing(\"()()()\") == True\n    assert correct_bracketing(\"(()\") == False\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\" \n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n    \n    Examples:\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if not isinstance(xs, list):\n        raise TypeError(\"Input must be a list\")\n    \n    if not all(isinstance(coef, (int, float)) for coef in xs):\n        raise ValueError(\"All coefficients must be integers or floats\")\n    \n    # Edge case: Empty list\n    if not xs:\n        return []\n\n    # Edge case: Constants (derivative of a constant is 0)\n    if len(xs) == 1:\n        return []\n    \n    # List to store the derivative coefficients\n    derivative_coeffs = []\n    \n    # Iterate over the coefficients starting from the 1st index because the 0th index\n    # is the constant term and its derivative is 0\n    for index in range(1, len(xs)):\n        # Append the coefficient multiplied by its power to the derivative list\n        derivative_coeffs.append(xs[index] * index)\n    \n    return derivative_coeffs\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional edge cases\n    print(derivative([5]))                   # Output: []\n    print(derivative([]))                    # Output: []\n    print(derivative([0, 0, 0]))             # Output: [0, 0]\n    print(derivative([1, 1, 1, 1]))          # Output: [1, 2, 3]\n    print(derivative([2, 0, -1, 0, 3]))      # Output: [0, -2, 0, 12]"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int) -> int:\n    \"\"\"\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    \n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    \n    Args:\n    n (int): The position in the FibFib sequence to compute.\n\n    Returns:\n    int: The n-th element of the FibFib sequence.\n    \n    Examples:\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    # Handle base cases directly\n    if n < 0:\n        raise ValueError(\"The input must be a non-negative integer.\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n\n    # Use a list to store computed values to avoid recomputation (Dynamic Programming approach)\n    fibfib_sequence = [0] * (n + 1)\n    fibfib_sequence[0] = 0\n    fibfib_sequence[1] = 0\n    fibfib_sequence[2] = 1\n\n    for i in range(3, n + 1):\n        # Apply the recurrence relation\n        fibfib_sequence[i] = fibfib_sequence[i - 1] + fibfib_sequence[i - 2] + fibfib_sequence[i - 3]\n\n    return fibfib_sequence[n]\n\n# Test cases to demonstrate implementation works correctly\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n# Example usage:\nprint(fibfib(1))  # Expected output: 0\nprint(fibfib(5))  # Expected output: 4\nprint(fibfib(8))  # Expected output: 24"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n    # Convert the string to lowercase for uniformity\n    s = s.lower()\n    \n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    # Check if the last character is 'y' and count it as a vowel if true\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n\n    return count\n\n# Add more test cases to ensure that our function works correctly\ndef test_vowels_count():\n    # Test cases provided in the docstring\n    assert vowels_count(\"abcde\") == 2\n    assert vowels_count(\"ACEDY\") == 3\n\n    # Additional test cases\n    # Edge case: empty string\n    assert vowels_count(\"\") == 0\n    # Edge case: string with no vowels\n    assert vowels_count(\"bcdfg\") == 0\n    # Edge case: string with only 'y' at the end\n    assert vowels_count(\"y\") == 1\n    # Edge case: string with only 'y' not at the end\n    assert vowels_count(\"ybc\") == 0\n    # Typical cases with mixed vowels\n    assert vowels_count(\"banana\") == 3\n    assert vowels_count(\"sky\") == 1  # 'y' at the end counts as a vowel\n    # Testing case insensitivity\n    assert vowels_count(\"AEIOUY\") == 6\n    assert vowels_count(\"AEIOUX\") == 5\n    \n    # Large input\n    long_string = \"a\" * 1000 + \"e\" * 1000 + \"i\" * 1000 + \"o\" * 1000 + \"u\" * 1000 + \"y\"\n    assert vowels_count(long_string) == 5001\n\n# Run the tests\ntest_vowels_count()\n\n# Function output\nprint(\"All test cases pass\")"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n\n    The plucked node should be returned in a list, [smallest_value, its index].\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    # Initialize variables to keep track of the smallest even value and its index\n    smallest_even_value = float('inf')\n    smallest_even_index = -1\n\n    # Iterate over the array to find the smallest even value and its index\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the value is even\n            # Update if the current even value is smaller or if this is the first even number found\n            if value < smallest_even_value:\n                smallest_even_value = value\n                smallest_even_index = index\n    \n    # If there are no even numbers or the array is empty, return []\n    if smallest_even_index == -1:\n        return []\n\n    # Return the smallest even value and its index as a list\n    return [smallest_even_value, smallest_even_index]\n\n\n# Example test cases\nprint(pluck([4,2,3]))  # Output: [2, 1]\nprint(pluck([1,2,3]))  # Output: [2, 1]\nprint(pluck([]))       # Output: []\nprint(pluck([5, 0, 3, 0, 4, 2]))  # Output: [0, 1]"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    \"\"\"\n    Check if x is a simple power of n, meaning if there exists an integer k such that n ** k = x.\n\n    Args:\n        x (int): The number to be checked.\n        n (int): The base number.\n\n    Returns:\n        bool: True if x is a simple power of n, False otherwise.\n    \"\"\"\n\n    # Edge cases to consider:\n    # 1. x or n being 0 or negative.\n    # 2. n being 1, which only works for x=1.\n    # 3. x being 1 which should always return True since any number to the power of 0 is 1.\n\n    # Handle edge cases\n    if x == 1:\n        return True  # n to the power of 0 is always 1\n    if n <= 0 or x <= 0:\n        return False  # Only positive integers are considered here\n\n    # Starting with k = 1 since any n ** 0 = 1, we can directly ignore that case.\n    current_power = n\n\n    while current_power <= x:\n        if current_power == x:\n            return True\n        current_power *= n  # Incrementize power by multiplying n\n\n    return False\n\n# Examples\nprint(is_simple_power(1, 4))  # => True\nprint(is_simple_power(2, 2))  # => True\nprint(is_simple_power(8, 2))  # => True\nprint(is_simple_power(3, 2))  # => False\nprint(is_simple_power(3, 1))  # => False\nprint(is_simple_power(5, 3))  # => False"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n\n    # Initialize two pointers\n    left = 0\n    right = len(arr) - 1\n\n    # Counter for the number of changes\n    changes = 0\n\n    # Iterate until the two pointers meet in the middle\n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n\n    return changes\n\n# Test cases\nprint(smallest_change([1, 2, 3, 5, 4, 7, 9, 6]))  # Expected: 4\nprint(smallest_change([1, 2, 3, 4, 3, 2, 2]))    # Expected: 1\nprint(smallest_change([1, 2, 3, 2, 1]))          # Expected: 0\nprint(smallest_change([1, 2, 3, 3, 2, 1]))       # Expected: 0\nprint(smallest_change([1, 2, 2, 1]))             # Expected: 0\nprint(smallest_change([1]))                      # Expected: 0\nprint(smallest_change([]))                       # Expected: 0"}
{"task_id": "HumanEval/69", "completion": "from collections import Counter\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n\n    # Counter to find frequency of each element in the list\n    count = Counter(lst)\n    \n    # Initialize the result with -1 in case no valid integer is found\n    result = -1\n\n    # Iterate over the items in the counter\n    for num, freq in count.items():\n        # Check if the frequency of the number is greater than or equal to the number itself\n        if freq >= num:\n            # Update the result with the highest valid integer\n            result = max(result, num)\n\n    return result\n\n# Test cases\nassert search([4, 1, 2, 2, 3, 1]) == 2\nassert search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\nassert search([5, 5, 4, 4, 4]) == -1\nassert search([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) == 10\nassert search([9, 4, 4, 3, 3, 3]) == -1  # Edge case where one element is > than its frequency, should return -1\nassert search([10]) == -1  # Single element greater than its frequency\nassert search([1]*100) == 1  # More repetitions but still frequency >= value\nassert search([7, 7, 7]) == -1  # Similar value but still fails the freq >= num\n\n# return the final function definition\nprint(\"\"\""}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    '''\n    This function accepts two lists of strings and returns the list that has the total \n    number of characters in all strings of the list less than the other list.\n\n    If the two lists have the same number of characters, it returns the first list.\n\n    Examples:\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    def total_chars(lst):\n        # Calculate the total number of characters in all strings in the list\n        return sum(len(s) for s in lst)\n    \n    # Calculate the total number of characters in both lists\n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2\n\n# Here are some example test cases to ensure the function works correctly\nprint(total_match([], []))  # \u279e []\nprint(total_match(['hi', 'admin'], ['hI', 'Hi']))  # \u279e ['hI', 'Hi']\nprint(total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']))  # \u279e ['hi', 'admin']\nprint(total_match(['hi', 'admin'], ['hI', 'hi', 'hi']))  # \u279e ['hI', 'hi', 'hi']\nprint(total_match(['4'], ['1', '2', '3', '4', '5']))  # \u279e ['4']"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n\n    # Edge case for zero, since 0 is a cube (0^3 = 0)\n    if a == 0:\n        return True\n    \n    # For negative numbers, convert to positive and check for cube\n    abs_a = abs(a)\n    \n    # Using integer arithmetic to determine if there's an integer whose cube is `a`\n    # We check from 1 up to the cube root of `abs_a` (inclusive)\n    candidate = int(abs_a**(1/3))  # Calculate approximate cube root\n    \n    # Check if any integer around the cube root, when cubed, gives `a`\n    return candidate**3 == abs_a or (candidate + 1)**3 == abs_a or (candidate - 1)**3 == abs_a\n\n# Testing the function with provided examples\nassert iscube(1) == True\nassert iscube(2) == False\nassert iscube(-1) == True\nassert iscube(64) == True\nassert iscube(0) == True\nassert iscube(180) == False"}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    \"\"\"\n    Convert a decimal number to binary string format.\n    The binary string will be wrapped with 'db' at the beginning and at the end.\n    \n    Args:\n    decimal (int): The decimal number to convert.\n\n    Returns:\n    str: The binary string representation with 'db' format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n    # Ensure that the input is an integer\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer\")\n    \n    # Special case for zero\n    if decimal == 0:\n        return \"db0db\"\n    \n    # Convert the decimal number to binary string\n    binary_string = bin(decimal)[2:]  # bin() returns a string starting with '0b'\n    \n    # Wrap the binary string with 'db' at both ends\n    result = f\"db{binary_string}db\"\n    \n    return result\n\n# Example tests\nprint(decimal_to_binary(15))   # returns \"db1111db\"\nprint(decimal_to_binary(32))   # returns \"db100000db\"\nprint(decimal_to_binary(0))    # returns \"db0db\"\nprint(decimal_to_binary(1))    # returns \"db1db\"\nprint(decimal_to_binary(255))  # returns \"db11111111db\""}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle, return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise, return -1.\n    \n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Validate if the three sides make a valid triangle\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return -1\n    \n    # Calculate the semi-perimeter (s)\n    s = (a + b + c) / 2\n    \n    # Using Heron's formula to calculate the area\n    try:\n        # Calculation inside the square root might result in a negative number due to floating point precision issues\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    except ValueError:\n        # If there were any issues in computing the area (like a negative number inside sqrt), return -1\n        return -1\n    \n    # Round the result to 2 decimal places and return\n    return round(area, 2)\n\n# Test cases for verification\nassert triangle_area(3, 4, 5) == 6.00, \"Test case 1 failed\"\nassert triangle_area(1, 2, 10) == -1, \"Test case 2 failed\"\nassert triangle_area(5, 12, 13) == 30.00, \"Test case 3 failed\"\nassert triangle_area(1, 1, 1.732) == 0.43, \"Test case 4 failed\"\nassert triangle_area(7, 10, 5) == 16.25, \"Test case 5 failed\"\nassert triangle_area(0, 0, 0) == -1, \"Test case 6 failed\"\nassert triangle_area(-1, -1, -1) == -1, \"Test case 7 failed\"\n\nprint(\"All test cases passed!\")"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    '''\n    Check if the object q will fly based on the criteria:\n    1. The list q is balanced (palindromic).\n    2. The sum of elements in q is less than or equal to the maximum possible weight w.\n\n    Parameters:\n    q: List of integers representing the object.\n    w: Integer representing the maximum possible weight.\n\n    Returns:\n    Boolean: True if the object will fly, False otherwise.\n    '''\n    \n    # Check if the list q is a palindrome\n    def is_palindrome(lst):\n        return lst == lst[::-1]\n    \n    # Calculate the sum of elements in the list q\n    total_weight = sum(q)\n    \n    # Determine if the object will fly\n    can_fly = is_palindrome(q) and total_weight <= w\n    \n    return can_fly\n\n# Example usage and edge cases\n# The provided examples\nprint(will_it_fly([1, 2], 5))    # False\nprint(will_it_fly([3, 2, 3], 1)) # False\nprint(will_it_fly([3, 2, 3], 9)) # True\nprint(will_it_fly([3], 5))       # True\n\n# Additional edge cases\nprint(will_it_fly([], 5))        # True, empty list is considered balanced and has sum = 0\nprint(will_it_fly([1], 0))       # False, sum = 1 which is greater than 0\nprint(will_it_fly([1, 1], 1))    # False, sum = 2 which is greater than 1\nprint(will_it_fly([1, 1, 1], 3)) # True, sum = 3 and it's balanced\nprint(will_it_fly([-1, -1], -2)) # True, sum = -2 and it's balanced\nprint(will_it_fly([-1, -2], -3)) # False, sum = -3 but it's unbalanced"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Validate the input\n    if not isinstance(N, int) or N < 0 or N > 10000:\n        raise ValueError(\"Input must be an integer between 0 and 10000 inclusive.\")\n\n    # Calculate the sum of the digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to a binary string and return\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Example usages\nprint(solve(1000))  # Expected output \"1\"\nprint(solve(150))   # Expected output \"110\"\nprint(solve(147))   # Expected output \"1100\""}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    \"\"\"\n    Determines the number of prime hexadecimal digits in the given string.\n    \n    Args:\n    num (str): A string representing a hexadecimal number.\n    \n    Returns:\n    int: The count of prime hexadecimal digits in the input string.\n    \"\"\"\n    \n    # Define a set of hex digits that are prime (for quick lookup)\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime hex digits\n    prime_count = 0\n    \n    # Edge case: If input is an empty string, return 0\n    if not num:\n        return prime_count\n    \n    # Iterate over each character in the provided hex string\n    for char in num:\n        # Increment the counter if the character is in the set of prime hex digits\n        if char in prime_hex_digits:\n            prime_count += 1\n    \n    return prime_count\n\n# Examples for testing the function\nprint(hex_key(\"AB\"))         # Output: 1\nprint(hex_key(\"1077E\"))      # Output: 2\nprint(hex_key(\"ABED1A33\"))   # Output: 4\nprint(hex_key(\"123456789ABCDEF0\"))  # Output: 6\nprint(hex_key(\"2020\"))       # Output: 2\nprint(hex_key(\"\"))           # Output: 0"}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n    \"\"\"Returns true if the given number (a) is the product of exactly three prime numbers.\n    \n    Args:\n    a (int): The number to be checked. Guaranteed to be less than 100.\n    \n    Returns:\n    bool: True if `a` is the product of three prime numbers, False otherwise.\n    \"\"\"\n    \n    def sieve_of_eratosthenes(n):\n        \"\"\"Generate a list of prime numbers up to n (inclusive) using the Sieve of Eratosthenes algorithm.\"\"\"\n        is_prime = [True] * (n + 1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n + 1) if is_prime[p]]\n\n    # Given constraint a < 100, we only need primes less than 100\n    primes = sieve_of_eratosthenes(100)\n\n    # Checking combinations of three primes\n    from itertools import combinations\n    \n    for combo in combinations(primes, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n    \n    return False\n\n# Example Usage\nprint(is_multiply_prime(30))  # Output should be True as 30 = 2 * 3 * 5\nprint(is_multiply_prime(60))  # Output should be False as 60 != product of exactly 3 prime numbers\nprint(is_multiply_prime(1))   # Output should be False as 1 is not product of 3 prime numbers"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Examples:\n    starts_one_ends(1) -> 1 (1)\n    starts_one_ends(2) -> 19 (11, 12, ..., 19, 10, 21, 31, ..., 91)\n    starts_one_ends(3) -> 171 (111, 112, ..., 119, 121, ..., 191, 101, 211, ..., 911)\n    \"\"\"\n    # Ensure n is a positive integer\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    if n == 1:\n        # There are only '1' single-digit positive integers that start or end with 1\n        return 1\n    \n    # Calculate the total n-digit numbers\n    total_n_digit_numbers = 9 * (10 ** (n - 1))\n    \n    # Numbers start with 1: 1xxxx, count is 10^(n-1)\n    start_with_1 = 10 ** (n - 1)\n    \n    # Numbers end with 1: xxxx1, count is 9 * 10^(n-2) (9 to avoid overlap)\n    end_with_1 = 9 * (10 ** (n - 2))\n    \n    # Since the counts of starting and ending numbers will overlap at 1xxxx1,\n    # subtract the overlap: 10^(n-2)\n    overlap = 10 ** (n - 2)\n    \n    return start_with_1 + end_with_1 - overlap\n\n# Test cases \nprint(starts_one_ends(1))  # Expected output: 1\nprint(starts_one_ends(2))  # Expected output: 19\nprint(starts_one_ends(3))  # Expected output: 171"}
{"task_id": "HumanEval/89", "completion": "import string\n\ndef encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places, which means a shift of 4 positions.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    \n    # Defining the rotation shift\n    SHIFT = 4\n    ALPHABET_SIZE = 26\n    \n    # Creating translation table for lowercase letters\n    lower_translation = str.maketrans(\n        string.ascii_lowercase, \n        string.ascii_lowercase[SHIFT:] + string.ascii_lowercase[:SHIFT]\n    )\n\n    # Apply translation to the input string\n    encrypted_string = s.translate(lower_translation)\n    \n    return encrypted_string\n\n# Example cases for verification\nprint(encrypt('hi'))           # Expected 'lm'\nprint(encrypt('asdfghjkl'))    # Expected 'ewhjklnop'\nprint(encrypt('gf'))           # Expected 'kj'\nprint(encrypt('et'))           # Expected 'ix'"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    >>> circular_shift(1234, 1)\n    \"4123\"\n    >>> circular_shift(1234, 4)\n    \"1234\"\n    >>> circular_shift(12345, 6)\n    \"54321\" # 6 > 5, hence reversed\n    \"\"\"\n    x_str = str(x)  # Convert the integer to a string to handle digit manipulation\n    n = len(x_str)  # Get the number of digits\n\n    # If shift is greater than the number of digits, return the digits reversed\n    if shift > n:\n        return x_str[::-1]\n\n    # Normalize the shift value to handle cases where shift > n\n    shift = shift % n\n\n    # Perform the circular shift\n    if shift > 0:\n        # The last 'shift' digits will move to the front\n        result = x_str[-shift:] + x_str[:-shift]\n    else:\n        # No shift needed, return the number as is\n        result = x_str\n    \n    return result\n\n# Test cases for the function\nif __name__ == \"__main__\":\n    print(circular_shift(12, 1))  # \"21\"\n    print(circular_shift(12, 2))  # \"12\"\n    print(circular_shift(1234, 1))  # \"4123\"\n    print(circular_shift(1234, 4))  # \"1234\"\n    print(circular_shift(12345, 6))  # \"54321\""}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst: A non-empty list of integers.\n\n    Returns:\n        The sum of even integers found at odd indices in the list.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 3, 2, 6, 5, 8]) ==> 6\n        add([2, 4, 6, 8, 10]) ==> 8\n    \"\"\"\n    # Initialize sum to 0\n    even_sum = 0\n    \n    # Iterate over the list using enumeration to get both index and value\n    # Start the range from 1 to skip the first (zero) index if it's odd\n    for index in range(1, len(lst), 2):\n        value = lst[index]\n        # Check if the element at the odd index is even\n        if value % 2 == 0:\n            even_sum += value\n    \n    return even_sum\n\n# Additional edge cases and potential error conditions:\n# 1. Test with only one element which should return 0 since there's no odd index\n# 2. Test with only even or odd numbers\n# 3. Test an empty list, although the function assumes non-empty, proper handling can be added\n\n# Example tests:\nassert add([4, 2, 6, 7]) == 2\nassert add([1, 3, 2, 6, 5, 8]) == 6\nassert add([2, 4, 6, 8, 10]) == 8\nassert add([1, 3, 5, 7, 9]) == 0\nassert add([10]) == 0\nassert add([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 10\n\n# For error handling, we assume non-empty input as per the docstring requirement."}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    \"\"\"\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n    # Check if the string length is less than 3, return False immediately\n    if len(s) < 3:\n        return False\n\n    # Iterate through the string, stopping 2 characters early to check groups of 3\n    for i in range(len(s) - 2):\n        # Check if current character and the next two characters are distinct\n        if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n            return False\n\n    # If loop completes without returning False, the string is happy\n    return True\n\n# Test cases\nprint(is_happy(\"a\"))     # False\nprint(is_happy(\"aa\"))    # False\nprint(is_happy(\"abcd\"))  # True\nprint(is_happy(\"aabb\"))  # False\nprint(is_happy(\"adb\"))   # True\nprint(is_happy(\"xyy\"))   # False\nprint(is_happy(\"abcde\")) # True\nprint(is_happy(\"\"))      # False\nprint(is_happy(\"ab\"))    # False"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates.\n    coordinates = []\n    \n    # Iterate over each row with row index.\n    for row_index, row in enumerate(lst):\n        # Find all columns containing the integer x in the current row.\n        row_coords = [(row_index, col_index) for col_index, value in enumerate(row) if value == x]\n        \n        # Sorting by columns in descending order.\n        row_coords.sort(key=lambda coord: coord[1], reverse=True)\n        \n        # Extend the main coordinates list with the sorted row coordinates.\n        coordinates.extend(row_coords)\n    \n    # Return the final list of coordinates which is already sorted by row index in ascending order.\n    return coordinates\n\n# Example usage:\n# Note: The user can test the below examples to verify the solution.\nprint(get_row([\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n], 1))  # Expected output: [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\nprint(get_row([], 1))  # Expected output: []\n\nprint(get_row([[], [1], [1, 2, 3]], 3))  # Expected output: [(2, 2)]"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n    \"\"\"Converts a list of GPAs to their corresponding letter grades based on the given table.\"\"\"\n    \n    # List of tuples with GPA thresholds and their corresponding letter grades.\n    gpa_to_grade_mapping = [\n        (4.0, 'A+'), \n        (3.7, 'A'), \n        (3.3, 'A-'), \n        (3.0, 'B+'), \n        (2.7, 'B'), \n        (2.3, 'B-'), \n        (2.0, 'C+'), \n        (1.7, 'C'), \n        (1.3, 'C-'), \n        (1.0, 'D+'), \n        (0.7, 'D'), \n        (0.0, 'D-'), \n        (-float('inf'), 'E')  # This works as it will catch any GPA < 0.0\n    ]\n    \n    def get_letter_grade(gpa):\n        \"\"\"Returns the corresponding letter grade for a given GPA.\"\"\"\n        for threshold, grade in gpa_to_grade_mapping:\n            if gpa >= threshold:\n                return grade\n        # If the GPA is somehow not matched, return E as a default\n        return 'E'\n    \n    # Create a list to hold the letter grades\n    letter_grades = []\n    \n    # Iterate over each GPA in the grades list\n    for gpa in grades:\n        letter_grade = get_letter_grade(gpa)\n        letter_grades.append(letter_grade)\n    \n    return letter_grades\n\n# Example usage\nprint(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]))  # Output: ['A+', 'B', 'C-', 'C', 'A-']"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Edge case: if the list has fewer than 2 distinct elements, there's no 2nd smallest\n    if len(lst) < 2:\n        return None\n\n    # Use a set to eliminate duplicates, then sort and retrieve the second smallest\n    unique_elements = sorted(set(lst))\n\n    # Check again if there are fewer than 2 unique elements after removing duplicates\n    if len(unique_elements) < 2:\n        return None\n\n    # The second element in the list of unique, sorted elements is the 2nd smallest\n    return unique_elements[1]\n\n# Test cases\nprint(next_smallest([1, 2, 3, 4, 5]))  # Should output 2\nprint(next_smallest([5, 1, 4, 3, 2]))  # Should output 2\nprint(next_smallest([]))               # Should output None\nprint(next_smallest([1, 1]))           # Should output None\nprint(next_smallest([7, 7, 5, 5, 3, 2]))  # Should output 3\nprint(next_smallest([1, 3, 1, 2, 2]))  # Should output 2"}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    \n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    \n    # Extract the unit digits using modulo operation.\n    # Using abs() to handle negative numbers correctly\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    \n    # Return the product of the unit digits\n    return unit_a * unit_b\n\n# Example test cases\nprint(multiply(148, 412))  # Expected output: 16\nprint(multiply(19, 28))    # Expected output: 72\nprint(multiply(2020, 1851)) # Expected output: 0\nprint(multiply(14, -15))    # Expected output: 20"}
{"task_id": "HumanEval/82", "completion": "def prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise.\n    Examples:\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    def is_prime(n):\n        \"\"\"Helper function to determine if a number is prime.\n        A prime number is a natural number greater than 1 that has no positive \n        divisors other than 1 and itself.\n        \"\"\"\n        \n        # Edge cases\n        if n <= 1:\n            return False\n        if n == 2:\n            return True  # 2 is the only even prime number\n        \n        # Check for even number greater than 2\n        if n % 2 == 0:\n            return False\n        \n        # Check for factors from 3 to sqrt(n)\n        i = 3\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += 2\n        \n        return True\n    \n    length = len(string)\n    return is_prime(length)\n\n# Example function calls to illustrate the functionality\nprint(prime_length('Hello'))    # True\nprint(prime_length('abcdcba'))  # True\nprint(prime_length('kittens'))  # True\nprint(prime_length('orange'))   # False\nprint(prime_length(''))         # False (Edge case: empty string)\nprint(prime_length('a'))        # False (Edge case: single character)"}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    \n    # Edge case: if S is empty, there are no sentences and thus no boredom\n    if not S:\n        return 0\n\n    # List of sentence-ending punctuation marks\n    delimiters = {'.', '!', '?'}\n\n    # Split the string into sentences based on the delimiters\n    sentences = []\n    start = 0\n    for index, char in enumerate(S):\n        if char in delimiters:\n            # Extract the sentence, strip any leading/trailing whitespace\n            sentence = S[start:index].strip()\n            if sentence:  # Only add non-empty sentences\n                sentences.append(sentence)\n            start = index + 1  # Start index for the next sentence\n\n    # Add the last sentence part if there's any left after the final delimiter\n    last_sentence = S[start:].strip()\n    if last_sentence:\n        sentences.append(last_sentence)\n\n    # Count sentences starting with \"I\"\n    boredom_count = sum(1 for sentence in sentences if sentence.startswith(\"I\"))\n\n    return boredom_count\n\n# Test cases to clarify the implementation\nassert is_bored(\"Hello world\") == 0\nassert is_bored(\"The sky is blue. The sun is shining. I love this weather\") == 1\nassert is_bored(\"I am happy. Are you happy? You are happy!\") == 1\nassert is_bored(\"\") == 0\nassert is_bored(\"It's great. It is.\") == 0\n\n# Edge cases\nassert is_bored(\"I. I! I?\") == 3\nassert is_bored(\"I .\") == 1\nassert is_bored(\"Hello. I . Hi. I.\") == 2\nassert is_bored(\"I\") == 1\n"}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    \n    # Set of uppercase vowels for quick lookup\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    \n    # Initialize count to 0\n    count = 0\n    \n    # Loop over the string with step 2 to check only even indices\n    for i in range(0, len(s), 2):\n        # If the character at the current index is an uppercase vowel, increment the count\n        if s[i] in uppercase_vowels:\n            count += 1\n    \n    return count\n\n# Example test cases\nprint(count_upper('aBCdEf'))  # Output: 1\nprint(count_upper('abcdefg'))  # Output: 0\nprint(count_upper('dBBE'))  # Output: 0"}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n    '''\n    \n    # Check if all inputs are integers\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        return False\n    \n    # Check if one number is the sum of the other two\n    return x == y + z or y == x + z or z == x + y\n\n# Test cases\nprint(any_int(5, 2, 7))  # \u279e True\nprint(any_int(3, 2, 2))  # \u279e False\nprint(any_int(3, -2, 1)) # \u279e True\nprint(any_int(3.6, -2.2, 2)) # \u279e False"}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(d):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False if the given dictionary is empty.\n\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    # Check if the dictionary is empty\n    if not d:\n        return False\n\n    # Initialize flags to check for lowercase and uppercase keys\n    is_all_lower = True\n    is_all_upper = True\n\n    # Iterate through all keys in the dictionary\n    for key in d.keys():\n        # Check if the key is a string\n        if not isinstance(key, str):\n            return False\n        # Update flags based on the case of the key\n        if key.islower():\n            is_all_upper = False\n        elif key.isupper():\n            is_all_lower = False\n        else:\n            # If the key is neither all lower nor all upper, return False\n            return False\n    \n    # Return True if all keys are either lower case or upper case\n    return is_all_lower or is_all_upper\n\n# Example cases\nassert check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) == True\nassert check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) == False\nassert check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) == False\nassert check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False\nassert check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True\nassert check_dict_case({}) == False\n"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n\n    def shift_vowel(ch):\n        # Helper function to replace vowels with the letter 2 places ahead\n        vowels = 'aeiou'\n        vowel_shift = {v: chr((ord(v) + 2 - ord('a')) % 26 + ord('a')) for v in vowels}\n        vowel_shift.update({v.upper(): chr((ord(v.upper()) + 2 - ord('A')) % 26 + ord('A')) for v in vowels})\n        return vowel_shift.get(ch, ch)\n    \n    # Initialize the result list for better performance compared to string concatenation\n    result = []\n    \n    # Swap case and replace vowels in a single pass\n    for char in message:\n        swapped_char = char.swapcase()  # Swap case\n        encoded_char = shift_vowel(swapped_char)  # Replace vowel if needed\n        result.append(encoded_char)  # Collect the modified character\n\n    return ''.join(result)  # Join the list into a resulting string\n\n# Examples\nprint(encode('test'))  # 'TGST'\nprint(encode('This is a message'))  # 'tHKS KS C MGSSCGG'\n\n# Edge cases\nprint(encode('A'))  # 'C'\nprint(encode('eIoU'))  # 'Gkqw'\nprint(encode('bcdfg'))  # 'BCDFG'"}
{"task_id": "HumanEval/101", "completion": "def words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n\n    # Strip leading and trailing whitespace for clean input processing\n    s = s.strip()\n\n    # Initialize a list to hold the resulting words\n    words = []\n\n    # Initialize a current word buffer\n    current_word = []\n\n    # Iterate over each character in the string\n    for char in s:\n        # If the character is a space or a comma, we've reached a word boundary\n        if char == ' ' or char == ',':\n            # If the current buffer is not empty, convert it to a word and add to the list\n            if current_word:\n                words.append(''.join(current_word))\n                current_word = []\n        else:\n            # If it's a valid character, add to buffer\n            current_word.append(char)\n\n    # If there's any remaining word in buffer, add it to the list\n    if current_word:\n        words.append(''.join(current_word))\n\n    return words\n\n# Example usages:\nprint(words_string(\"Hi, my name is John\"))  # Should output: ['Hi', 'my', 'name', 'is', 'John']\nprint(words_string(\"One, two, three, four, five, six\"))  # Should output: ['One', 'two', 'three', 'four', 'five', 'six']"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    # Define a dictionary to map integers to their corresponding names\n    num_to_name = {\n        1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\",\n        6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n    }\n    \n    # Filter the list to include only integers between 1 and 9 (inclusive)\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map the digits to their corresponding names\n    result = [num_to_name[num] for num in reversed_arr]\n    \n    return result\n\n# Example cases\nprint(by_length([2, 1, 1, 4, 5, 8, 2, 3]))    # Expected: ['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']\nprint(by_length([]))                         # Expected: []\nprint(by_length([1, -1, 55]))                # Expected: ['One']"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    \"\"\"\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n\n    # Ensure x is the smaller and y is the larger number\n    if x > y:\n        return -1\n\n    # Adjust y to be the largest even number in the range\n    if y % 2 != 0:\n        y -= 1\n\n    # If after adjustment y is less than x, it means no even number in the range\n    if y < x:\n        return -1\n\n    # Since we need the largest even number in the range, returning y is enough\n    return y\n\n# Example usage:\n# choose_num(12, 15) should return 14\n# choose_num(13, 12) should return -1\n# Additional examples:\n# choose_num(7, 18) should return 18\n# choose_num(8, 20) should return 20"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    # Split the input string based on spaces\n    words = s.split(' ')\n    \n    # Process each word: sort the characters in ascending order\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words with a single space character\n    result = ' '.join(sorted_words)\n    \n    return result\n\n# Test cases with edge cases and normal examples\nif __name__ == \"__main__\":\n    print(anti_shuffle('Hi'))  # Should return \"Hi\" (no modification as it's already sorted)\n    print(anti_shuffle('hello'))  # Should return \"ehllo\" (sorted characters)\n    print(anti_shuffle('Hello World!!!'))  # Should return \"Hello !!!Wdlor\" (keeps spaces intact)\n\n    # Additional test cases\n    print(anti_shuffle('a'))  # Single character, should return \"a\"\n    print(anti_shuffle(''))  # Empty string, should return \"\"\n    print(anti_shuffle('a a'))  # Two single characters with space, should return \"a a\"\n    print(anti_shuffle('rusty nail'))  # Should return \"rstu ailm\" (sorted each word)\n    print(anti_shuffle('  spaces  '))  # With leading and trailing spaces, should keep them \"  acepss  \"\n\n    # Performance consideration\n    # Testing a large string with repeated words and spaces\n    large_test = \"big test \" * 1000\n    print(anti_shuffle(large_test))  # Should return sorted characters for each word repeatedly"}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    \"\"\"\n    Implement a function that takes a non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    \n    For example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n\n    def is_prime(num):\n        \"\"\"Check if a number is a prime number.\"\"\"\n        if num <= 1:\n            return False\n        if num == 2: # 2 is the only even prime number\n            return True\n        if num % 2 == 0: # eliminate all other even numbers\n            return False\n        limit = int(num ** 0.5) + 1\n        for i in range(3, limit, 2):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n\n    return primes\n\n# Testing the function with example cases\nprint(count_up_to(5))    # => [2, 3]\nprint(count_up_to(11))   # => [2, 3, 5, 7]\nprint(count_up_to(0))    # => []\nprint(count_up_to(20))   # => [2, 3, 5, 7, 11, 13, 17, 19]\nprint(count_up_to(1))    # => []\nprint(count_up_to(18))   # => [2, 3, 5, 7, 11, 13, 17]"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    \n    def is_palindrome(num):\n        # Check if a number is a palindrome by converting it to a string and comparing it with its reverse\n        return str(num) == str(num)[::-1]\n\n    evens = 0\n    odds = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                evens += 1\n            else:\n                odds += 1\n\n    return (evens, odds)\n\n# Example outputs\nprint(even_odd_palindrome(3))  # Output: (1, 2)\nprint(even_odd_palindrome(12)) # Output: (4, 6)"}
{"task_id": "HumanEval/106", "completion": "def factorial(x):\n    \"\"\"Helper function to compute factorial of x.\n    Args:\n        x (int): The number to compute the factorial of.\n    Returns:\n        int: The factorial of x.\n    \"\"\"\n    if x == 0:\n        return 1\n    result = 1\n    for i in range(1, x + 1):\n        result *= i\n    return result\n\ndef sum_to(x):\n    \"\"\"Helper function to compute the sum of numbers from 1 to x.\n    Args:\n        x (int): The upper limit to sum to.\n    Returns:\n        int: The sum of numbers from 1 to x.\n    \"\"\"\n    return x * (x + 1) // 2\n\ndef f(n):\n    \"\"\"Implementation of the function based on the provided docstring.\n    Args:\n        n (int): The size of the list to generate.\n    Returns:\n        list: Generated list with factorials for even indices and sums for odd indices.\n    \"\"\"\n    if n <= 0:\n        return []  # Return an empty list for non-positive n\n\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_to(i))\n    return result\n\n# Test cases to validate the implementation\nprint(f(5))  # Expected: [1, 2, 6, 24, 15]\nprint(f(0))  # Expected: []\nprint(f(-1)) # Expected: []\nprint(f(1))  # Expected: [1]\nprint(f(6))  # Expected: [1, 2, 6, 24, 15, 720]"}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting.\n    You will sort the array in ascending order if the sum of the first and last index values is odd,\n    or sort it in descending order if the sum of the first and last index values is even.\n\n    Note:\n    * Don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    # Check for empty or single-element list which do not need sorting\n    if not array or len(array) == 1:\n        return array[:]\n\n    # Calculate the sum of the first and last elements in the array\n    first_last_sum = array[0] + array[-1]\n\n    # Determine sort order based on the sum being even or odd\n    if first_last_sum % 2 == 0:\n        # Even sum: Sort in descending order\n        sorted_array = sorted(array, reverse=True)\n    else:\n        # Odd sum: Sort in ascending order\n        sorted_array = sorted(array)\n\n    return sorted_array\n\n# Test cases to illustrate usage\nprint(sort_array([]))           # => []\nprint(sort_array([5]))          # => [5]\nprint(sort_array([2, 4, 3, 0, 1, 5]))    # => [0, 1, 2, 3, 4, 5]\nprint(sort_array([2, 4, 3, 0, 1, 5, 6])) # => [6, 5, 4, 3, 2, 1, 0]"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    \"\"\"\n    Given a list of positive integers x, return a sorted list of all \n    elements that haven't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    def has_even_digit(n):\n        \"\"\"\n        Check if a given number has any even digits.\n        \n        Args:\n        n (int): A positive integer to be checked.\n        \n        Returns:\n        bool: True if `n` contains any even digits, False otherwise.\n        \"\"\"\n        for digit in str(n):  # Convert the number to a string to iterate through digits\n            if int(digit) % 2 == 0:  # Check if the digit is even\n                return True\n        return False\n    \n    # Filter out the numbers which contain any even digits\n    no_even_digit_list = [num for num in x if not has_even_digit(num)]\n    \n    # Sort the final list in increasing order\n    return sorted(no_even_digit_list)\n\n# Example usage and testing the function\nif __name__ == \"__main__\":\n    # Test cases\n    print(unique_digits([15, 33, 1422, 1]))  # Expected output: [1, 15, 33]\n    print(unique_digits([152, 323, 1422, 10]))  # Expected output: []\n    print(unique_digits([71, 135, 799, 24]))  # Additional test case, Expected output: [135, 71, 799]\n    print(unique_digits([]))  # Edge case: Empty list, Expected output: []\n\n# The function `unique_digits` runs in O(n * k) where n is the number of elements in the list x and \n# k is the maximum number of digits in a number. Sorting runs in O(m log m) where m is the number\n# of elements in the filtered list, which should be efficient for reasonable input sizes."}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n\n    def sum_of_digits(num):\n        \"\"\"\n        Helper function to calculate the sum of digits of a number.\n        If the number is negative, its first digit will be negative.\n        \"\"\"\n        is_negative = num < 0\n        num = abs(num)\n        digit_sum = 0\n\n        while num > 0:\n            digit_sum += num % 10\n            num //= 10\n\n        return -digit_sum if is_negative else digit_sum\n\n    count = 0\n\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n\n    return count\n\n# Inline doctests to verify the implementation\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n\n    try:\n        # Convert the input string to a float\n        num = float(value)\n\n        # Split the float into its integer and fractional parts\n        int_part = int(num)\n        fractional_part = num - int_part\n\n        # Handle positive numbers\n        if num > 0:\n            # If the fractional part is exactly 0.5, round away from zero\n            if fractional_part == 0.5:\n                return int_part + 1\n            # Otherwise, use standard rounding\n            else:\n                return round(num)\n        # Handle negative numbers\n        elif num < 0:\n            # If the fractional part is exactly -0.5, round away from zero\n            if fractional_part == -0.5:\n                return int_part - 1\n            # Otherwise, use standard rounding\n            else:\n                return round(num)\n        # If the number is 0, simply return 0\n        else:\n            return 0\n    except ValueError:\n        # In case of invalid input, raise an error\n        raise ValueError('Invalid input: Please enter a valid number as string')\n\n# Test cases\nif __name__ == \"__main__\":\n    print(closest_integer(\"10\"))    # Output: 10\n    print(closest_integer(\"15.3\"))  # Output: 15\n    print(closest_integer(\"14.5\"))  # Output: 15\n    print(closest_integer(\"-14.5\")) # Output: -15\n    print(closest_integer(\"0\"))     # Output: 0\n    print(closest_integer(\"0.5\"))   # Output: 1\n    print(closest_integer(\"-0.5\"))  # Output: -1\n    print(closest_integer(\"999.99\")) # Output: 1000\n    try:\n        print(closest_integer(\"invalid\")) # Should raise ValueError\n    except ValueError as e:\n        print(e)                   # Output: Invalid input: Please enter a valid number as string"}
{"task_id": "HumanEval/111", "completion": "from collections import Counter\n\ndef histogram(test):\n    \"\"\"\n    Given a string representing space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"\n    \n    # Split the input string into individual characters\n    letters = test.split()\n    \n    # Use Counter to count the occurrences of each character\n    counts = Counter(letters)\n    \n    if not counts:\n        return {}\n    \n    # Find the maximum occurrence count\n    max_count = max(counts.values())\n    \n    # Create a dictionary with all characters that have the maximum occurrence count\n    result = {char: count for char, count in counts.items() if count == max_count}\n    \n    return result\n\n# Example usage\nprint(histogram('a b c'))        # Output: {'a': 1, 'b': 1, 'c': 1}\nprint(histogram('a b b a'))      # Output: {'a': 2, 'b': 2}\nprint(histogram('a b c a b'))    # Output: {'a': 2, 'b': 2}\nprint(histogram('b b b b a'))    # Output: {'b': 4}\nprint(histogram(''))             # Output: {}\n"}
{"task_id": "HumanEval/94", "completion": "def skjkasdkd(lst):\n    \"\"\"\n    You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n    \n    def is_prime(n):\n        \"\"\"Checks if a number is a prime number.\"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def sum_of_digits(n):\n        \"\"\"Returns the sum of the digits of a number.\"\"\"\n        total = 0\n        while n > 0:\n            total += n % 10\n            n //= 10\n        return total\n\n    # Filter the list to get all prime numbers\n    prime_numbers = [num for num in lst if is_prime(num)]\n\n    if not prime_numbers:\n        return 0  # Return 0 if there are no prime numbers in the list\n\n    # Find the largest prime number\n    largest_prime = max(prime_numbers)\n\n    # Return the sum of its digits\n    return sum_of_digits(largest_prime)\n\n# Example usage and tests\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))  # Output: 10\nprint(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))  # Output: 25\nprint(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))  # Output: 13\nprint(skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))  # Output: 11\nprint(skjkasdkd([0, 81, 12, 3, 1, 21]))  # Output: 3\nprint(skjkasdkd([0, 8, 1, 2, 1, 7]))  # Output: 7"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    \"\"\"\n    Determines whether it is possible to exchange elements between two lists\n    such that lst1 contains only even numbers. \n   \n    Arguments:\n    lst1 -- the first list of numbers\n    lst2 -- the second list of numbers\n\n    Returns:\n    \"YES\" if it is possible to make lst1 contain only even numbers through\n    exchange with lst2, otherwise \"NO\".\n    \"\"\"\n    # Helper function to check if all elements in a list are even\n    def all_even(lst):\n        return all(x % 2 == 0 for x in lst)\n\n    # If lst1 already consists of only even numbers, no exchange is needed.\n    if all_even(lst1):\n        return \"YES\"\n    \n    # Check if there are enough even numbers in lst2 to replace all odd numbers in lst1\n    even_in_lst2 = [x for x in lst2 if x % 2 == 0]\n    odd_count_in_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # If the count of even numbers in lst2 is at least the count of odd numbers in lst1 then return \"YES\"\n    return \"YES\" if len(even_in_lst2) >= odd_count_in_lst1 else \"NO\"\n\n# Test cases to validate our code\nprint(exchange([1, 2, 3, 4], [1, 2, 3, 4]))  # => \"YES\"\nprint(exchange([1, 2, 3, 4], [1, 5, 3, 4]))  # => \"NO\"\nprint(exchange([2, 4, 6], [1, 5, 3]))        # => \"YES\"\nprint(exchange([1, 1, 1], [2, 2, 2, 2]))     # => \"YES\"\nprint(exchange([1], [1, 3, 5]))              # => \"NO\"\nprint(exchange([1], [2]))                    # => \"YES\""}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    \"\"\"\n    Task\n    We are given two strings s and c, you have to delete all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n    \n    # Convert string c to a set for O(1) average time complexity lookups\n    c_set = set(c)\n\n    # Create a new string by filtering out characters that are in set c_set\n    filtered_s = ''.join(char for char in s if char not in c_set)\n    \n    # Check if the filtered string is a palindrome\n    is_palindrome = filtered_s == filtered_s[::-1]\n\n    return (filtered_s, is_palindrome)\n\n\n# Example edge cases\nassert reverse_delete(\"abcde\", \"ae\") == ('bcd', False)\nassert reverse_delete(\"abcdef\", \"b\") == ('acdef', False)\nassert reverse_delete(\"abcdedcba\", \"ab\") == ('cdedc', True)\nassert reverse_delete(\"\", \"ae\") == ('', True)  # Empty string should be considered a palindrome\nassert reverse_delete(\"a\", \"a\") == ('', True)  # Single character removed, resulting in empty string\nassert reverse_delete(\"a\", \"b\") == ('a', True)  # Single character not removed and itself is a palindrome\nassert reverse_delete(\"aa\", \"b\") == ('aa', True)  # Two characters that are the same\n"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    \"\"\"\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation: It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    \"\"\"\n    \n    # Handle edge case: if the array is empty, return True\n    if not arr:\n        return True\n    \n    n = len(arr)\n    \n    # Create the sorted version of the array\n    sorted_arr = sorted(arr)\n    \n    # Check the array with multiple shifts\n    for shift in range(n):\n        # Perform the right shift by slicing\n        shifted_arr = arr[-shift:] + arr[:-shift]\n        # Check if the current shifted array matches the sorted array\n        if shifted_arr == sorted_arr:\n            return True\n    \n    # If no shifted version matches the sorted array, return False\n    return False\n\n# Examples to test the function\nprint(move_one_ball([3, 4, 5, 1, 2]))  # Should return True\nprint(move_one_ball([3, 5, 4, 1, 2]))  # Should return False"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    # Determine if the starting number is odd or even\n    is_odd = n % 2 != 0\n\n    # Initialize the result list with the first level\n    result = [n]\n\n    # Iterate to generate the required levels\n    for _ in range(1, n):\n        if is_odd:\n            next_level = result[-1] + 2  # next odd number\n        else:\n            next_level = result[-1] + 2  # next even number\n        \n        result.append(next_level)\n\n    return result\n\n# Examples and edge cases\nif __name__ == \"__main__\":\n    # Test cases given in the problem\n    print(make_a_pile(3))  # Expected: [3, 5, 7]\n\n    # Additional test cases\n    print(make_a_pile(1))  # Expected: [1]\n    print(make_a_pile(2))  # Expected: [2, 4]\n    print(make_a_pile(5))  # Expected: [5, 7, 9, 11, 13]\n\n    try:\n        print(make_a_pile(0))  # Expected: ValueError\n    except ValueError as e:\n        print(e)\n\n    try:\n        print(make_a_pile(-3))  # Expected: ValueError\n    except ValueError as e:\n        print(e)"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    import math\n    \n    if not grid or not capacity:\n        return 0\n\n    total_units_of_water = 0\n    \n    # Count all the 1s in the grid\n    for row in grid:\n        total_units_of_water += sum(row)\n    \n    # Calculate the number of times the buckets need to be lowered\n    bucket_lower_count = math.ceil(total_units_of_water / capacity)\n    \n    return bucket_lower_count\n\n# Test cases\nprint(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1))  # Output: 6\nprint(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2))  # Output: 5\nprint(max_fill([[0,0,0], [0,0,0]], 5))  # Output: 0\n\n# Edge case: Empty grid or capacity\nprint(max_fill([], 1))  # Output: 0\nprint(max_fill([[0,0,0], [0,0,0]], 0))  # Output: 0\nprint(max_fill([[0,0,0], [0,0,0]], 1))  # Output: 0"}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n\n    # Check if n is greater than m and return -1 if true\n    if n > m:\n        return -1\n\n    # Calculate the sum of integers from n to m inclusive\n    # Using the arithmetic series sum formula for efficiency\n    sum_n_to_m = (m * (m + 1) - n * (n - 1)) // 2 \n\n    # Calculate the count of integers from n to m inclusive\n    count = m - n + 1\n\n    # Calculate the average\n    avg = sum_n_to_m / count\n\n    # Round the average to the nearest integer\n    rounded_avg = round(avg)\n\n    # Convert the rounded average to binary\n    binary_avg = bin(rounded_avg)\n\n    return binary_avg\n\n# Examples to validate the implementation\nprint(rounded_avg(1, 5))     # => \"0b11\"\nprint(rounded_avg(7, 5))     # => -1\nprint(rounded_avg(10, 20))   # => \"0b1111\"\nprint(rounded_avg(20, 33))   # => \"0b11010\"\nprint(rounded_avg(1, 1))     # => \"0b1\", edge case where n == m\nprint(rounded_avg(1000000, 1000000))  # => \"0b11110100001001000000\", large single number"}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    \n    def is_consonant(c):\n        \"\"\"Helper function to determine if a character is a consonant.\"\"\"\n        return c not in \"aeiouAEIOU\" and c.isalpha()\n\n    def count_consonants(word):\n        \"\"\"Helper function to count consonants in a word.\"\"\"\n        return sum(1 for char in word if is_consonant(char))\n    \n    # Split the string into words\n    words = s.split()\n    \n    # Find words with exactly n consonants\n    result = [word for word in words if count_consonants(word) == n]\n    \n    return result\n\n# Examples for testing the function\nprint(select_words(\"Mary had a little lamb\", 4))  # [\"little\"]\nprint(select_words(\"Mary had a little lamb\", 3))  # [\"Mary\", \"lamb\"]\nprint(select_words(\"simple white space\", 2))      # []\nprint(select_words(\"Hello world\", 4))             # [\"world\"]\nprint(select_words(\"Uncle sam\", 3))               # [\"Uncle\"]"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    \"\"\"\n    You are given a word. Your task is to find the closest vowel that stands between\n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    # Define vowels for easy referencing\n    vowels = \"AEIOUaeiou\"\n\n    # Remove leading and trailing consonants as per the problem statement\n    start, end = 0, len(word) - 1\n\n    # Find the first consonant from the start\n    while start < len(word) and word[start] in vowels:\n        start += 1\n\n    # Find the first consonant from the end\n    while end >= 0 and word[end] in vowels:\n        end -= 1\n\n    # Early exit if start or end overlap (no valid middle section)\n    if start >= end:\n        return \"\"\n\n    # Iterate from right to left, finding the closest vowel between two consonants\n    for i in range(end - 1, start, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            return word[i]\n\n    # Return empty string if no vowel met the criteria\n    return \"\"\n\n# Example outputs\nprint(get_closest_vowel(\"yogurt\"))  # \"u\"\nprint(get_closest_vowel(\"FULL\"))    # \"U\"\nprint(get_closest_vowel(\"quick\"))   # \"\"\nprint(get_closest_vowel(\"ab\"))      # \"\""}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # Handle special case of empty input array\n    if not nums:\n        raise ValueError(\"Input array must be non-empty\")\n\n    # Initialize variables for the current minimum sum and the global minimum sum\n    current_min = nums[0]\n    global_min = nums[0]\n    \n    # Iterate through each element in the array starting from the second element\n    for num in nums[1:]:\n        # Update the current minimum sum by considering the current number alone\n        # or extending the current sub-array to include the current number\n        current_min = min(num, current_min + num)\n        \n        # Update the global minimum sum if the current minimum is smaller\n        global_min = min(global_min, current_min)\n    \n    return global_min\n\n# Example usage\nif __name__ == \"__main__\":\n    print(minSubArraySum([2, 3, 4, 1, 2, 4]))  # Should return 1\n    print(minSubArraySum([-1, -2, -3]))        # Should return -6\n    # Additional test cases\n    print(minSubArraySum([3, -4, 2, -3, -1, 7, -5]))  # Should return -6\n    print(minSubArraySum([-2, -3, -1, -5]))           # Should return -11\n    print(minSubArraySum([2, 3, -4, -2, 1, 4]))       # Should return -6"}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    def count_odds(s):\n        \"\"\"Helper function to count odd digits in a string.\"\"\"\n        return sum(1 for char in s if char in '13579')\n\n    result = []\n    for s in lst:\n        odd_count = count_odds(s)  # Count the number of odd digits\n        # Construct the formatted string by replacing 'i' with the odd_count variable\n        processed_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(processed_str)\n\n    return result\n\n# Example usage and test cases\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases to validate edge cases\n    print(odd_count(['978534678291']))\n    print(odd_count(['579']))\n    print(odd_count(['']))\n    print(odd_count(['24680']))  # All even digits, should return \"0\"\n    print(odd_count(['13151719']))  # All odd digits, count should reflect total number of digits\n"}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        \"\"\"\n        This helper function checks if a given string s has balanced parentheses.\n        It uses a simple counter to track the balance as it iterates over the string.\n        \"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If counter goes negative, it means more ')' than '(' so far\n            if balance < 0:\n                return False\n        # The final balance should be zero for the string to be balanced\n        return balance == 0\n\n    # Get the two input strings\n    str1, str2 = lst\n    \n    # Check both concatenation orders\n    if is_balanced(str1 + str2) or is_balanced(str2 + str1):\n        return 'Yes'\n    else:\n        return 'No'\n\n# Examples for testing\nprint(match_parens(['()(', ')']))  # expected 'Yes'\nprint(match_parens([')', ')']))    # expected 'No'\nprint(match_parens(['(()', ')()'])) # expected 'Yes'\nprint(match_parens([')', '()(']))   # expected 'No'"}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    '''\n    Given a string of words, returns a list of words split on whitespace. \n    If no whitespaces exist in the text, it splits on commas ','. \n    If no commas exist, returns the number of lower-case letters with an odd order in the alphabet.\n    \n    Examples:\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n    \n    # Check if there are whitespaces in the text\n    if ' ' in txt:\n        return txt.split()\n    \n    # Check if there are commas in the text\n    elif ',' in txt:\n        return txt.split(',')\n    \n    # If no whitespace or comma exists, count the number of odd-ordered lower-case letters\n    else:\n        # Initialize counter\n        odd_count = 0\n        for char in txt:\n            # Check if the character is a lowercase letter\n            if 'a' <= char <= 'z':\n                # Calculate the order (0-based index so 'a' is 0)\n                order = ord(char) - ord('a')\n                # Check if the order is odd\n                if order % 2 == 1:\n                    odd_count += 1\n        return odd_count\n\n# Examples\nprint(split_words(\"Hello world!\")) # \u279e [\"Hello\", \"world!\"]\nprint(split_words(\"Hello,world!\")) # \u279e [\"Hello\", \"world!\"]\nprint(split_words(\"abcdef\"))       # \u279e 3"}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n\n    # Edge case: if k is greater than the length of the array, limit k to len(arr)\n    k = min(k, len(arr))\n\n    sum_2_digits = 0  # Initialize the sum of elements with at most two digits\n\n    for i in range(k):\n        element = arr[i]\n        # Check if the element has at most two digits (i.e., lies between -99 and 99)\n        if -99 <= element <= 99:\n            sum_2_digits += element\n    \n    return sum_2_digits\n\n\n# Examples to illustrate the function\n\nprint(add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4))  # Output: 24\nprint(add_elements([10, -5, 123, -45, 90, 100], 5))         # Output: 50\nprint(add_elements([100, 200, 300], 2))                    # Output: 0\nprint(add_elements([-99, -100, 0, 50], 4))                 # Output: -49\nprint(add_elements([50], 1))                               # Output: 50\nprint(add_elements([101, -105, 400], 3))                   # Output: 0"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    odd_numbers = set()  # Use a set to avoid duplicate values\n\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.add(n)\n        n = 3 * n + 1 if n % 2 == 1 else n // 2\n\n    odd_numbers.add(1)  # Ensure 1 is included as it's always the endpoint of the sequence\n    \n    return sorted(odd_numbers) # Return the sorted list\n\n# Example usage\nprint(get_odd_collatz(5))  # Output: [1, 5]"}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    \n    def count_ones(n):\n        \"\"\"Helper function to count the number of '1's in the binary representation of n\"\"\"\n        return bin(n).count('1')\n    \n    if not all(isinstance(i, int) for i in arr):\n        raise ValueError(\"All elements must be integers\")\n    \n    # Filter out non-negative integers\n    non_negative = [x for x in arr if x >= 0]\n    negative = [x for x in arr if x < 0]\n    \n    # Sort non-negative integers based on the number of ones in their binary representation, then by their decimal value\n    non_negative.sort(key=lambda x: (count_ones(x), x))\n    \n    # Sort negative integers in ascending order\n    negative.sort()\n    \n    # Combine the two sorted lists\n    sorted_arr = negative + non_negative\n    \n    return sorted_arr\n\n# Test cases for the function\nif __name__ == \"__main__\":\n    print(sort_array([1, 5, 2, 3, 4]))       # Should output [1, 2, 3, 4, 5]\n    print(sort_array([-2, -3, -4, -5, -6]))  # Should output [-6, -5, -4, -3, -2]\n    print(sort_array([1, 0, 2, 3, 4]))       # Should output [0, 1, 2, 3, 4]\n    print(sort_array([-1, 15, 2, 5]))        # Should output [-1, 2, 5, 15]\n"}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n    # Check if the array is empty\n    if not arr:\n        return None\n\n    # Initialize sum of magnitudes and product of signs\n    magnitude_sum = 0\n    sign_product = 1\n\n    for num in arr:\n        magnitude_sum += abs(num)  # Sum of magnitudes\n        if num == 0:\n            sign_product = 0  # If there is a zero, the sign product is zero\n        elif num > 0:\n            sign_product *= 1  # Positive number has sign 1\n        else:\n            sign_product *= -1  # Negative number has sign -1\n\n    # Return the product of sign_product and magnitude_sum\n    return magnitude_sum * sign_product\n\n# Example usages\nprint(prod_signs([1, 2, 2, -4]))  # Expected output: -9\nprint(prod_signs([0, 1]))         # Expected output: 0\nprint(prod_signs([]))             # Expected output: None"}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    \"\"\"\n    Generates the first n+1 numbers of the Tribonacci sequence.\n\n    Args:\n    n (int): A non-negative integer representing the number of elements to generate.\n\n    Returns:\n    list: A list of the first n+1 numbers in the Tribonacci sequence.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n\n    def tribonacci_value(k):\n        \"\"\"Calculate and memoize the k-th value in the Tribonacci sequence.\"\"\"\n        if k in memo:\n            return memo[k]\n        \n        if k == 1:\n            memo[k] = 3\n        elif k % 2 == 0:\n            memo[k] = 1 + k / 2\n        else:\n            # Ensure the values we depend on have been calculated:\n            memo[k] = tribonacci_value(k - 1) + tribonacci_value(k - 2) + tribonacci_value(k + 1)\n        \n        return memo[k]\n    \n    result = []\n    memo = {}\n\n    for i in range(n + 1):\n        result.append(tribonacci_value(i))\n    \n    return result\n\n# Examples:\nprint(tri(3))  # Result should be [1, 3, 2, 8]\nprint(tri(0))  # Result should be [1]\nprint(tri(1))  # Result should be [1, 3]"}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    # Convert integer to string to iterate through digits\n    str_n = str(n)\n    \n    # Initialize the product as 1 because we are dealing with multiplication\n    product = 1\n    odd_found = False\n    \n    for char in str_n:\n        digit = int(char)\n        if digit % 2 != 0:\n            # Digit is odd, include in product\n            product *= digit\n            odd_found = True\n    \n    # Return 0 if no odd digits are found\n    return product if odd_found else 0\n\n# Examples\nprint(digits(1))   # 1\nprint(digits(4))   # 0\nprint(digits(235)) # 15\nprint(digits(246)) # 0 - edge case where all digits are even\nprint(digits(97531)) # 945 - product of all odd digits "}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n    # Dictionary with maximum days for each month considering February can have 29 days\n    days_in_month = {\n        1: 31, 2: 29, 3: 31, 4: 30, 5: 31, 6: 30, \n        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31\n    }\n\n    # Check if date is empty\n    if not date:\n        return False\n    \n    # Check if date is in mm-dd-yyyy format\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n\n    try:\n        month, day, year = int(parts[0]), int(parts[1]), int(parts[2])\n    except ValueError:\n        # If conversion from string to int fails, it's not a valid date\n        return False\n\n    # Validate month\n    if month < 1 or month > 12:\n        return False\n\n    # Validate day based on the month\n    if day < 1 or day > days_in_month[month]:\n        return False\n    \n    # Additional validation for February in a non-leap year\n    if month == 2 and day == 29:\n        if not (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)):\n            return False\n\n    return True\n\n# Test cases\nassert valid_date('03-11-2000') == True\nassert valid_date('15-01-2012') == False\nassert valid_date('04-0-2040') == False\nassert valid_date('06-04-2020') == True\nassert valid_date('06/04/2020') == False\nassert valid_date('') == False\nassert valid_date('02-29-2020') == True\nassert valid_date('02-29-2019') == False\n"}
{"task_id": "HumanEval/120", "completion": "from heapq import nlargest\n\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    \n    # Edge case: If k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Use `heapq.nlargest` to find the k largest elements efficiently\n    largest_k_elements = nlargest(k, arr)\n    \n    # Return sorted list of the k largest elements\n    return sorted(largest_k_elements)\n\n# Example tests\nprint(maximum([-3, -4, 5], 3))  # Expected: [-4, -3, 5]\nprint(maximum([4, -4, 4], 2))   # Expected: [4, 4]\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))  # Expected: [2]"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    \n    # Ensuring the list is non-empty, according to the problem specification.\n    if not lst:\n        raise ValueError(\"Input list must be non-empty\")\n    \n    result = 0\n    \n    # Iterate through the list, considering only even indices.\n    for i in range(0, len(lst), 2):\n        # Check if the element at the given even index is odd.\n        if lst[i] % 2 != 0:\n            result += lst[i]\n    \n    return result\n    \n# Examples and edge cases for testing\nprint(solution([5, 8, 7, 1]))  # Output: 12\nprint(solution([3, 3, 3, 3, 3]))  # Output: 9\nprint(solution([30, 13, 24, 321]))  # Output: 0\nprint(solution([1]))  # Output: 1 (single odd number at an even position)\nprint(solution([2]))  # Output: 0 (single even number at an even position)\nprint(solution([-1, -3, -5, -7]))  # Output: -6 (negative odd numbers included in the sum)"}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                # if we find ']', pop corresponding '[' from the stack\n                stack.pop()\n            else:\n                return False # unbalanced, more ']' than '['\n\n    # Check if there's a remaining '[' in the stack\n    # which indicates at least one nested structure was possible\n    if stack:\n        return True\n    return False\n\n\n# Test cases\nprint(is_nested('[[]]'))  # True\nprint(is_nested('[]]]]]]][[[[[]'))  # False\nprint(is_nested('[][]'))  # False\nprint(is_nested('[]'))  # False\nprint(is_nested('[[][]]'))  # True\nprint(is_nested('[[]][['))  # True"}
{"task_id": "HumanEval/139", "completion": "import math\n\ndef special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    # Validate input: n must be a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    # Initialize result as 1 since we are multiplying\n    result = 1\n\n    # Compute the special factorial by iterating from n down to 1\n    for i in range(1, n+1):\n        result *= math.factorial(i)\n    \n    return result\n\n# Sample test case\nprint(special_factorial(4))  # Expected output: 288"}
{"task_id": "HumanEval/127", "completion": "def is_prime(n):\n    \"\"\"Helper function to determine if a number is prime.\n    Args:\n    n (int): The number to check for primality.\n    \n    Returns:\n    bool: True if n is a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return True  # 2 and 3 are prime numbers\n\n    if n % 2 == 0 or n % 3 == 0:\n        return False  # Eliminate multiples of 2 and 3\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False  # Eliminate other multiples\n        i += 6\n    return True\n\ndef intersection(interval1, interval2):\n    \"\"\"Determine if the length of the intersection of two intervals is a prime number.\n    Args:\n    interval1 (tuple): First interval as a pair of integers (start, end).\n    interval2 (tuple): Second interval as a pair of integers (start, end).\n    \n    Returns:\n    str: \"YES\" if the length of the intersection is a prime number, \"NO\" otherwise.\n    \"\"\"\n    # Extract start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Calculate the start and end of the intersection\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n\n    # If there's no intersection, the intersection's length is zero or negative\n    if intersection_start > intersection_end:\n        return \"NO\"\n\n    # Length of the intersection\n    intersection_length = intersection_end - intersection_start\n\n    # Check if the length of the intersection is a prime number\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test cases\nprint(intersection((1, 2), (2, 3)))  # Expected output: \"NO\"\nprint(intersection((-1, 1), (0, 4)))  # Expected output: \"NO\"\nprint(intersection((-3, -1), (-5, 5)))  # Expected output: \"YES\""}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    # Iterate through the array from the second element to the end.\n    for i in range(1, len(arr)):\n        # Check if the current element is less than the previous element.\n        if arr[i] < arr[i - 1]:\n            # If yes, return the current index as it is the largest one found.\n            return i\n    # If no such element exists, return -1.\n    return -1\n\n# Example Usages\nprint(can_arrange([1, 2, 4, 3, 5]))  # Output: 3\nprint(can_arrange([1, 2, 3]))        # Output: -1\nprint(can_arrange([5, 4, 3, 2, 1]))  # Output: 1\nprint(can_arrange([1]))              # Output: -1\nprint(can_arrange([]))               # Output: -1"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples:\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n\n    # Early return for lists with one or zero elements\n    if len(lst) <= 1:\n        return True  # Every single-element or empty list is trivially sorted\n\n    # Dictionary to count occurrences of each number\n    counts = {}\n\n    # Traverse through list\n    for i in range(len(lst)):\n        # Count occurrences of each number\n        if lst[i] in counts:\n            counts[lst[i]] += 1\n        else:\n            counts[lst[i]] = 1\n\n        # If any number appears more than twice, return False\n        if counts[lst[i]] > 2:\n            return False\n\n        # Compare current element with the next one to check sorting\n        if i < len(lst) - 1 and lst[i] > lst[i + 1]:\n            return False\n\n    return True\n\n# Example test cases\nprint(is_sorted([5]))  # Should return True\nprint(is_sorted([1, 2, 3, 4, 5]))  # Should return True\nprint(is_sorted([1, 3, 2, 4, 5]))  # Should return False\nprint(is_sorted([1, 2, 3, 4, 5, 6]))  # Should return True\nprint(is_sorted([1, 2, 2, 3, 3, 4]))  # Should return True\nprint(is_sorted([1, 2, 2, 2, 3, 4]))  # Should return False"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n    \n    # Initialize the variables for largest negative and smallest positive as None\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0:\n            # If current negative number is larger than the current largest_negative or if largest_negative is None\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            # If current positive number is smaller than the current smallest_positive or if smallest_positive is None\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n    \n    return (largest_negative, smallest_positive)\n\n# Example use:\nprint(largest_smallest_integers([2, 4, 1, 3, 5, 7]))  # Output should be (None, 1)\nprint(largest_smallest_integers([]))  # Output should be (None, None)\nprint(largest_smallest_integers([0]))  # Output should be (None, None)"}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n    '''\n\n    # Strip trailing spaces to manage the integrity of words and their counts\n    stripped_txt = txt.rstrip()\n    \n    # If the stripped string is empty, return False\n    if not stripped_txt:\n        return False\n\n    # Check if the last character of the stripped text is an alphabetical character\n    if stripped_txt[-1].isalpha():\n        # Split the stripped text into a list of words\n        words = stripped_txt.split()\n\n        # Check if the last word in the list consists of a single character\n        if len(words[-1]) == 1:\n            return True\n            \n    return False\n\n# Test cases\nprint(check_if_last_char_is_a_letter(\"apple pie\"))    # \u279e False\nprint(check_if_last_char_is_a_letter(\"apple pi e\"))   # \u279e True\nprint(check_if_last_char_is_a_letter(\"apple pi e \"))  # \u279e False\nprint(check_if_last_char_is_a_letter(\"\"))             # \u279e False\nprint(check_if_last_char_is_a_letter(\"a\"))            # \u279e True\nprint(check_if_last_char_is_a_letter(\" \"))            # \u279e False\nprint(check_if_last_char_is_a_letter(\"e \"))           # \u279e False\nprint(check_if_last_char_is_a_letter(\"word e\"))       # \u279e True\nprint(check_if_last_char_is_a_letter(\"word   e   \"))  # \u279e False"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    \n    def parse_string_number(s):\n        \"\"\"\n        Helper function to parse a string number that may use either '.' or ',' as a decimal separator.\n        \"\"\"\n        if ',' in s:\n            s = s.replace(',', '.')\n        try:\n            return float(s)\n        except ValueError:\n            return None\n\n    # Handle parsing of the inputs if they are strings\n    if isinstance(a, str):\n        parsed_a = parse_string_number(a)\n    else:\n        parsed_a = a\n    \n    if isinstance(b, str):\n        parsed_b = parse_string_number(b)\n    else:\n        parsed_b = b\n    \n    # Proper error handling in case a string couldn't be parsed\n    if parsed_a is None or parsed_b is None:\n        raise ValueError(\"One of the input numbers is not in a recognizable format\")\n\n    # Compare the values and decide the return value\n    if parsed_a > parsed_b:\n        return a  # return in original format\n    elif parsed_b > parsed_a:\n        return b  # return in original format\n    else:\n        return None  # values are equal\n\n# Test cases\nprint(compare_one(1, 2.5))         # \u279e 2.5\nprint(compare_one(1, \"2,3\"))       # \u279e \"2,3\"\nprint(compare_one(\"5,1\", \"6\"))     # \u279e \"6\"\nprint(compare_one(\"1\", 1))         # \u279e None"}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    \n    # Handle empty list edge case\n    if not lst:\n        return 0\n    \n    # Initialize the sum\n    total = 0\n    \n    # Iterate through the list, using enumerate to get both index and value\n    for idx, val in enumerate(lst):\n        if idx % 3 == 0:\n            total += val ** 2\n        elif idx % 4 == 0:\n            total += val ** 3\n        else:\n            total += val\n    \n    return total\n\n# Example test cases\nprint(sum_squares([1, 2, 3]))  # Expected output: 6\nprint(sum_squares([]))  # Expected output: 0\nprint(sum_squares([-1, -5, 2, -1, -5]))  # Expected output: -126"}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    \n    # Helper function to calculate the sum of the digits of a number\n    def sum_of_digits(n):\n        # Take absolute value to ignore the sign while summing digits\n        return sum(int(digit) for digit in str(abs(n)))\n\n    # Sort based on the tuple (sum_of_digits value, index)\n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n\n\n# Examples and edge cases provided in docstring\nprint(order_by_points([1, 11, -1, -11, -12]))  # Output: [-1, -11, 1, -12, 11]\nprint(order_by_points([]))  # Output: []"}
{"task_id": "HumanEval/129", "completion": "import heapq\n\ndef minPath(grid, k):\n    def neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                yield nx, ny\n\n    N = len(grid)\n    min_path = None\n    pq = []\n\n    # Initialize priority queue with starting points\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)]))\n\n    while pq:\n        current_value, path = heapq.heappop(pq)\n        \n        if len(path) == k:\n            result = [grid[x][y] for x, y in path]\n            if min_path is None or result < min_path:\n                min_path = result\n            continue\n        \n        x, y = path[-1]\n        for nx, ny in neighbors(x, y):\n            new_path = path + [(nx, ny)]\n            new_value = current_value + grid[nx][ny]\n            heapq.heappush(pq, (new_value, new_path))\n    \n    return min_path\n  \n# Examples\nprint(minPath([[1,2,3], [4,5,6], [7,8,9]], 3))  # Output: [1, 2, 1]\nprint(minPath([[5,9,3], [4,1,6], [7,8,2]], 1))  # Output: [1]"}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n    \"\"\"\n    Simplifies the product of two fractions and checks if the result is a whole number.\n    \n    Args:\n    x (str): A string representation of a fraction (<numerator>/<denominator>).\n    n (str): A string representation of a fraction (<numerator>/<denominator>).\n    \n    Returns:\n    bool: True if the product is a whole number, False otherwise.\n    \"\"\"\n    \n    def parse_fraction(fraction):\n        \"\"\"Helper function to parse a string fraction into numerator and denominator.\"\"\"\n        num, denom = fraction.split('/')\n        return int(num), int(denom)\n    \n    # Parse the fractions\n    num_x, denom_x = parse_fraction(x)\n    num_n, denom_n = parse_fraction(n)\n    \n    # Compute the product of the fractions\n    product_numerator = num_x * num_n\n    product_denominator = denom_x * denom_n\n    \n    # Check if the product is a whole number\n    if product_numerator % product_denominator == 0:\n        return True\n    else:\n        return False\n\n# Example test cases\nprint(simplify(\"1/5\", \"5/1\"))  # True\nprint(simplify(\"1/6\", \"2/1\"))  # False\nprint(simplify(\"7/10\", \"10/2\"))  # False"}
{"task_id": "HumanEval/140", "completion": "import re\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n\n    # Define the regex pattern to match consecutive spaces (>2) or individual spaces\n    pattern = re.compile(r'(\\s{2,}|\\s)')\n\n    # Define a replacement function to decide between '_' and '-'\n    def replacer(match):\n        match_str = match.group(0)\n        if len(match_str) > 2:\n            return '-'  # Replace consecutive spaces with '-'\n        return '_'      # Replace single spaces with '_'\n\n    # Use re.sub with the replacement function\n    result = re.sub(pattern, replacer, text)\n    \n    return result\n\n# Test Examples\nprint(fix_spaces(\"Example\"))         # \"Example\"\nprint(fix_spaces(\"Example 1\"))       # \"Example_1\"\nprint(fix_spaces(\" Example 2\"))      # \"_Example_2\"\nprint(fix_spaces(\" Example   3\"))    # \"_Example-3\"\nprint(fix_spaces(\"  Example    4\"))  # \"-Example-4\"\nprint(fix_spaces(\"Example\"))         # \"Example\""}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n    Example:\n    >>> is_equal_to_sum_even(4)\n    False\n    >>> is_equal_to_sum_even(6)\n    False\n    >>> is_equal_to_sum_even(8)\n    True\n    \"\"\"\n\n    # The smallest sum of 4 positive even numbers is 2+2+2+2 = 8\n    if n < 8:\n        return False\n    \n    # Any multiple of 2 greater is an even number\n    # The sum of 4 even numbers will also be even\n    # Any even number >= 8 can be written as the sum of 4 positive even numbers\n    return n % 2 == 0\n\n# Test examples\nif __name__ == \"__main__\":\n    test_cases = [4, 6, 8, 10, 12, 14, 16, 18, 20, 100, 102, 23]\n    results = [is_equal_to_sum_even(tc) for tc in test_cases]\n    print(results)"}
{"task_id": "HumanEval/141", "completion": "import re\n\ndef file_name_check(file_name):\n    \"\"\"\n    Checks if the given file name is valid based on specific criteria:\n    - No more than three digits in the file's name.\n    - Contains exactly one dot '.'.\n    - The substring before the dot should not be empty and start with a latin alphabet letter.\n    - The substring after the dot should be one of: ['txt', 'exe', 'dll'].\n\n    Args:\n    file_name (str): The name of the file to check.\n\n    Returns:\n    str: 'Yes' if the file name is valid, 'No' otherwise.\n\n    Examples:\n    file_name_check(\"example.txt\") => 'Yes'\n    file_name_check(\"1example.dll\") => 'No'\n    \"\"\"\n    # Define a regex pattern to match the valid file name criteria\n    pattern = r'^[a-zA-Z][^0-9]*([0-9][^0-9]*){0,3}\\.(txt|exe|dll)$'\n    \n    # Use re.fullmatch to check if the entire string conforms to the pattern\n    if not re.fullmatch(pattern, file_name):\n        return \"No\"\n    \n    # Ensure that the substring before the dot contains no more than 3 digits\n    before_dot = file_name.split('.')[0]\n    if sum(char.isdigit() for char in before_dot) > 3:\n        return \"No\"\n\n    return \"Yes\"\n\n# Examples to validate the implementation\nprint(file_name_check(\"example.txt\"))  # => 'Yes'\nprint(file_name_check(\"1example.dll\"))  # => 'No'\nprint(file_name_check(\"1234example.txt\"))  # => 'No'\nprint(file_name_check(\"examp.le.txt\"))  # => 'No'\nprint(file_name_check(\"exampletxtexe.dll\"))  # => 'Yes'"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''\n    \n    # Check if the input list is empty, return 0\n    if not lst:\n        return 0\n\n    # Initialize the sum of squares\n    sum_of_squares = 0\n    \n    for num in lst:\n        # Validate that the number is an integer, non-negative, and odd\n        if isinstance(num, int) and num >= 0 and num % 2 != 0:\n            # Add the square of the number to the sum\n            sum_of_squares += num ** 2\n    \n    return sum_of_squares  # Return the final sum of squares\n\n# Example test cases\nprint(double_the_difference([1, 3, 2, 0]))  # Should print 10\nprint(double_the_difference([-1, -2, 0]))   # Should print 0\nprint(double_the_difference([9, -2]))       # Should print 81\nprint(double_the_difference([0]))           # Should print 0"}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n\n    def is_odd_digit(digit):\n        \"\"\"Helper function to check if a digit is odd.\"\"\"\n        return digit in {1, 3, 5, 7, 9}\n\n    def first_and_last_digits_are_odd(num):\n        \"\"\"Helper function to check if the first and last digits of the number are odd.\"\"\"\n        str_num = str(abs(num))  # Consider the absolute value of the number to handle negative numbers\n        first_digit = int(str_num[0])\n        last_digit = int(str_num[-1])\n        return is_odd_digit(first_digit) and is_odd_digit(last_digit)\n\n    # Main processing of the numbers\n    count = 0\n    for num in nums:\n        if num > 10 and first_and_last_digits_are_odd(num):\n            count += 1\n\n    return count\n\n# Example usage\nprint(specialFilter([15, -73, 14, -15]))  # Output: 1 \nprint(specialFilter([33, -2, -3, 45, 21, 109]))  # Output: 2"}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    if n < 3:\n        # If n is less than 3, it's impossible to form any triples\n        return 0\n\n    # Compute the array 'a' based on the formula\n    a = [(i * i - i + 1) % 3 for i in range(1, n + 1)]\n    \n    # Initialize counts of residues\n    count = [0, 0, 0]\n    \n    # Count the occurrences of each residue modulo 3\n    for value in a:\n        count[value] += 1\n    \n    # Number of valid triples:\n    result = 0\n    \n    # Triples of the same residue (0,0,0), (1,1,1), (2,2,2)\n    for i in range(3):\n        if count[i] >= 3:\n            result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n    \n    # Triples of different residues (0,1,2)\n    result += count[0] * count[1] * count[2]\n    \n    return result\n\n# Testing the function with the given example\nprint(get_max_triples(5))  # Output: 1"}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have different lengths.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"    \n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length first, then lexicographically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list\n\n# Example test cases\nassert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\nassert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\nassert sorted_list_sum([\"abcd\", \"bd\", \"ab\", \"b\", \"c\"]) == [\"ab\", \"bd\", \"abcd\"]\nassert sorted_list_sum([]) == []  # Edge case: empty list\nassert sorted_list_sum([\"\", \"aa\", \"bbbb\", \"ccc\", \"a\"]) == [\"\", \"aa\", \"bbbb\"]\n\n# Explanation of key decisions and assumptions:\n# - Used list comprehension for filtering strings with odd lengths for concise and efficient filtering.\n# - Sorted the list using a custom key: first by length and then lexicographically for strings of the same length.\n# - Assumed that words with zero length (\"\") are also valid and handled as even length.\n# - Considered edge cases such as an empty list or a list with only odd-length strings.\n\n# The overall time complexity of sorting is O(n log n), where n is the number of strings to be sorted."}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    \"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n\n    def rotations(word):\n        \"\"\"Generate all rotations of the given word.\"\"\"\n        return [word[i:] + word[:i] for i in range(len(word))]\n\n    # Check if any rotation of 'b' is a substring in 'a'\n    for rotation in rotations(b):\n        if rotation in a:\n            return True\n\n    return False\n\n# Example Test Cases\nprint(cycpattern_check(\"abcd\", \"abd\"))     # Expected: False\nprint(cycpattern_check(\"hello\", \"ell\"))    # Expected: True\nprint(cycpattern_check(\"whassup\", \"psus\")) # Expected: False\nprint(cycpattern_check(\"abab\", \"baa\"))     # Expected: True\nprint(cycpattern_check(\"efef\", \"eeff\"))    # Expected: False\nprint(cycpattern_check(\"himenss\", \"simen\"))# Expected: True"}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun are \n    Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples:\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n\n    # List of planets in the order of their proximity to the sun\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planet1 and planet2 are valid planets\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n\n    # Find the indices of the given planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Ensure index1 is less than index2 for correct slicing\n    start_index = min(index1, index2) + 1  # +1 to exclude the start planet\n    end_index = max(index1, index2)\n\n    # Return the tuple of planets between the two indices\n    return tuple(planets[start_index:end_index])\n\n# Examples to validate the implementation\nprint(bf(\"Jupiter\", \"Neptune\"))  # Expected Output: (\"Saturn\", \"Uranus\")\nprint(bf(\"Earth\", \"Mercury\"))    # Expected Output: (\"Venus\")\nprint(bf(\"Mercury\", \"Uranus\"))   # Expected Output: (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nprint(bf(\"Pluto\", \"Neptune\"))    # Expected Output: ()\nprint(bf(\"Mars\", \"Mars\"))        # Expected Output: ()"}
{"task_id": "HumanEval/133", "completion": "import math\n\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \n    Parameters:\n    lst (list of floats or ints): The original list of numbers\n    \n    Returns:\n    int: The sum of squared elements, rounded to the nearest upper integer\n    \"\"\"\n    # Initialize sum to zero\n    total_sum = 0\n    \n    # Iterate through the list\n    for num in lst:\n        ceil_value = math.ceil(num)  # Round each number up to the nearest integer\n        total_sum += ceil_value ** 2  # Add the square of the rounded value to the total_sum\n    \n    return total_sum\n\n# Examples and edge cases\nassert sum_squares([1, 2, 3]) == 14  # 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14\nassert sum_squares([1, 4, 9]) == 98  # 1^2 + 4^2 + 9^2 = 1 + 16 + 81 = 98\nassert sum_squares([1, 3, 5, 7]) == 84  # 1^2 + 3^2 + 5^2 + 7^2 = 1 + 9 + 25 + 49 = 84\nassert sum_squares([1.4, 4.2, 0]) == 29  # 2^2 + 5^2 + 0^2 = 4 + 25 + 0 = 29\nassert sum_squares([-2.4, 1, 1]) == 6  # -2.4 -> -2 -> -2^2 + 1^2 + 1^2 = 4 + 1 + 1 = 6\n\n# Edge case: empty list\nassert sum_squares([]) == 0  # Sum of empty list should be 0\n\n# Edge case: list with all negative numbers\nassert sum_squares([-1.2, -3.4, -0.5]) == 11  # -1.2 -> -1; -3.4 -> -3; -0.5 -> 0; -1^2 + -3^2 + 0^2 = 1 + 9 + 0 = 10\n\n# Edge case: large numbers\nassert sum_squares([1000, 0.001, -999.9]) == 1000000001  # Ensure it handles large/small num rounding\n"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    Determine if a person correctly guessed the results of a number of matches.\n    Given two arrays of scores and guesses of equal length, return an array of\n    the same length denoting how far off each guess was. If they guessed\n    correctly, the value is 0, and if not, the value is the absolute difference\n    between the guess and the score.\n\n    Args:\n    - game (list of int): Actual scores.\n    - guess (list of int): Guessed scores.\n\n    Returns:\n    - list of int: Differences between actual scores and guesses.\n    \"\"\"\n\n    # Validate input lengths to ensure both lists are of equal length\n    if len(game) != len(guess):\n        raise ValueError(\"The length of game and guess arrays must be the same\")\n\n    # Calculate the differences using a list comprehension\n    # This ensures O(n) time complexity where n is the length of the arrays\n    difference = [abs(g - s) for s, g in zip(game, guess)]\n    \n    return difference\n\n# Example usage and potential edge case validation\n# All cases provided in the docstring examples\nassert compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3]\nassert compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2]) == [4, 4, 1, 0, 0, 6]\n# Edge cases to test\nassert compare([], []) == []  # Empty arrays case\nassert compare([10], [10]) == [0]  # Single element correct guess\nassert compare([100], [0]) == [100]  # Large difference single element\n"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    \"\"\"\n    You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    \"\"\"\n\n    def calculate_strength(extension):\n        \"\"\"Helper function to calculate the strength of an extension.\"\"\"\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        return cap - sm\n\n    # Check if the list is empty and handle the edge case\n    if not extensions:\n        return f\"{class_name}.\"\n\n    strongest_extension = None\n    max_strength = float('-inf')\n\n    # Iterate over all extensions to find the one with the highest strength\n    for extension in extensions:\n        strength = calculate_strength(extension)\n        # Update if this extension has a higher strength\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n\n    return f\"{class_name}.{strongest_extension}\"\n\n# Example usage:\n# result = Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n# print(result)  # Output: 'my_class.AA'"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n    \"\"\"\n    \n    if not words:\n        return \"\"\n\n    # Initialize the variables to track the word with max unique characters and its count\n    max_word = \"\"\n    max_unique_chars = 0\n    \n    for word in words:\n        # Calculate unique characters in the current word\n        unique_chars = len(set(word))\n        \n        # Compare and update max_word based on unique characters count and lexicographical order\n        if unique_chars > max_unique_chars or (unique_chars == max_unique_chars and word < max_word):\n            max_unique_chars = unique_chars\n            max_word = word\n\n    return max_word\n\n\n# Test cases\nprint(find_max([\"name\", \"of\", \"string\"]))  # \"string\"\nprint(find_max([\"name\", \"enam\", \"game\"]))  # \"enam\"\nprint(find_max([\"aaaaaaa\", \"bb\", \"cc\"]))  # \"aaaaaaa\"\nprint(find_max([\"a\", \"b\", \"c\"]))  # \"a\" (all have 1 unique char, \"a\" is lexicographically first)\nprint(find_max([]))  # \"\" (empty input list case)"}
{"task_id": "HumanEval/143", "completion": "import math\n\ndef is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n    :param n: The number to check.\n    :return: True if n is prime, else False.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef words_in_sentence(sentence):\n    \"\"\"\n    Returns a string that contains the words from the original sentence,\n    whose lengths are prime numbers, in the same order.\n    \n    :param sentence: Input sentence as a string.\n    :return: Filtered sentence as a string with words having prime lengths.\n    \"\"\"\n    # Helper function to check if a number is prime\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        for i in range(5, int(math.sqrt(n)) + 1, 6):\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n        return True\n\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter the words whose lengths are prime\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    \n    # Join the filtered words into a result string\n    return ' '.join(prime_length_words)\n\n# Example Usage\nprint(words_in_sentence(\"This is a test\"))        # Output: \"is\"\nprint(words_in_sentence(\"lets go for swimming\"))  # Output: \"go for\"\nprint(words_in_sentence(\"hello world\"))           # Output: \"\"\nprint(words_in_sentence(\"be extraordinary\"))      # Output: \"be extraordinary\""}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"\n    Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n\n    # Convert the number to its absolute value to handle negative numbers\n    num = abs(num)\n\n    # Single digit edge case check\n    if num == 0:\n        return (1, 0)  # Zero is even\n\n    # Iterate over each digit in the number\n    while num > 0:\n        digit = num % 10  # Get the last digit\n        if digit % 2 == 0:\n            even_count += 1  # Increment even counter\n        else:\n            odd_count += 1  # Increment odd counter\n        num = num // 10  # Remove the last digit\n    \n    # Return the final counts as a tuple\n    return (even_count, odd_count)\n\n# Testing some edge and typical cases\nprint(even_odd_count(-12))  # (1, 1) - One even (-2) and one odd (1)\nprint(even_odd_count(123))  # (1, 2) - One even (2) and two odd (1, 3)\nprint(even_odd_count(0))    # (1, 0) - Zero is considered an even number\nprint(even_odd_count(111))  # (0, 3) - All digits are odd\nprint(even_odd_count(222))  # (3, 0) - All digits are even\nprint(even_odd_count(13579))# (0, 5) - All digits are odd\nprint(even_odd_count(24680))# (5, 0) - All digits are even\n"}
{"task_id": "HumanEval/150", "completion": "def is_prime(num):\n    \"\"\"Returns True if num is a prime number, otherwise False.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other\n    than 1 and itself.\n    \n    Algorithm:\n    - Special case for num <= 1 (not prime)\n    - Check from 2 to sqrt(num). If any divisor is found, num is not prime.\n    \n    This algorithm is efficient for prime checking with O(sqrt(n)) complexity.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True  # 2 and 3 are prime numbers\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef x_or_y(n, x, y):\n    \"\"\"Returns x if n is a prime number, otherwise returns y.\n    \n    Args:\n    n (int): The number to check for primality.\n    x (any): The value to return if n is prime.\n    y (any): The value to return if n is not prime.\n    \n    Returns:\n    any: x if n is a prime number, otherwise y.\n    \n    Example:\n    >>> x_or_y(7, 34, 12)\n    34\n    >>> x_or_y(15, 8, 5)\n    5\n    \"\"\"\n\n    # Check if n is a prime number\n    if is_prime(n):\n        return x\n    else:\n        return y\n\n# Example cases ran as part of a self-test\nif __name__ == \"__main__\":\n    print(x_or_y(7, 34, 12))  # Output: 34\n    print(x_or_y(15, 8, 5))   # Output: 5\n    print(x_or_y(2, 'a', 'b'))  # Output: 'a'\n    print(x_or_y(1, 'a', 'b'))  # Output: 'b'\n    print(x_or_y(0, 'test', 'fail'))  # Output: 'fail'"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    \n    Examples:\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    \n    # Check if the string contains any letters\n    contains_letter = any(char.isalpha() for char in s)\n    \n    if contains_letter:\n        # If the string contains letters, reverse their case\n        result = ''.join(\n            char.upper() if char.islower() else char.lower() if char.isupper() else char\n            for char in s\n        )\n    else:\n        # If the string contains no letters, simply reverse the string\n        result = s[::-1]\n    \n    return result"}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebraic \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"\n\n    # Check for basic constraints to avoid errors\n    if not operator or not operand or len(operand) != len(operator) + 1:\n        raise ValueError(\"Invalid input. Check the lengths of operator and operand lists.\")\n\n    # Initialize the expression with the first operand\n    expression = str(operand[0])\n\n    # Loop through both lists to build the expression\n    for op, num in zip(operator, operand[1:]):\n        expression += f\" {op} {num}\"\n\n    # Evaluate the built expression\n    result = eval(expression)\n\n    return result\n\n# Examples to illustrate the work\nexample_operator = ['+', '*', '-']\nexample_operand = [2, 3, 4, 5]\nprint(do_algebra(example_operator, example_operand))  # Output should be 9\n\n# Edge cases\ntry:\n    empty_operator = []\n    print(do_algebra(empty_operator, example_operand))  # Should raise ValueError\nexcept ValueError as ve:\n    print(ve)  # Output: Invalid input. Check the lengths of operator and operand lists."}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    You should return an array of [total number of eaten carrots after your meals,\n                                   the number of carrots left after your meals].\n    If there are not enough remaining carrots, you will eat all remaining carrots but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        The number of carrots that you have eaten so far.\n    @need : integer\n        The number of carrots that you need to eat.\n    @remaining : integer\n        The number of remaining carrots that exist in stock.\n    \n    Constraints:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    \n    # Calculate how many more carrots you can realistically eat\n    carrots_to_eat = min(need, remaining)\n    \n    # Calculate the total number of carrots eaten after the meal\n    total_eaten = number + carrots_to_eat\n    \n    # Calculate the number of remaining carrots after the meal\n    remaining_after_meal = remaining - carrots_to_eat\n    \n    return [total_eaten, remaining_after_meal]\n\n# Example test cases\nprint(eat(5, 6, 10))  # [11, 4]\nprint(eat(4, 8, 9))   # [12, 1]\nprint(eat(1, 10, 10)) # [11, 0]\nprint(eat(2, 11, 5))  # [7, 0]"}
{"task_id": "HumanEval/162", "completion": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not text:  # Check for either empty string or None\n        return None\n    \n    # Create an md5 hash object\n    md5_hash = hashlib.md5()\n    \n    # Update the hash object with the bytes of the string\n    # Encoding to 'utf-8' to handle any kind of string input\n    md5_hash.update(text.encode('utf-8'))\n    \n    # Return the hexadecimal digest of the hash\n    return md5_hash.hexdigest()\n\n# Demonstrating the function with an example\nprint(string_to_md5(\"Hello world\") == '3e25960a79dbc69b674cd4ec67a72c62')\n\n# You can add more tests below to ensure proper functioning\nassert string_to_md5(\"\") is None, \"Test case for empty string failed\"\nassert string_to_md5(None) is None, \"Test case for None input failed\"\nassert string_to_md5(\"abc\") == '900150983cd24fb0d6963f7d28e17f72', \"Test case for 'abc' failed\""}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    \n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number out of range. Must be between 1 and 1000 inclusive.\")\n    \n    # Define Roman numeral equivalents for various decimal values\n    roman_numeral_map = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    \n    result = []  # Initialize the result as a list for efficient string concatenation\n    \n    # Iterate over the roman numeral map to construct the Roman numeral\n    for value, numeral in roman_numeral_map:\n        count = number // value  # Determine how many times the numeral should appear\n        result.append(numeral * count)  # Append the numeral the appropriate number of times\n        number -= value * count  # Reduce the number by the equivalent roman numeral value\n    \n    return ''.join(result).lower()  # Join the list into a string and convert to lowercase\n\n# Example usage:\n# print(int_to_mini_roman(19))  # Output: 'xix'\n# print(int_to_mini_roman(152))  # Output: 'clii'\n# print(int_to_mini_roman(426))  # Output: 'cdxxvi'"}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Ensure inputs are valid\n    if not all(isinstance(x, (int, float)) and x > 0 for x in (a, b, c)):\n        raise ValueError(\"All sides must be positive real numbers.\")\n    \n    # Sort sides so `c` is the longest side (potential hypotenuse)\n    sides = sorted([a, b, c])\n    x, y, z = sides[0], sides[1], sides[2]\n\n    # Use Pythagorean theorem to check for right-angled triangle\n    # x^2 + y^2 should be equal to z^2 for a right-angled triangle\n    return round(x**2 + y**2, 10) == round(z**2, 10)\n\n# Examples of edge cases:\n# - Non-positive sides\n# - Very large or very small floating point numbers\n# - Valid non-integer sides forming a right triangle (e.g., 1.5, 2, sqrt(6.25))\n\n# Usage examples:\nprint(right_angle_triangle(3, 4, 5))  # True\nprint(right_angle_triangle(1, 2, 3))  # False\nprint(right_angle_triangle(1.5, 2, (6.25)**0.5))  # True\nprint(right_angle_triangle(0, 4, 5))  # Raises ValueError\nprint(right_angle_triangle(-3, 4, 5))  # Raises ValueError"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    \n    # Ensure a and b are positive integers\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Both a and b must be positive integers.\")\n        \n    # Determine the range using min and max to handle cases like a > b\n    start = min(a, b)\n    end = max(a, b)\n    \n    result = []\n    \n    # Iterate through the range and collect even digits\n    for num in range(start, end + 1):\n        if num % 2 == 0:\n            result.append(num)\n    \n    return result\n\n# Edge cases:\n# 1. a and b are the same and even, ex: generate_integers(4, 4) => [4]\n# 2. a and b are the same and odd, ex: generate_integers(3, 3) => []\n# 3. One of a or b is 0, should raise an error\n# 4. Large a and b values check for efficiency and performance\n\n# Completed function including examples of potential edge cases.\n"}
