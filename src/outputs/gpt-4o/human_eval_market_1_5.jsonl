{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n\n    Args:\n        number (float): A positive floating point number.\n\n    Returns:\n        float: The decimal part of the number.\n    \n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    # Input validation: Check if the number is positive\n    if number < 0:\n        raise ValueError(\"The number must be positive\")\n\n    # Compute the integer part by converting the float to an integer\n    integer_part = int(number)\n\n    # The decimal part is the difference between the number and its integer part\n    decimal_part = number - integer_part\n\n    # Return the decimal part\n    return decimal_part\n\n\n# Example usage:\n# truncate_number(3.5)  # Should return 0.5\n\n# Note: In a highly concurrent environment, the function itself doesn't require threading or locking mechanisms\n# because it operates only on local variables and doesn't share state across threads. The function can be called\n# independently in a web server handling multiple requests without additional synchronization."}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    # Initializing the sum to 0 as sum of an empty list is 0\n    sum_total = 0\n    \n    # Initializing the product to 1 as product of an empty list is 1\n    product_total = 1\n    \n    # Loop through each number in the list\n    for num in numbers:\n        # Increment the sum by the current number\n        sum_total += num\n        \n        # Multiply the product by the current number\n        product_total *= num\n    \n    # Return the calculated sum and product as a tuple\n    return sum_total, product_total\n\n# Example usage and test cases to verify the correctness of the implementation\nif __name__ == \"__main__\":\n    print(sum_product([]))           # Output should be (0, 1)\n    print(sum_product([1, 2, 3, 4])) # Output should be (10, 24)\n    print(sum_product([5]))          # Output should be (5, 5)\n    print(sum_product([-1, 2, -3]))  # Output should be (-2, 6)"}
{"task_id": "HumanEval/12", "completion": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of a list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \n    Args:\n        strings (List[str]): A list of strings to examine.\n        \n    Returns:\n        Optional[str]: The longest string, or the first longest in case of ties.\n                       None if the input list is empty.\n                       \n    Examples:\n        >>> longest([])\n        \n        >>> longest(['a', 'b', 'c'])\n        'a'\n        \n        >>> longest(['a', 'bb', 'ccc'])\n        'ccc'\n    \"\"\"\n    \n    # Input validation: Check if the list is empty\n    if not strings:\n        return None\n    \n    # Initialize the variable to keep track of the longest string found\n    longest_string = strings[0]\n\n    # Iterate over the list starting from the second element\n    for string in strings[1:]:\n        # Compare the length of the current string with the longest string so far\n        if len(string) > len(longest_string):\n            longest_string = string\n    \n    return longest_string\n\n# Note:\n# - The function operates in O(n) time complexity, where n is the number of strings in the list.\n#   This is necessary to ensure scalability when handling large lists of strings.\n# - We return the first longest string in case of a tie due to iterating from the start and updating\n#   only when a longer string is found.\n# - The function is designed to handle empty lists by returning None, which is explicitly checked at the beginning."}
{"task_id": "HumanEval/5", "completion": "from typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\"\n    Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        delimiter (int): The integer to be inserted between list elements.\n        \n    Returns:\n        List[int]: A new list with the delimiter inserted between each pair of original elements.\n    \n    Examples:\n        >>> intersperse([], 4)\n        []\n        >>> intersperse([1, 2, 3], 4)\n        [1, 4, 2, 4, 3]\n    \"\"\"\n    # If the input list is empty, return an empty list immediately.\n    if not numbers:\n        return []\n    \n    # Iterate through the numbers, adding the delimiter between elements.\n    # The list comprehension used here should be efficient and concise for typical use cases.\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers) - 1:  # Avoid adding delimiter after the last element.\n            result.append(delimiter)\n    \n    return result\n\n# This function should be performant and maintainable, adhering to best practices. The list comprehension ensures \n# readability and efficiency. Given the likely simplicity of test inputs, this approach will handle typical usage well.\n\n# The function leverages basic Python constructs which are thread-safe (like regular list operations), \n# hence making it suitable for concurrent environments without explicit locks or synchronization mechanisms."}
{"task_id": "HumanEval/4", "completion": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    \n    # Step 1: Handle edge cases\n    if not numbers:\n        # If the input list is empty, the MAD is not defined, raising an appropriate error.\n        raise ValueError(\"The input list is empty. Mean absolute deviation is not defined.\")\n\n    # Step 2: Calculate the mean of the input numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Step 3: Compute the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    \n    # Step 4: Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad\n\n# Example usage:\n# mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) -> 1.0"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"\n    Return list of all prefixes from shortest to longest of the input string.\n    \n    The method iterates over the input string, cumulatively collecting substrings \n    from the start to the current position. This ensures the prefixes are collected \n    in the correct order. The approach ensures efficient construction of the prefixes \n    list with a clear O(n^2) complexity due to string slicing in each iteration, where \n    n is the length of the string. Given typical use cases, this complexity is acceptable. \n    \n    Args:\n    string (str): The input string from which prefixes are generated.\n    \n    Returns:\n    List[str]: A list of prefixes ordered from shortest to longest.\n    \n    Examples:\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    # Using list comprehension to collect prefixes in a simple and idiomatic way.\n    return [string[:i] for i in range(1, len(string) + 1)]\n\n# Example call (for self-testing, remove before running in production)\n# print(all_prefixes('abc'))"}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    Args:\n    paren_string (str): A space-separated string containing groups of parentheses.\n\n    Returns:\n    List[int]: A list of integers representing the deepest level of nesting for each group.\n    \n    Examples:\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Split the input string by spaces to process each group of parentheses individually\n    groups = paren_string.split()\n    \n    # This list will store the deepest level of nesting for each group\n    deepest_levels = []\n    \n    # Iterate over each group to calculate its deepest level of nesting\n    for group in groups:\n        current_depth = 0\n        max_depth = 0\n        # Iterate through each character in the group\n        for char in group:\n            if char == '(':\n                # Increment current depth when encountering an opening parenthesis\n                current_depth += 1\n                # Update max_depth if current depth is greater\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                # Decrement current depth when encountering a closing parenthesis\n                current_depth -= 1\n            else:\n                # Error handling: if there are invalid characters, raise an error\n                raise ValueError(f\"Invalid character {char} in input string\")\n        # Error handling: check if the parentheses are balanced\n        if current_depth != 0:\n            raise ValueError(f\"Unbalanced parentheses in group {group}\")\n        \n        # Append the calculated max_depth to the list of deepest levels\n        deepest_levels.append(max_depth)\n    \n    return deepest_levels"}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    \n    # Early validation of inputs to ensure they are non-negative integers.\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise ValueError(\"Both a and b must be integers.\")\n    if a < 0 or b < 0:\n        raise ValueError(\"Both a and b must be non-negative integers.\")\n    \n    # Implementing Euclid's algorithm\n    while b != 0:\n        a, b = b, a % b\n    \n    return a\n\n# Test cases to confirm the function works correctly.\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings only for ones that contain given substring.\n    \n    Args:\n    strings (List[str]): List of strings to be filtered.\n    substring (str): Substring to filter the list by.\n    \n    Returns:\n    List[str]: List of strings containing the given substring.\n    \n    Examples:\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    # Validate inputs (basic validation to ensure types are correct)\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"The first argument should be a list of strings.\")\n    if not isinstance(substring, str):\n        raise ValueError(\"The second argument should be a string.\")\n    \n    # List comprehension for filtering strings containing the substring\n    # Using list comprehension because it is more concise and generally faster\n    filtered_strings = [string for string in strings if substring in string]\n    \n    return filtered_strings\n\n# Implementation adheres to the following:\n# - Scalability: Designed with a list comprehension which is efficient for filtering.\n# - Maintainability: Clear argument validation and docstring for easy understanding and future modifications.\n# - Best practices: Type hints, input validation, and inline comments.\n# - Concurrent Environment: No use of shared/global state ensures thread safety in concurrent usage."}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses.\n    Your goal is to separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n    Ignore any spaces in the input string.\n    \n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    \n    # Remove spaces from the input string as they are irrelevant for processing\n    filtered_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to keep track of the current group and collection of groups\n    groups = []\n    current_group = []\n    open_count = 0\n    \n    # Iterate through each character in the filtered string\n    for char in filtered_string:\n        # Add the character to the current group\n        current_group.append(char)\n        \n        # Update the open/close brace count\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            open_count -= 1\n        \n        # If open count is 0, we have completed a balanced group\n        if open_count == 0 and current_group:\n            # Join the current group into a string and add to groups\n            groups.append(\"\".join(current_group))\n            # Reset current group for the next potential group\n            current_group = []\n    \n    # Check if there's any dangling unbalanced parentheses (shouldn't happen as per the assumptions)\n    if current_group:\n        raise ValueError(\"Input string contains unbalanced parentheses.\")\n    \n    return groups\n\n# If running the script directly, we can do a simple test\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/3", "completion": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" \n    Detect if the balance ever falls below zero due to a sequence of operations. \n\n    Parameters:\n    operations (List[int]): A list of integers representing deposits (positive values) and withdrawals (negative values).\n\n    Returns:\n    bool: True if the balance falls below zero at any point, otherwise False.\n    \n    The initial balance is zero. As we process each operation, we keep a running total of the balance. If at any\n    operation the balance becomes negative, we return True. If the loop completes and the balance was never negative,\n    we return False.\n\n    Assumptions:\n    - The `operations` list will not be modified concurrently while being processed. For concurrent usage scenarios, \n      proper synchronization mechanisms should be implemented.\n    - The entries in `operations` are valid integers. Error handling for non-integer values can be added if necessary.\n\n    Examples:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    \n    # Starting balance initialized to zero\n    balance = 0\n    \n    # Iterate through each operation in the list\n    for operation in operations:\n        # Update the balance\n        balance += operation\n        \n        # Check if balance falls below zero\n        if balance < 0:\n            return True  # Early exit if balance is negative\n    \n    # If we've gone through all operations and balance is not negative, return False\n    return False\n\n# Ensure the sample cases and function signature remain easily understandable and maintainable.\n# The implementation runs in O(n) time complexity, processing each operation exactly once,\n# which is efficient for typical use cases involving sequences of financial transactions.\n\n# Example Usage:\n# >>> below_zero([1, 2, 3])\n# False\n# >>> below_zero([1, 2, -4, 5])\n# True"}
{"task_id": "HumanEval/11", "completion": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    # Ensure that two strings have equal length for element-wise XOR operation\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length\")\n    \n    # Use a list to accumulate the result due to potential immutability issues of strings in a loop.\n    result = []\n\n    # Iterate through each bit position and perform XOR operation\n    for bit_a, bit_b in zip(a, b):\n        # Convert bit characters to integers, XOR them, then convert the result back to string\n        xor_result = str(int(bit_a) ^ int(bit_b))\n        result.append(xor_result)\n    \n    # Join the list of results into a single string before returning\n    return ''.join(result)\n\n# Example usage:\n# This should output '100'\nprint(string_xor('010', '110'))"}
{"task_id": "HumanEval/10", "completion": "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    Args:\n    string (str): The input string to extend to the smallest palindrome.\n\n    Returns:\n    str: The shortest palindrome that starts with `string`.\n    \n    Examples:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    \n    # Edge case: If the string is empty or already a palindrome\n    if not string or is_palindrome(string):\n        return string\n\n    length = len(string)\n\n    # Finding the longest postfix which is a palindrome\n    for i in range(length):\n        if is_palindrome(string[i:]):  # Checking postfix starting from each index\n            # Appending the reversed prefix before this postfix to the end of the string\n            prefix_to_add = string[:i][::-1]\n            return string + prefix_to_add\n\n    # This line should never be reached with any valid string inputs handled by the loop above.\n    # Every string has at least a trivial single character palindrome (the last character).\n    raise RuntimeError(\"Unexpected error in palindrome generation algorithm.\")\n\n# Supporting function for palindrome checking\ndef is_palindrome(string: str) -> bool:\n    \"\"\" \n    Test if given string is a palindrome. \n    \n    Args:\n    string (str): The string to check.\n\n    Returns:\n    bool: True if `string` is a palindrome, False otherwise.\n    \"\"\"\n    return string == string[::-1]"}
{"task_id": "HumanEval/0", "completion": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    \n    # Edge case handling: If there are less than 2 numbers, return False as no pairs exist.\n    if len(numbers) < 2:\n        return False\n\n    # Sort the list to allow for efficient comparison between adjacent elements.\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the sorted list, comparing adjacent elements.\n    for i in range(len(sorted_numbers) - 1):\n        # If the difference between any two adjacent elements is less than the threshold, return True.\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    # If no such pair is found, return False.\n    return False\n\n# Tests to validate implementation\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\"\n    Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n    \n    Args:\n    n (int): The end number of the sequence.\n\n    Returns:\n    str: The space-delimited numbers from 0 to n.\n\n    Examples:\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    \n    # Input validation: Check if n is a non-negative integer\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Using str.join and a generator expression for memory efficiency\n    return ' '.join(str(i) for i in range(n + 1))\n\n# Explanation:\n# - The function first ensures that the input is a non-negative integer. If the input is invalid,\n#   it raises a ValueError with an appropriate message.\n# - The main functionality is achieved using a generator expression inside the str.join method.\n#   This approach is both memory efficient and scalable because it avoids the creation of\n#   intermediate lists, which is beneficial in a highly concurrent environment."}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    \n    # Python's built-in len() function is optimized for performance and handles all edge cases.\n    # Using it to determine the length of the string ensures scalability and maintainability.\n    return len(string)\n\n# The implementation is straightforward and efficient due to the use of Python's built-in len() function.\n# Since len() is a built-in function, it is highly optimized and tested extensively in the Python standard library.\n# This ensures the function is suitable for a highly concurrent environment such as a web server."}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" \n    Find how many times a given substring can be found in the original string. \n    Count overlapping cases.\n    \n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n    # Edge case: if either the string or the substring is empty, return 0.\n    if not string or not substring:\n        return 0\n\n    count = 0\n    start = 0\n\n    # Loop to find all occurrences of substring and increment the start position by 1 for overlapping checks\n    while True:\n        start = string.find(substring, start)\n        \n        # If find returns -1, no more substrings are found, exit loop\n        if start == -1:\n            break\n\n        # Found one instance, increment count and move to the next start position\n        count += 1\n        start += 1  # overlap means we can start from the next character of the current found substring\n\n    return count\n\n# Example Usage:\n#\n# if __name__ == \"__main__\":\n#    print(how_many_times('aaaa', 'aa'))  # Should print 3"}
{"task_id": "HumanEval/17", "completion": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    # Define a mapping from note representation to beats\n    note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1,\n    }\n\n    # Split the music string by spaces to get individual notes\n    notes = music_string.split()\n\n    # Convert each note into the corresponding number of beats\n    beats_list = [note_to_beats[note] for note in notes]\n\n    return beats_list\n\n# Testing the function with the provided example\nassert parse_music('o o| .| o| o| .| .| .| .| o o') == [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]"}
{"task_id": "HumanEval/27", "completion": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    :param string: The string whose case to flip.\n    :return: A new string with the cases of all characters flipped.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    # Validate input type\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n\n    # Use a generator expression with the built-in `str.swapcase` method for efficient case flipping\n    return ''.join(char.swapcase() for char in string)\n\n# Note: str.swapcase() efficiently converts uppercase characters to lowercase \n# and vice versa in one method call, which internally handles any character.\n"}
{"task_id": "HumanEval/9", "completion": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    Args:\n        numbers (List[int]): The list of integers for which the rolling max is to be calculated.\n\n    Returns:\n        List[int]: A list containing the rolling maximums.\n    \n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n\n    # Initialize the result list with the same length as the input list\n    result = []\n\n    # Initialize the current maximum to a very small value (can be float('-inf') as well)\n    current_max = float('-inf')\n    \n    for num in numbers:\n        # Update the current maximum if the current number is greater\n        if num > current_max:\n            current_max = num\n        # Append the current maximum to the result\n        result.append(current_max)\n    \n    return result\n\n# Explanation:\n# 1. We initialize an empty list `result` where we will store the rolling maximums.\n# 2. We initialize `current_max` with the smallest possible value (negative infinity) to ensure any number in the list can be set as an initial maximum.\n# 3. We loop through each number in the input list `numbers`:\n#    - If the current number is greater than `current_max`, we update `current_max`.\n#    - We append the `current_max` to the result list.\n# 4. Finally, we return the result list which contains the rolling maximums.\n\n# The function has linear time complexity O(n) and constant space complexity O(1) aside from the output list.\n# This ensures that the solution is both efficient and scalable.\n\n# Here is an example of how concurrency might be handled:\n# To use this function in a highly concurrent environment, like a web server, it would typically be safe since it doesn't maintain any internal state between runs. \n\n# However, if you'd like to make sure it's thread-safe (not strictly necessary due to Python's GIL for this use case but useful in general):\n# 1. Avoid using any shared state without proper synchronization.\n# 2. Each call to `rolling_max` operates only on inputs provided to it and generates a new output list.\n"}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Input validation: Ensure n is a positive integer greater than 1 (as the problem doesn't make sense for n <= 1)\n    if n <= 1:\n        raise ValueError(\"Input must be a positive integer greater than 1.\")\n\n    # Loop backwards from n//2 to 1 to find the largest divisor\n    # Starting from n//2 because the largest proper divisor of n cannot be more than n/2\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i  # Return the first number found that divides n evenly\n    \n    # The above loop guarantees a return for valid n > 1, this line is to satisfy function completeness\n    return 1  # As a fallback, though for n > 1 it never gets here (the loop correctly handles all n > 1 cases)\n\n# Example usage:\n# print(largest_divisor(15))\n# Output should be 5"}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string.\n\n    Returns:\n    int: The number of distinct characters in the string.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    \n    # Convert the string to lowercase to normalize the character cases\n    lower_case_string = string.lower()\n    \n    # Use a set to store distinct characters because sets inherently maintain unique elements\n    distinct_characters = set(lower_case_string)\n    \n    # The length of the set gives the count of distinct characters\n    return len(distinct_characters)\n\n# Test examples to check the function\nif __name__ == \"__main__\":\n    print(count_distinct_characters('xyzXYZ'))  # Expected output: 3\n    print(count_distinct_characters('Jerry'))   # Expected output: 4"}
{"task_id": "HumanEval/21", "completion": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    \n    # Validate input.\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    # Find the minimum and maximum values in the input list.\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    # If all numbers are the same, raising an error since we can't perform the transformation.\n    if min_value == max_value:\n        raise ValueError(\"All numbers in the input list are the same, cannot rescale.\")\n    \n    # Apply the linear transformation\n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n    \n    return rescaled_numbers\n\n# Test cases for the implemented function\nif __name__ == \"__main__\":\n    # Test on example provided\n    assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    # Test on a different set\n    assert rescale_to_unit([10, 20, 30]) == [0.0, 0.5, 1.0]\n    # Test on mixed decimal values\n    assert rescale_to_unit([0.5, 1.5, 2.5, 3.5, 4.5]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n\n    print(\"All test cases passed!\")\n\n# <your answer>"}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    # Using the built-in `str.join` method to concatenate the list of strings.\n    # This is more efficient than using a loop with string concatenation\n    # because `str.join` minimizes the number of intermediate string creations.\n    return ''.join(strings)\n\n# Example usage\n# print(concatenate(['a', 'b', 'c']))  # Expected output: 'abc'\n\n# We use `str.join` because it operates in O(n) time complexity, which makes it scalable for large lists of strings.\n# Additionally, Python performs certain optimizations internally with `str.join`, making it more efficient compared to other methods of concatenation.\n# The function handles empty lists gracefully, returning an empty string as specified in the docstring."}
{"task_id": "HumanEval/26", "completion": "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    \n    # Step 1: Create a frequency counter for all numbers in the list\n    count = Counter(numbers)\n    \n    # Step 2: Use a list comprehension to keep only the elements that appear exactly once\n    result = [num for num in numbers if count[num] == 1]\n\n    return result\n\n# Design decisions:\n# 1. `Counter` is used from the `collections` module for efficient counting of elements.\n# 2. List comprehension ensures that the solution is concise and leverages Python's built-in capabilities.\n# 3. The solution maintains the order of elements as it iterates over the original list.\n\n# This implementation is scalable as it operates in O(n) time complexity where n is the length of the input list.\n# This should be sufficient for typical use cases in a highly concurrent environment.\n# Slight optimizations may involve custom counting mechanisms, but `Counter` is well-optimized and designed for such use cases."}
{"task_id": "HumanEval/19", "completion": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \n    Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest.\n    \n    Example:\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    \n    # Define a mapping from number words to their corresponding integer values for easy comparison\n    numeral_to_int = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    # Reverse the dictionary to map integers back to their numeral words for the result\n    int_to_numeral = {v: k for k, v in numeral_to_int.items()}\n    \n    # Split the input string into a list of numeral words\n    numerals = numbers.split()\n    \n    # Check if all numerals are valid\n    for numeral in numerals:\n        if numeral not in numeral_to_int:\n            raise ValueError(f\"Invalid numeral word: {numeral}\")\n    \n    # Convert numeral words to their corresponding integer values\n    int_values = [numeral_to_int[numeral] for numeral in numerals]\n    \n    # Sort the list of integers\n    int_values.sort()\n    \n    # Convert the sorted list back to numeral words\n    sorted_numerals = [int_to_numeral[value] for value in int_values]\n    \n    # Join the sorted numerals back into a space-delimited string and return\n    return ' '.join(sorted_numerals)\n\n# Example usage:\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/29", "completion": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    # Validate the input types\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"The first argument should be a list of strings.\")\n    if not isinstance(prefix, str):\n        raise ValueError(\"The second argument should be a string.\")\n    \n    # Use a list comprehension to filter strings starting with the specified prefix\n    return [s for s in strings if s.startswith(prefix)]\n\n# Note on concurrency:\n# - Since this function does not have any shared state or side effects, it is naturally thread-safe.\n# - It can be used in a concurrent environment without additional synchronization mechanisms.\n# - However, ensuring input validation safeguards against potential issues when handling multiple requests."}
{"task_id": "HumanEval/20", "completion": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    \n    # Sort the list to bring the closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference as infinity\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list and find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair\n\n\n# The design decision to use sorting ensures that the closest elements are adjacent in the list, simplifying the search\n# for the minimum difference. This approach has a time complexity of O(n log n) due to sorting, followed by a linear\n# scan O(n) to find the closest pair, making it efficient and scalable for large lists.\n\n# Additionally, this solution does not require any extra space, thus maintaining O(1) additional space complexity\n# (excluding the input and output space).\n\n# Since this function deals with floating-point numbers, special care is taken to compare differences accurately.\n\n# Error handling such as checking if the input list contains at least two elements is omitted as the problem assumes\n# the list length is at least two."}
{"task_id": "HumanEval/25", "completion": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    # Validate the input: catch non-positive numbers and raise an appropriate error\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    factors = []\n    \n    # Check for number of 2s that divide `n`\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n        \n    # `i` starts from 3 and checks for all odd potential factors\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 2\n        \n    # If `n` becomes a prime number greater than 2\n    if n > 2:\n        factors.append(n)\n        \n    return factors\n    \n# Example of usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/34", "completion": "from typing import List\n\ndef unique(l: List[int]) -> List[int]:\n    \"\"\"Return sorted unique elements in a list\n    Args:\n        l (List[int]): List of integers.\n    Returns:\n        List[int]: List of sorted unique integers.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use a set to automatically filter out duplicates. This operation is O(n).\n    unique_elements = set(l)\n    \n    # Convert the set back to a list and sort it. Sorting has a time complexity of O(n log n).\n    sorted_unique_elements = sorted(unique_elements)\n    \n    return sorted_unique_elements\n\n# Example usage:\n# if __name__ == \"__main__\":\n#     print(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]))\n\n# Explanation:\n# 1. Using a set to remove duplicates ensures that we are only keeping unique elements. Sets have O(1) insertion time on average.\n# 2. Converting the set back to a list and sorting it ensures the final output is in sorted order.\n# 3. The code is designed to be thread-safe and stateless since it does not rely on any shared, mutable state, making it suitable for concurrent environments."}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that l' is identical to l in the indices that are not divisible by three, \n    while its values at the indices that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    \n    Args:\n    l (list): The input list of integers.\n\n    Returns:\n    list: The transformed list as described in the docstring.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    \n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [v for i, v in enumerate(l) if i % 3 == 0]\n\n    # Sort these extracted elements\n    divisible_by_three_sorted = sorted(divisible_by_three)\n\n    # Create a copy of the original list to modify\n    l_copy = l[:]\n\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for idx, value in zip(range(0, len(l), 3), divisible_by_three_sorted):\n        l_copy[idx] = value\n        \n    return l_copy\n\n# Examples:\nprint(sort_third([1, 2, 3]))         # Output: [1, 2, 3]\nprint(sort_third([5, 6, 3, 4, 8, 9, 2]))  # Output: [2, 6, 3, 4, 8, 9, 5]\n"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    # Input validation\n    if not isinstance(l, list):\n        raise ValueError(\"Input must be a list\")\n\n    # Utilize list comprehension for concise and efficient filtering\n    # List comprehension generally has better performance due to optimized loops in Python\n    positive_numbers = [num for num in l if num > 0]\n\n    return positive_numbers\n\n# Example Usage\nif __name__ == \"__main__\":\n    # Test cases to verify the function\n    print(get_positive([-1, 2, -4, 5, 6]))  # Expected output: [2, 5, 6]\n    print(get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))  # Expected output: [5, 3, 2, 3, 9, 123, 1]"}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    \n    # Handle edge cases: numbers less than or equal to 1 are not prime\n    if n <= 1:\n        return False\n\n    # Handle small primes directly\n    if n <= 3:\n        return True\n\n    # Rule out multiples of 2 and 3\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    # Use a more efficient check for remaining potential divisors\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n\n    return True"}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n\n    The function takes a list of integers (or floats) and returns the maximum element in the list.\n    If the list is empty, it raises a ValueError since there is no element to compare.\n\n    Args:\n    l (list): a list containing numbers.\n\n    Returns:\n    int/float: The maximum number in the list.\n\n    Raises:\n    ValueError: if the input list is empty.\n    \n    Examples:\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n\n    # Input validation: check if list is empty\n    if not l:\n        raise ValueError(\"The list is empty. Cannot determine maximum element.\")\n\n    # Initialize a variable to hold the maximum value, start with the first element\n    max_val = l[0]\n    \n    # Iterate through the list and update the max_val variable accordingly\n    for number in l[1:]:\n        if number > max_val:\n            max_val = number\n    \n    return max_val\n\n# If this function is used in a highly concurrent environment, care must be taken to ensure\n# the list `l` is not modified while being processed. Although this function itself does not\n# modify the list, external factors (like the rest of the concurrent environment) might, \n# and thus lists should ideally be handled in a way that avoids such concurrency issues."}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # Split the string into groups of three characters.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # For each group of three characters, move the first character to the end if the group has exactly three characters.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # Split the string into groups of three characters.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # For each group of three characters, move the last character to the start if the group has exactly three characters.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n# Explanation:\n# - We split the input string `s` into groups of three characters.\n# - For the encoding function, we move the first character of each fully populated group (length 3) to the end.\n# - For the decoding function, we move the last character of each fully populated group (length 3) to the start.\n# - This creates a reversible transformation where the encoded message can be correctly decoded back to its original form."}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    Args:\n        l (list): Input list.\n    \n    Returns:\n        list: Output list with sorted even indices.\n    \n    Example:\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    \n    # Extracting values at even indices\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    # Sorting the values at even indices\n    even_indices_sorted = sorted(even_indices)\n        \n    # Initialize a new list to store the result\n    result = l[:]\n    \n    # Inserting sorted even indices back into their original positions\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = even_indices_sorted[even_index]\n        even_index += 1\n    \n    return result"}
{"task_id": "HumanEval/22", "completion": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter given list of any Python values for integers.\n    \n    Args:\n        values (List[Any]): A list containing values of any type.\n    \n    Returns:\n        List[int]: A list containing only the integer values from the input list.\n    \n    Example:\n        >>> filter_integers(['a', 3.14, 5])\n        [5]\n        >>> filter_integers([1, 2, 3, 'abc', {}, []])\n        [1, 2, 3]\n    \"\"\"\n    \n    # Initializing an empty list to store integer values.\n    result = []\n    \n    # Iterate over each value in the input list.\n    for value in values:\n        # Check if the value is an instance of int.\n        if isinstance(value, int):\n            # Append value to result list if it is an integer.\n            result.append(value)\n    \n    # Return the list of filtered integers.\n    return result"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    \n    # Edge case: If the list has fewer than 3 elements, it's impossible for there to be a triplet\n    if len(l) < 3:\n        return False\n\n    # Sort the list: O(n log n) - This helps in using the two-pointer technique\n    l.sort()\n\n    # Iterate through the list, fixing one element at a time\n    for i in range(len(l) - 2):\n        # Skip duplicate elements to avoid checking the same triplet more than once\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        # Two-pointer technique to find if there's a triplet summing to zero\n        left, right = i + 1, len(l) - 1\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1  # We need a larger sum, move the left pointer to the right\n            else:\n                right -= 1  # We need a smaller sum, move the right pointer to the left\n\n    # If no triplets sum to zero, return False\n    return False"}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int) -> str:\n    \"\"\"\n    Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    \n    # Error handling and input validation\n    if not (isinstance(x, int) and isinstance(base, int)):\n        raise ValueError(\"Both x and base must be integers\")\n        \n    if x < 0:\n        raise ValueError(\"Negative numbers are not supported\")\n        \n    if base <= 1 or base >= 10:\n        raise ValueError(\"Base must be greater than 1 and less than 10\")\n        \n    # Edge case: converting 0 always returns \"0\"\n    if x == 0:\n        return \"0\"\n    \n    # Store the digits of the converted number\n    digits = []\n    \n    # Convert the number into the specified base\n    while x > 0:\n        remainder = x % base\n        digits.insert(0, str(remainder))\n        x = x // base\n    \n    # Join and return the digits as a string\n    return ''.join(digits)\n\n# Example Usage:\n# >>> change_base(8, 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'"}
{"task_id": "HumanEval/32", "completion": "import math\nfrom typing import List\n\ndef poly(xs: List[float], x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: List[float]) -> float:\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    find_zero only takes list xs having an even number of coefficients\n    and largest non-zero coefficient as it guarantees\n    a solution.\n    \n    Args:\n    xs : List[float] : List of coefficients of the polynomial, must have an even length.\n    \n    Returns:\n    float : A zero of the polynomial.\n\n    Example:\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    \n    # Validate input to ensure list has even number of coefficients\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    # Use Newton-Raphson Method to find the root\n    def derivative(xs: List[float]) -> List[float]:\n        \"\"\"Calculate the derivative of the polynomial with coefficients xs.\"\"\"\n        return [i * coeff for i, coeff in enumerate(xs)][1:]\n    \n    # Initial guess and tolerance\n    x0 = 0.0\n    tol = 1e-7\n    max_iter = 1000\n\n    # Calculate the derivative of the polynomial\n    d_poly = derivative(xs)\n\n    for _ in range(max_iter):\n        y = poly(xs, x0)\n        if abs(y) < tol:\n            return x0\n        dy = poly(d_poly, x0)\n        if dy == 0:\n            raise ValueError(\"Derivative is zero, no convergence.\")\n        x0 = x0 - y / dy\n\n    raise ValueError(\"Maximum iterations exceeded, method did not converge.\")\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n# Note: This implementation includes basic validation to ensure the list of coefficients has an even number of elements,\n# as required by the specification. It uses the Newton-Raphson method for finding a root of the polynomial, which is\n# appropriate for polynomials of arbitrary degree and ensures scalability and robustness."}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    # We will use a set to store the elements we have seen so far.\n    # This allows O(1) average-time complexity for lookup and insertion.\n    \n    seen = set()\n\n    for num in l:\n        # Check if the negative counterpart of the current number\n        # already exists in the set.\n        if -num in seen:\n            return True\n        # Add the current number to the set for future pairs checking.\n        seen.add(num)\n    \n    return False\n\n# Testing the function using the provided examples\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/39", "completion": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns the n-th number that is both a Fibonacci number and a prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n        \n    primes = []\n    a, b = 1, 1\n    while len(primes) < n:\n        # Generate the next Fibonacci number\n        if is_prime(b):\n            primes.append(b)\n        a, b = b, a + b\n    return primes[n - 1]"}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n    \"\"\"\n    Return list with elements incremented by 1.\n\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n\n    Arguments:\n    l -- a list of integers\n\n    Returns:\n    A new list where each element from the input list is incremented by 1\n    \"\"\"\n    \n    # Validate input to ensure it is a list of integers.\n    if not isinstance(l, list):\n        raise TypeError(\"Input must be a list\")\n    if not all(isinstance(x, int) for x in l):\n        raise ValueError(\"All elements in the list must be integers\")\n    \n    # Return a new list with each element incremented by 1.\n    return [x + 1 for x in l]\n\n# Test cases for validation\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input a string encoded with the encode_shift function. Returns the decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n# Explanation:\n# `ord()` is used to get the ASCII value of the character.\n# For encoding, we shift the ASCII value by 5 and wrap around using modulo 26.\n# For decoding, we subtract the shift (5) instead of adding it and again wrap around using modulo 26.\n# `ord(\"a\")` is used to normalize the characters within 'a' to 'z'.\n# `chr()` is used to convert the ASCII value back to the character.\n\n# The decode_shift function directly parallels the encode_shift function.\n# It follows the same principles but reverses the shift, ensuring symmetry between encoding and decoding.\n# The modulo 26 operation ensures that the characters wrap around correctly within the alphabet.\n# This ensures simplicity and clarity, important aspects when code needs to be maintainable and scalable for a web server context.\n\n# Input validation can be added if the function is to be used in a broader context where the string might contain\n# characters outside 'a' to 'z'. This is left out here as the sample use case suggests the input will always be valid."}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y and return the result.\n    \n    This function takes two integer inputs, x and y, and returns their sum. This simple\n    operation is expected to be performed with high concurrency in mind, such as in a web\n    server environment handling numerous requests simultaneously.\n    \n    Given the type hints and simplicity of the operation, there\u2019s no need for complex error \n    handling beyond ensuring the inputs are integers. Python's type hints help ensure that the \n    inputs are of the expected type.\n    \n    Args:\n    x (int): The first integer to add.\n    y (int): The second integer to add.\n    \n    Returns:\n    int: The sum of x and y.\n    \n    Examples:\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    # Return the sum of x and y\n    return x + y\n\n# Examples to demonstrate the function:\n# add(2, 3) should return 5\n# add(5, 7) should return 12"}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n        n (int): The upper limit (exclusive) to check numbers.\n    \n    Returns:\n        int: The count of the digit '7' in the relevant integers.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    \n    # Input validation to ensure that n is an integer greater than 0.\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count_of_sevens = 0\n    \n    # Iterate through numbers from 0 to n-1.\n    for i in range(n):\n        # Check if the number is divisible by 11 or 13.\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to string to check for the digit '7'.\n            count_of_sevens += str(i).count('7')\n\n    return count_of_sevens\n\n# Running the example tests\nprint(fizz_buzz(50))  # Expected output: 0\nprint(fizz_buzz(78))  # Expected output: 2\nprint(fizz_buzz(79))  # Expected output: 3"}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    \n    # Define vowels in both lower and upper case\n    vowels = \"aeiouAEIOU\"\n    \n    # Use a list comprehension to filter out vowels from the input text\n    result = [char for char in text if char not in vowels]\n\n    # Join the list back into a single string\n    return ''.join(result)\n\n# The implementation uses a list comprehension for filtering which is typically efficient in Python.\n# Using a set for `vowels` could improve membership checking time slightly, \n# but given the small fixed size of `vowels`, this difference is negligible.\n# Furthermore, list comprehensions have a clean syntax and are optimized for performance in Python.\n\n# Additional considerations:\n# 1. Error Handling: Assuming the input is always a string as per the function's description. No explicit error handling is added.\n# 2. Concurrent Environment: The function is stateless and does not depend on or alter any external state, making it safe for concurrent execution."}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n\n    # Base cases: Define the first few elements of the sequence as given\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n\n    # Use an iterative approach to compute the sequence up to n.\n    # This avoids the stack overflow risks and inefficiencies associated with recursion.\n    # An array to store the sequence values is ideal for this purpose.\n    \n    # Initialize the first four values of the sequence\n    sequence = [0, 0, 2, 0]\n    \n    # Compute subsequent values iteratively up to n\n    for i in range(4, n + 1):\n        next_value = sequence[i - 1] + sequence[i - 2] + sequence[i - 3] + sequence[i - 4]\n        sequence.append(next_value)\n    \n    # Return the n-th value in the sequence\n    return sequence[n]\n\n# Include tests to validate the implementation\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    Parameters:\n    n (int): The exponent.\n    p (int): The modulus.\n\n    Returns:\n    int: The result of 2^n modulo p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p <= 0:\n        raise ValueError(\"Modulus p must be positive\")\n    if n < 0:\n        raise ValueError(\"Exponent n must be non-negative\")\n\n    # Using modular exponentiation to handle large n efficiently.\n    result = 1\n    base = 2 % p\n\n    while n > 0:\n        # If n is odd, multiply the current base to the result\n        if n % 2 == 1:\n            result = (result * base) % p\n        # Update base to base^2 % p\n        base = (base * base) % p\n        # Floor divide n by 2\n        n = n // 2\n\n    return result"}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    \n    Arguments:\n    l -- a list of comparable elements (e.g., integers or floats)\n    \n    Returns:\n    A boolean indicating whether the list is monotonically increasing or decreasing.\n    \n    Examples:\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    \n    # Input validation: check if the list is empty or contains only one element.\n    if len(l) <= 1:\n        return True\n    \n    # Determine the direction of monotonicity.\n    is_increasing = l[0] < l[1]\n    is_decreasing = l[0] > l[1]\n    \n    for i in range(1, len(l)):\n        if is_increasing and l[i] < l[i - 1]:\n            return False\n        if is_decreasing and l[i] > l[i - 1]:\n            return False\n    \n    return True"}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    \n    Parameters:\n    - text: The input string to check.\n    \n    Returns:\n    - True if the input string is a palindrome, False otherwise.\n    \n    Examples:\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \n    Considerations:\n    - Scalable to handle large strings efficiently.\n    - Thread-safe for concurrent environments like web servers.\n    \"\"\"\n    \n    # Input validation is not strictly necessary for this implementation since\n    # we're only dealing with strings as specified by the function signature.\n\n    # Remove non-alphanumeric characters and convert to lowercase to ignore case differences.\n    sanitized_text = ''.join(char.lower() for char in text if char.isalnum())\n\n    # Use two-pointer technique to check palindrome\n    # This is efficient, with a time complexity of O(n) and space complexity of O(1)\n    left, right = 0, len(sanitized_text) - 1\n\n    while left < right:\n        if sanitized_text[left] != sanitized_text[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True"}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    Takes into account the number of occurrences of each character as well.\n    \n    Args:\n    - s0 (str): The first word.\n    - s1 (str): The second word.\n    \n    Returns:\n    - bool: True if both words have the same characters in any quantities, False otherwise.\n\n    Examples:\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n\n    # Design Decision:\n    # We can use collections.Counter to count characters in each string, \n    # then simply compare the keys of these counters.\n    \n    from collections import Counter\n\n    # Counter objects to count the frequency of characters\n    counter1 = Counter(s0)\n    counter2 = Counter(s1)\n\n    # Compare the sets of characters in both strings\n    # We use the keys() method to get only the characters without caring about their frequencies\n    return set(counter1.keys()) == set(counter2.keys())"}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    \n    The function computes the median of a list of numbers, which is the middle \n    value when the numbers are sorted in order. If the list has an even number \n    of elements, the median is the average of the two middle elements.\n    \n    Args:\n        l (list): A list of numerical values.\n        \n    Returns:\n        float: The median value of the list.\n    \n    Examples:\n        >>> median([3, 1, 2, 4, 5])\n        3\n        >>> median([-10, 4, 6, 1000, 10, 20])\n        15.0\n    \n    Raises:\n        ValueError: If input is not a non-empty list.\n    \"\"\"\n    \n    # Input validation to ensure the input is a non-empty list\n    if not isinstance(l, list) or not l:\n        raise ValueError(\"Input must be a non-empty list.\")\n    \n    # Sorting the list to find the median\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    mid = n // 2\n    \n    # If the number of elements is odd, return the middle element\n    if n % 2 != 0:\n        return sorted_list[mid]\n    \n    # If the number of elements is even, return the average of the two middle elements\n    return (sorted_list[mid - 1] + sorted_list[mid]) / 2.0\n\n# Example Usage\nprint(median([3, 1, 2, 4, 5])) # Output: 3\nprint(median([-10, 4, 6, 1000, 10, 20])) # Output: 15.0"}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    \n    The function uses an iterative approach to compute the n-th Fibonacci number.\n    Iteration is chosen over recursion to avoid stack overflow issues and to provide \n    better performance for larger values of n. This implementation has a time complexity\n    of O(n) and space complexity of O(1).\n    \n    :param n: Index of the Fibonacci number to be returned. Should be a non-negative integer.\n    :return: The n-th Fibonacci number.\n\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    \n    # Input Validation\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    \n    # Special case for the first two Fibonacci numbers\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    prev, curr = 0, 1  # Initialize variables to store the previous two Fibonacci numbers.\n    \n    # Iterate from 2 to n and update the previous two Fibonacci numbers.\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\n# The choice of using an iterative approach with simple variable updates ensures that the \n# implementation is efficient in terms of both time and space. This function is \n# suitable for a highly concurrent environment as it does not retain large intermediate \n# states and operates in constant space, which helps in managing multiple simultaneous \n# requests effectively."}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    # Input validation to ensure n is a positive integer\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer greater than or equal to 1\")\n\n    # We use the arithmetic series sum formula to calculate the sum: sum = n * (n + 1) / 2\n    # This approach is O(1) in complexity which makes it highly scalable for large values of n.\n    return n * (n + 1) // 2  # Using integer division as result must be an integer\n\n# This design ensures that the function is both efficient and simple. Using the arithmetic\n# series sum formula means there is no need for loops or recursion, which could potentially\n# be performance bottlenecks in a concurrent environment."}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a: float, h: float) -> float:\n    \"\"\"\n    Calculate the area of a triangle given the base and height.\n    \n    Args:\n    a (float): The length of the base of the triangle.\n    h (float): The height of the triangle.\n    \n    Returns:\n    float: The area of the triangle.\n    \n    Raises:\n    ValueError: If `a` or `h` is negative.\n    TypeError: If `a` or `h` is not a number.\n    \n    Examples:\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # Input Validation\n    if not isinstance(a, (int, float)) or not isinstance(h, (int, float)):\n        raise TypeError(\"Both base (a) and height (h) must be numbers.\")\n    if a < 0 or h < 0:\n        raise ValueError(\"Both base (a) and height (h) must be non-negative.\")\n    \n    # Calculating the area of the triangle\n    area = 0.5 * a * h\n    return area\n\n# Example usage:\n# print(triangle_area(5, 3))  # Output: 7.5"}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    \n    - Iterate through each character in the input string.\n    - Use a counter to keep track of the number of unmatched opening brackets.\n    - Increment the counter for an opening bracket.\n    - Decrement the counter for a closing bracket.\n    - If the counter goes negative, return False immediately.\n    - At the end, return True if the counter is zero, otherwise return False.\n\n    Args:\n        brackets (str): A string containing only '<' and '>' characters.\n\n    Returns:\n        bool: True if the bracketing is correct, False otherwise.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    \n    # This counter will keep track of the number of unmatched opening brackets.\n    balance = 0\n    \n    for char in brackets:\n        if char == '<':\n            # Increment the counter for every opening bracket.\n            balance += 1\n        elif char == '>':\n            # Decrement the counter for every closing bracket.\n            balance -= 1\n            # If balance goes negative, there's a closing bracket without a matching opening bracket.\n            if balance < 0:\n                return False\n\n    # If balance is zero, all opening brackets have corresponding closing brackets.\n    return balance == 0"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left. The two sets of cars start out being very far from\n    each other. All cars move in the same speed. Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \n    Args:\n    n (int): The number of cars in each set.\n    \n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    \n    # Input validation: Ensure n is a non-negative integer\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"The number of cars (n) must be a non-negative integer.\")\n    \n    # Calculate the number of collisions\n    total_collisions = n * n\n    \n    return total_collisions\n\n# Example Usage:\n# print(car_race_collision(3)) # Should output 9"}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Return True if all numbers in the list l are below threshold t.\n\n    Args:\n        l (list): The list of numbers to be checked.\n        t (int): The threshold value.\n\n    Returns:\n        bool: True if all numbers in the list are below the threshold, False otherwise.\n\n    Examples:\n        >>> below_threshold([1, 2, 4, 10], 100)\n        True\n        >>> below_threshold([1, 20, 4, 10], 5)\n        False\n    \"\"\"\n    \n    # Input validation: Ensures that the list contains only numbers and the threshold is an integer.\n    if not isinstance(l, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(t, int):\n        raise TypeError(\"The threshold must be an integer.\")\n    if not all(isinstance(x, (int, float)) for x in l):\n        raise ValueError(\"All elements in the list must be numbers (int or float).\")\n\n    # Using the built-in all() function for clarity and efficiency\n    # It will short-circuit on the first False (i.e., if any number is not below the threshold).\n    return all(x < t for x in l)\n    \n# Example of usage:\n# print(below_threshold([1, 2, 4, 10], 100))  # Expected: True\n# print(below_threshold([1, 20, 4, 10], 5))   # Expected: False"}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert the lists to sets to leverage O(1) average time complexity for membership checks\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets to get the common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set to a sorted list\n    sorted_common_elements = sorted(common_elements)\n    \n    return sorted_common_elements\n\n# The above function is designed to be efficient in terms of both time and space complexity.\n# Explanation:\n# - By converting the lists to sets, we reduce the complexity of finding common elements to O(n).\n# - Using set intersection efficiently finds common elements.\n# - Sorting the set of common elements ensures the output is ordered.\n# - This approach is scalable, maintainable, and quick, suitable for concurrent environments like web servers."}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters' ASCII codes.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The sum of the ASCII values of all uppercase characters in the string.\n    \n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    \n    # Initialize the sum to 0.\n    total_sum = 0\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is an uppercase letter\n        if char.isupper():\n            # Add its ASCII value to the total sum\n            total_sum += ord(char)\n    \n    # Return the computed sum\n    return total_sum\n\n# Testing the function with given examples\nprint(digitSum(\"\"))           # Output: 0\nprint(digitSum(\"abAB\"))       # Output: 131\nprint(digitSum(\"abcCd\"))      # Output: 67\nprint(digitSum(\"helloE\"))     # Output: 69\nprint(digitSum(\"woArBld\"))    # Output: 131\nprint(digitSum(\"aAaaaXa\"))    # Output: 153"}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n\n    :param xs: List of coefficients [a0, a1, a2, ...] representing the polynomial a0 + a1*x + a2*x^2 + ...\n               xs[i] is the coefficient for x^i\n    :return: List of coefficients representing the derivative of the polynomial\n\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    \n    # Input validation: Ensure the input is a list and contains numeric coefficients.\n    if not isinstance(xs, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    if not all(isinstance(x, (int, float)) for x in xs):\n        raise ValueError(\"All elements in the input list must be numbers.\")\n    \n    # Return an empty list for an empty input list or for a constant polynomial (degree 0).\n    if len(xs) <= 1:\n        return []\n    \n    # Calculate the derivative coefficients.\n    derivative_coeffs = [i * xs[i] for i in range(1, len(xs))]\n    \n    return derivative_coeffs\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    # Initialize a counter to keep track of the balance between opening and closing brackets\n    balance = 0\n    \n    for char in brackets:\n        if char == \"(\":\n            balance += 1\n        elif char == \")\":\n            balance -= 1\n        \n        # If balance goes negative, we have more closing brackets than opening ones\n        if balance < 0:\n            return False\n    \n    # The final balance should be zero if we have a correct bracketing\n    return balance == 0\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(correct_bracketing(\"(\"))      # Should print False\n    print(correct_bracketing(\"()\"))     # Should print True\n    print(correct_bracketing(\"(()())\")) # Should print True\n    print(correct_bracketing(\")(()\"))   # Should print False"}
{"task_id": "HumanEval/67", "completion": "import re\n\ndef fruit_distribution(s, n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit. This basket contains  \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket, return the number of the mango fruits in the basket.\n    \n    Args:\n    s (str): A string representing the quantity of apples and oranges in the format \"<X> apples and <Y> oranges\".\n    n (int): An integer representing the total number of fruits in the basket.\n    \n    Returns:\n    int: The number of mango fruits in the basket.\n    \n    Example:\n    >>> fruit_distribution(\"5 apples and 6 oranges\", 19)\n    8\n    >>> fruit_distribution(\"0 apples and 1 oranges\", 3)\n    2\n    >>> fruit_distribution(\"2 apples and 3 oranges\", 100)\n    95\n    >>> fruit_distribution(\"100 apples and 1 oranges\", 120)\n    19\n    \"\"\"\n    \n    # Using regular expressions to extract numbers from the input string\n    numbers = re.findall(r'\\d+', s)\n    \n    if len(numbers) != 2:\n        raise ValueError(\"The input string format is incorrect. Expected format: '<X> apples and <Y> oranges'\")\n    \n    # Converting the extracted numbers from string to integer\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    \n    # Validate input: Ensure input is a string\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n\n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    # Initialize the count of vowels\n    count = 0\n\n    # Convert the input string to lowercase to handle case insensitivity\n    s = s.lower()\n\n    # Iterate over each character in the string and count the vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        # Check if the character 'y' is at the end of the string (it acts as a vowel in this case)\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count\n\n# Testing the function with various cases\nprint(vowels_count(\"abcde\"))  # Expected output: 2\nprint(vowels_count(\"ACEDY\"))  # Expected output: 3\nprint(vowels_count(\"bcd\"))    # Expected output: 0\nprint(vowels_count(\"y\"))      # Expected output: 1\nprint(vowels_count(\"AYEIOU\")) # Expected output: 5\nprint(vowels_count(\"crypt\"))  # Expected output: 1\nprint(vowels_count(\"\"))       # Expected output: 0\nprint(vowels_count(\"aEIouY\")) # Expected output: 6\nprint(vowels_count(\"happy\"))  # Expected output: 2\n\n# Edge cases\ntry:\n    print(vowels_count(1234))  # Expected to raise ValueError\nexcept ValueError as e:\n    print(e)\n\ntry:\n    print(vowels_count(None))  # Expected to raise ValueError\nexcept ValueError as e:\n    print(e)"}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start by dealing with the smallest prime, which is 2.\n    # We repeatedly divide n by 2 to handle even numbers.\n    \n    # Whenever n is even, we divide it by 2 (smallest prime number)\n    while n % 2 == 0:\n        n //= 2\n    \n    # At this point, n is odd. We now check the odd factors.\n    # We start with the smallest odd prime number, which is 3.\n    factor = 3\n    max_prime_factor = 1\n\n    while factor * factor <= n:\n        if n % factor == 0:\n            max_prime_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n    \n    if n > 2:\n        max_prime_factor = n\n    \n    return max_prime_factor\n\n# Now we will include some test cases to validate the function.\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/69", "completion": "from collections import Counter\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n\n    # Count the frequency of each integer in the list\n    frequency = Counter(lst)\n\n    # Initialize the result to -1 assuming no valid number is found\n    result = -1\n\n    # Iterate over the items in the dictionary\n    for number, freq in frequency.items():\n        # Check if the frequency is greater than or equal to the integer itself\n        if freq >= number:\n            # Update the result if the current number is greater than the result\n            result = max(result, number)\n    \n    return result"}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n\n    # Check if the list q is palindromic\n    is_palindromic = q == q[::-1]\n    \n    # Calculate the sum of the elements in q\n    total_weight = sum(q)\n    \n    # Determine if the object will fly\n    return is_palindromic and total_weight <= w\n\n# Example usage\nif __name__ == \"__main__\":\n    print(will_it_fly([1, 2], 5))        # Expected: False\n    print(will_it_fly([3, 2, 3], 1))     # Expected: False\n    print(will_it_fly([3, 2, 3], 9))     # Expected: True\n    print(will_it_fly([3], 5))           # Expected: True"}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize an array to hold the sequence values\n    fibfib_values = [0] * (n + 1)\n    fibfib_values[0] = 0\n    fibfib_values[1] = 0\n    fibfib_values[2] = 1\n    \n    # Fill the array using the defined relation\n    for i in range(3, n + 1):\n        fibfib_values[i] = fibfib_values[i - 1] + fibfib_values[i - 2] + fibfib_values[i - 3]\n    \n    # Return the nth value of the sequence\n    return fibfib_values[n]"}
{"task_id": "HumanEval/65", "completion": "\ndef circular_shift(x, shift):\n    \"\"\"\n    Circular shift the digits of the integer x, shift the digits right by 'shift'\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n\n    Args:\n        x (int): The integer whose digits are to be shifted.\n        shift (int): The number of positions to shift the digits to the right.\n\n    Returns:\n        str: The resulting string after the circular shift or the reversed number if shift > number of digits.\n\n    Usage examples:\n        >>> circular_shift(12, 1)\n        '21'\n        >>> circular_shift(12, 2)\n        '12'\n    \"\"\"\n\n    # Convert the number to a string to easily access its digits\n    num_str = str(x)\n    # Calculate the length of the number\n    length = len(num_str)\n\n    # If shift is greater than the number of digits, return the reversed digits\n    if shift >= length:\n        return num_str[::-1]\n\n    # Calculate the effective shift, considering any redundant complete rotations\n    effective_shift = shift % length\n\n    # Perform the circular shift to the right\n    result = num_str[-effective_shift:] + num_str[:-effective_shift]\n\n    return result\n\n\n# Test cases (to be removed or handled separately in actual production code)\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes,\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n\n    The plucked node should be returned in a list, [ smallest_value, its index ].\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    \n    # Initialize variables to store the smallest even value and its index\n    min_even_value = float('inf')\n    min_index = -1\n    \n    # Iterate through the array to find the smallest even value and its index\n    for index, value in enumerate(arr):\n        # Check if the number is even\n        if value % 2 == 0:\n            # Check if the current value is smaller than the current smallest even value\n            if value < min_even_value:\n                min_even_value = value\n                min_index = index\n    \n    # If no even value was found or the array was empty, return an empty list\n    if min_index == -1:\n        return []\n\n    # Return the smallest even value and its index\n    return [min_even_value, min_index]\n\n# Example usage:\n# print(pluck([4, 2, 3]))  # Output: [2, 1]\n# print(pluck([1, 2, 3]))  # Output: [2, 1]\n# print(pluck([]))         # Output: []\n# print(pluck([5, 0, 3, 0, 4, 2]))  # Output: [0, 1]"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    \n    # Return True for 0 since 0^3 is 0\n    if a == 0:\n        return True\n\n    # Calculate the cube root of the absolute value of a\n    # The cube root is taken from the absolute value, because the cube of a negative number is also negative.\n    abs_cube_root = round(abs(a) ** (1 / 3))\n\n    # Check if the cube root cubed equals the absolute value of a, returning True if so\n    return abs_cube_root ** 3 == abs(a)\n\n# Test cases to validate the solution\nprint(iscube(1))     # Expected: True\nprint(iscube(2))     # Expected: False\nprint(iscube(-1))    # Expected: True\nprint(iscube(64))    # Expected: True\nprint(iscube(0))     # Expected: True\nprint(iscube(180))   # Expected: False"}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n    \"\"\"\n    Returns true if the given number is the multiplication of 3 prime numbers and false otherwise.\n    Knowing that (a) is less than 100. \n    \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    \n    if not isinstance(a, int) or a < 2 or a >= 100:\n        # Input validation\n        return False\n    \n    # Sieve of Eratosthenes to find all prime numbers less than 100\n    def sieve(n):\n        is_prime = [True] * n\n        p = 2\n        while p * p < n:\n            if is_prime[p]:\n                for i in range(p * p, n, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n) if is_prime[p]]\n    \n    primes = sieve(100)\n    \n    # Trying all possible combinations of 3 primes to check if their product equals `a`\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            for k in range(j + 1, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    \n    return False"}
{"task_id": "HumanEval/71", "completion": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1.\n    \n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    \n    # Check if the inputs form a valid triangle using the triangle inequality theorem\n    if not (a + b > c and a + c > b and b + c > a):\n        return -1\n\n    # Calculate the semi-perimeter for Heron's formula\n    s = (a + b + c) / 2\n\n    # Calculate the area using Heron's formula\n    try:\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    except ValueError:\n        # This would handle mathematical errors that might arise from improper values.\n        return -1\n\n    # Return the area rounded to 2 decimal points\n    return round(area, 2)"}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n    # Input Validation: Ensure the input is an integer\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer\")\n    \n    # Convert the decimal number to a binary string\n    # The bin() function returns the binary representation prefixed with '0b'\n    # We use slicing [2:] to remove the '0b' prefix\n    binary_string = bin(decimal)[2:]\n    \n    # Format and return the final string with 'db' prefix and suffix\n    return f\"db{binary_string}db\"\n\n# Example usage:\n# print(decimal_to_binary(15))  # Output: \"db1111db\"\n# print(decimal_to_binary(32))  # Output: \"db100000db\""}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1  # If totals are equal, return the first list\n\n# Example usages:\n# print(total_match([], [])) # \u279e []\n# print(total_match(['hi', 'admin'], ['hI', 'Hi'])) # \u279e ['hI', 'Hi']\n# print(total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])) # \u279e ['hi', 'admin']\n# print(total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])) # \u279e ['hI', 'hi', 'hi']\n# print(total_match(['4'], ['1', '2', '3', '4', '5'])) # \u279e ['4']"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n    \n    # Check if the string length is less than 3.\n    if len(s) < 3:\n        return False\n    \n    # Iterate through the string up to the third last character.\n    for i in range(len(s) - 2):\n        # Extract the substring of three consecutive characters.\n        triplet = s[i:i+3]\n        \n        # Check if all three characters are distinct.\n        if len(set(triplet)) != 3:\n            return False\n    \n    # If all triplets are distinct, return True.\n    return True\n\n# As per best practices, this implementation ensures the string is scanned efficiently with O(n) complexity,\n# and uses constant space to check each triplet of characters. This is optimal for the problem at hand."}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 3, 5, 7]) ==> 0\n        add([0, 2, 0, 2]) ==> 4\n    \"\"\"\n\n    # Initialize the sum to zero\n    total = 0\n\n    # Iterate over the list while keeping track of the index\n    for index in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        # Check if the element at the odd index is even\n        if lst[index] % 2 == 0:\n            total += lst[index]  # Add it to the total sum\n\n    return total  # Return the final sum\n\n# Explanation:\n# - The function starts iterating from index 1 and increments the index by 2.\n#   This ensures we are only checking elements at odd indices.\n# - For each of these elements, it checks if the element is even.\n# - If the element is even, it adds it to the total sum.\n# - Finally, it returns the total sum of the even elements found at odd indices."}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n\n    # Edge case: empty list, simply return it as is\n    if not lst:\n        return []\n\n    sorted_lst = sorted(lst)  # Sort the list to easily extract min and max values\n    result = []              # This will hold the final sorted list\n    left, right = 0, len(sorted_lst) - 1  # Pointers to the start and end of the sorted list\n\n    # We iterate until all elements from sorted_lst are added to the result\n    while left <= right:\n        # Append the minimum element remaining\n        result.append(sorted_lst[left])\n        left += 1\n        \n        if left <= right:\n            # Append the maximum element remaining\n            result.append(sorted_lst[right])\n            right -= 1\n\n    return result\n\n# Example usage\n# print(strange_sort_list([1, 2, 3, 4]))  # Output: [1, 4, 2, 3]\n# print(strange_sort_list([5, 5, 5, 5]))  # Output: [5, 5, 5, 5]\n# print(strange_sort_list([]))            # Output: []"}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n    \"\"\"\n    Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int = x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n\n    # Input validation\n    if not isinstance(x, int) or not isinstance(n, int):\n        raise ValueError(\"Both x and n should be integers\")\n    if x < 1 or n < 1:\n        raise ValueError(\"Both x and n should be positive integers greater than 0\")\n    \n    # Handle special case where x is 1\n    if x == 1:\n        return True  # n**0 is 1 for any n\n    \n    # Start with the smallest power and check if we get to x\n    power = 1\n    while n ** power <= x:\n        if n ** power == x:\n            return True\n        power += 1\n        \n    return False\n\n# Example usage:\n# is_simple_power(1, 4) => True\n# is_simple_power(2, 2) => True\n# is_simple_power(8, 2) => True\n# is_simple_power(3, 2) => False\n# is_simple_power(3, 1) => False\n# is_simple_power(5, 3) => False"}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n\n    # Initialize a counter for the number of changes needed\n    changes_needed = 0\n    \n    # Iterate only halfway through the array\n    for i in range(len(arr) // 2):\n        # Compare the ith element from start and end\n        if arr[i] != arr[~i]:  # arr[~i] is a shorthand for arr[-i-1]\n            # If they are different, increment the counter as we need to make a change\n            changes_needed += 1\n            \n    return changes_needed\n\n# Example usages to verify correctness:\n# smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) returns 4\n# smallest_change([1, 2, 3, 4, 3, 2, 2]) returns 1\n# smallest_change([1, 2, 3, 2, 1]) returns 0"}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    \n    # Split the input string into words while preserving spaces.\n    words = s.split(' ')\n    \n    # Sort each word individually based on ASCII values and rejoin them.\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Reconstruct the string by joining the sorted words with a single space.\n    result = ' '.join(sorted_words)\n    \n    return result\n\n# Testing the function with given test cases\nprint(anti_shuffle('Hi'))           # Should return 'Hi'\nprint(anti_shuffle('hello'))        # Should return 'ehllo'\nprint(anti_shuffle('Hello World!!!')) # Should return 'Hello !!!Wdlor'"}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    \"\"\"\n    Count the number of hexadecimal digits in a given string that are prime numbers.\n    Hexadecimal digits are 0-9 and A-F, and primes among these are 2, 3, 5, 7, B (11), D (13).\n\n    Args:\n    num (str): A hexadecimal number as a string.\n\n    Returns:\n    int: The count of hexadecimal digits that are prime numbers.\n    \"\"\"\n    # Define the set of hexadecimal digits that are prime numbers.\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter to keep track of prime digits.\n    prime_count = 0\n    \n    # Iterate through each character in the input string.\n    for digit in num:\n        # Check if the character is a prime hexadecimal digit and increment the counter if it is.\n        if digit in prime_hex_digits:\n            prime_count += 1\n    \n    return prime_count\n\n# Example usage:\n# For these calls you should get the expected results as shown in the docstring.\nprint(hex_key(\"AB\"))            # Output: 1\nprint(hex_key(\"1077E\"))         # Output: 2\nprint(hex_key(\"ABED1A33\"))      # Output: 4\nprint(hex_key(\"123456789ABCDEF0\"))  # Output: 6\nprint(hex_key(\"2020\"))          # Output: 2"}
{"task_id": "HumanEval/82", "completion": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    # Only check odd numbers from 3 up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_length(string):\n    \"\"\"Check if the length of the string is a prime number.\"\"\"\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string\")\n    \n    length = len(string)\n    \n    return is_prime(length)\n\n# Examples for testing the function\nprint(prime_length('Hello'))        # True\nprint(prime_length('abcdcba'))      # True\nprint(prime_length('kittens'))      # True\nprint(prime_length('orange'))       # False"}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 2 * 2  # Calculate the shift amount\n    encrypted_string = []\n    \n    for char in s:\n        if char.islower():\n            # Find the position in the alphabet (0-25)\n            original_position = ord(char) - ord('a')\n            # Calculate the new position with the shift\n            new_position = (original_position + shift) % 26\n            # Convert back to a character\n            new_char = chr(ord('a') + new_position)\n            encrypted_string.append(new_char)\n        else:\n            # Non-lowercase characters are not handled in this spec, \n            # but if needed, we can add logic to manage other cases.\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)\n\n# Test examples\nprint(encrypt('hi'))       # 'lm'\nprint(encrypt('asdfghjkl'))  # 'ewhjklnop'\nprint(encrypt('gf'))       # 'kj'\nprint(encrypt('et'))       # 'ix'"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"\n    Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    \n    # Validate input\n    if not isinstance(N, int) or N < 0 or N > 10000:\n        raise ValueError(\"Input must be an integer within the range 0 \u2264 N \u2264 10000\")\n    \n    # Sum the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary, remove the '0b' prefix and return the string\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Ensuring the function is scalable and maintainable:\n# 1. **Validation**: Added input constraints validation to ensure N falls within acceptable range and is of correct type.\n# 2. **Sum Calculation**: Used list comprehension for concise and readable digit sum calculation.\n# 3. **Binary Conversion**: `bin()` function is utilized to convert the sum into binary.\n# 4. **Concurrency Consideration**: Python's GIL (Global Interpreter Lock) handles concurrency for standard data types, and this function doesn't maintain state. Hence it's thread-safe."}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n    '''\n    # Check if all provided inputs are integers.\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        return False\n    \n    # Check if any one number is the sum of the other two.\n    if x == y + z or y == x + z or z == x + y:\n        return True\n\n    # If none of the conditions were met, return False.\n    return False\n\n# Please note the comments explaining the decisions:\n# 1. Check if all inputs are integers to ensure that only valid integer inputs are processed.\n# 2. Check each pair combination to see if one of the numbers is the sum of the other two.\n# 3. If all checks pass, return True; otherwise, return False."}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    \"\"\"\n    This function takes two integers and returns the product of their unit digits.\n    \n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    int: The product of the unit digits of the input integers.\n    \n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    # Extract the unit digit of each number using modulo operation\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Calculate the product of the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product\n\n# Test cases\nprint(multiply(148, 412))  # Expected output: 16 (8*2)\nprint(multiply(19, 28))    # Expected output: 72 (9*8)\nprint(multiply(2020, 1851))# Expected output: 0  (0*1)\nprint(multiply(14, -15))   # Expected output: 20 (4*5)"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n\n    For example, if n=2, the valid numbers are:\n    - Starting with 1: 10, 11, 12, ..., 19 (10 numbers)\n    - Ending with 1: 11, 21, 31, ..., 91 (9 numbers - 11 is counted twice)\n    Hence, the count is 10 + 9 = 19.\n    \n    :param n: int -> A positive integer indicating the number of digits.\n    :return: int -> The count of n-digit positive integers that start or end with 1.\n    \"\"\"\n    \n    # Input validation\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input should be a positive integer\")\n    \n    if n == 1:\n        # For single-digit numbers, we have 1 as both the starting and ending number.\n        return 1\n    \n    # Calculate the count of numbers starting with 1\n    starts_with_1_count = 10 ** (n - 1)\n    \n    # Calculate the count of numbers ending with 1\n    ends_with_1_count = 10 ** (n - 1)\n    \n    # Exclude the double-counted numbers that both start and end with 1\n    overlap_count = 10 ** (n - 2) if n > 1 else 0\n\n    return starts_with_1_count + ends_with_1_count - overlap_count\n\n# Testing the function\nprint(starts_one_ends(2))  # Example: should return 19\nprint(starts_one_ends(3))  # More digits to see if the function scales well"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Write a function that takes a message and encodes it in such a \n    way that it swaps the case of all letters and replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the English alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    \n    # Define a utility function to replace vowels with the letter 2 places ahead\n    def replace_vowel(character):\n        vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n                  'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n        return vowels.get(character, character)  # Return the mapped character or the original if not a vowel\n    \n    # Process each character in the message\n    encoded_message = []\n    for char in message:\n        if char.isalpha():\n            # Swap case of the letter\n            swapped_char = char.lower() if char.isupper() else char.upper()\n            # Replace vowel if applicable\n            encoded_message.append(replace_vowel(swapped_char))\n        else:\n            # Safety clause, although function assumes only letters\n            encoded_message.append(char)\n\n    # Return the joined list as a new encoded string\n    return ''.join(encoded_message)\n\n# Ensure the code works with the provided examples\nif __name__ == \"__main__\":\n    print(encode('test'))  # Expected: 'TGST'\n    print(encode('This is a message'))  # Expected: 'tHKS KS C MGSSCGG'"}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    # Define a set of uppercase vowels for constant-time membership testing\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    \n    # Initialize a counter for uppercase vowels found at even indices\n    count = 0\n    \n    # Iterate over the string `s` with indices\n    for i in range(0, len(s), 2):\n        # Check if the character at the current even index is an uppercase vowel\n        if s[i] in uppercase_vowels:\n            count += 1\n    \n    return count\n\n# Example function calls:\nprint(count_upper('aBCdEf'))  # Output: 1\nprint(count_upper('abcdefg')) # Output: 0\nprint(count_upper('dBBE'))    # Output: 0"}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    \n    # Guard against empty input\n    if not array:\n        return []\n\n    # Calculate sum of first and last element\n    first_last_sum = array[0] + array[-1]\n\n    # Determine sorting order based on the sum\n    if first_last_sum % 2 == 0:\n        # Even sum, sort in descending order\n        sorted_array = sorted(array, reverse=True)\n    else:\n        # Odd sum, sort in ascending order\n        sorted_array = sorted(array)\n    \n    return sorted_array\n\n# Examples:\n# sort_array([]) => []\n# sort_array([5]) => [5]\n# sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n# sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    \n    # Check if the list contains fewer than 2 distinct elements\n    if len(lst) < 2 or len(set(lst)) < 2:\n        return None\n    \n    # Use a set to remove duplicates, then sort the unique elements\n    sorted_unique = sorted(set(lst))\n    \n    # Fetch the second smallest element\n    return sorted_unique[1]\n\n# Test cases\nprint(next_smallest([1, 2, 3, 4, 5]))  # Expected output: 2\nprint(next_smallest([5, 1, 4, 3, 2]))  # Expected output: 2\nprint(next_smallest([]))               # Expected output: None\nprint(next_smallest([1, 1]))           # Expected output: None"}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False if the given dictionary is empty.\n    \n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n\n    # Check if dictionary is empty\n    if not dict:\n        return False\n\n    # Determine the initial case of the first string key\n    lower_case = upper_case = None\n\n    for key in dict.keys():\n        # Check if the key is not a string\n        if not isinstance(key, str):\n            return False\n\n        # Check the case of the string key\n        if key.islower():\n            if upper_case:\n                return False\n            lower_case = True\n        elif key.isupper():\n            if lower_case:\n                return False\n            upper_case = True\n        else:\n            return False\n\n    # All keys have passed the checks\n    return True"}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested list,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    \n    # Initialize an empty list to store the coordinates\n    result = []\n\n    # Traverse each row and column to find occurrences of x\n    for row_index, row in enumerate(lst):\n        for col_index in range(len(row) - 1, -1, -1):\n            if row[col_index] == x:\n                result.append((row_index, col_index))\n    \n    # Sort the resultant list by row first, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result\n\n# Test cases\nprint(get_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1)) # Output: [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\nprint(get_row([], 1)) # Output: []\n\nprint(get_row([[], [1], [1, 2, 3]], 3)) # Output: [(2, 2)]"}
{"task_id": "HumanEval/99", "completion": "import math\n\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n\n    # Convert the input string to a float\n    try:\n        number = float(value)\n    except ValueError:\n        raise ValueError(\"Invalid input: The value must be a string representing a number.\")\n\n    # Calculate the floor and ceiling of the number\n    floor_num = math.floor(number)\n    ceil_num = math.ceil(number)\n\n    # Calculate the distance from the number to the nearest integer\n    distance_to_floor = abs(number - floor_num)\n    distance_to_ceil = abs(number - ceil_num)\n\n    # Decision logic to handle rounding\n    if distance_to_floor < distance_to_ceil:\n        return floor_num\n    elif distance_to_ceil < distance_to_floor:\n        return ceil_num\n    else:\n        # When the number is equally close to both floor and ceiling,\n        # round away from zero\n        if number > 0:\n            return ceil_num\n        else:\n            return floor_num\n\n# Test cases to validate the function \nprint(closest_integer(\"10\"))     # Output: 10\nprint(closest_integer(\"15.3\"))   # Output: 15\nprint(closest_integer(\"14.5\"))   # Output: 15\nprint(closest_integer(\"-14.5\"))  # Output: -15\nprint(closest_integer(\"0.5\"))    # Output: 1\nprint(closest_integer(\"-0.5\"))   # Output: -1\nprint(closest_integer(\"99.999\")) # Output: 100\nprint(closest_integer(\"-50.9999\")) # Output: -51"}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(gpas):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n    Example:\n    numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \n    Args:\n        gpas (list): A list of GPAs as floats.\n    \n    Returns:\n        list: A list of letter grades corresponding to the GPAs.\n    \"\"\"\n    \n    # Define a dictionary to map GPA ranges to letter grades\n    gpa_to_letter = [\n        (4.0, 'A+'), (3.7, 'A'), (3.3, 'A-'), (3.0, 'B+'), \n        (2.7, 'B'), (2.3, 'B-'), (2.0, 'C+'), (1.7, 'C'), \n        (1.3, 'C-'), (1.0, 'D+'), (0.7, 'D'), (0.0, 'D-'), \n        (-float('inf'), 'E')\n    ]\n    \n    def get_letter_grade(gpa):\n        \"\"\"Helper function to convert GPA to letter grade based on the defined ranges.\"\"\"\n        for threshold, grade in gpa_to_letter:\n            if gpa >= threshold:\n                return grade\n    \n    # Convert each GPA to a letter grade\n    letter_grades = [get_letter_grade(gpa) for gpa in gpas]\n\n    return letter_grades\n\n# Example usage\nprint(numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]))  # Output: ['A+', 'B', 'C-', 'C', 'A-']"}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    def has_even_digit(n):\n        \"\"\"Check if the number has any even digit\"\"\"\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n //= 10\n        return False\n    \n    # Filter out numbers with even digits and then sort the remaining numbers\n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()  # Ensure the list is sorted in increasing order\n    \n    return result\n\n# The function `has_even_digit` checks if a number contains any even digit. \n# The main function `unique_digits` uses this helper to filter out numbers that have even digits and \n# only retains numbers without any even digit. Finally, it sorts the result before returning."}
{"task_id": "HumanEval/101", "completion": "import re\n\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n\n    # Use regular expression to split the string by comma or space followed by zero or more spaces.\n    # This allows for robust splitting even with varied whitespace.\n    words = re.split(r'[,\\s]+', s.strip())\n    \n    # Filter out any empty strings that may have been created, in the event of multiple spaces or trailing commas.\n    words = [word for word in words if word]\n    \n    return words\n\n# Use comments to explain and validate\n# Considerations:\n# - Regular expressions are used due to their ability to handle complex splitting rules efficiently.\n# - The regex [,\\s]+ matches one or more occurrences of commas or whitespace.\n# - The `strip()` function removes leading/trailing whitespace from the input string.\n# - A list comprehension is used to filter out any empty strings."}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    \n    Example:\n    rounded_avg(1, 5) => \"0b11\"  # Average of 1, 2, 3, 4, 5 is 3\n    rounded_avg(7, 5) => -1      # n > m, invalid input\n    rounded_avg(10, 20) => \"0b1111\"  # Average of integers from 10 to 20 is ~15\n    rounded_avg(20, 33) => \"0b11010\"  # Average of integers from 20 to 33 is ~26\n    \"\"\"\n    \n    # If n is greater than m, it's an invalid input\n    if n > m:\n        return -1\n    \n    # Finding the number of elements in the range [n, m]\n    count = m - n + 1\n    \n    # Calculate the sum of integers from n to m using arithmetic series sum formula\n    total_sum = (m * (m + 1) // 2) - ((n - 1) * n // 2)\n\n    # Calculate the average\n    average = total_sum / count\n    \n    # Round the average to the nearest integer\n    rounded_average = round(average)\n    \n    # Convert the result to binary and return\n    return bin(rounded_average)\n\n# Test cases for validation\nassert rounded_avg(1, 5) == \"0b11\"  # Average is 3\nassert rounded_avg(7, 5) == -1      # Invalid input\nassert rounded_avg(10, 20) == \"0b1111\"  # Average is 15\nassert rounded_avg(20, 33) == \"0b11010\"  # Average is 26"}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    \"\"\"\n    Implement a function that takes a non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    For example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n\n    # Validate input\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # List to store prime numbers less than `n`\n    primes = []\n\n    # Loop through numbers from 2 to `n` and check for primality\n    for number in range(2, n):\n        if is_prime(number):\n            primes.append(number)\n\n    return primes"}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    \n    # Step 1: Check if lst1 already consists of only even numbers\n    if all(x % 2 == 0 for x in lst1):\n        return \"YES\"\n    \n    # Step 2: Identify the odd numbers in lst1 and the even numbers in lst2\n    odd_in_lst1 = [x for x in lst1 if x % 2 != 0]\n    even_in_lst2 = [x for x in lst2 if x % 2 == 0]\n    \n    # Step 3: Check if the number of odd numbers in lst1 is less than or equal to even numbers in lst2\n    # If so, it is possible to perform exchanges to make lst1 a list of only even numbers\n    if len(odd_in_lst1) <= len(even_in_lst2):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Output the final function"}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n\n    # Error handling: Handle cases where x or y are not positive numbers\n    if not (isinstance(x, (int, float)) and isinstance(y, (int, float)) and x > 0 and y > 0):\n        raise ValueError(\"Both x and y must be positive numbers.\")\n\n    # Swap values if x is greater than y to make x the lower bound and y the upper bound\n    if x > y:\n        x, y = y, x\n\n    # We start from the upper bound y and move downwards to check for the largest even number.\n    for num in range(int(y), int(x) - 1, -1):\n        if num % 2 == 0:\n            return num\n\n    # If no even number is found in the range, return -1.\n    return -1"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    \n    # Input validation: Ensure n is a positive integer.\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    # Determine if n is odd or even\n    is_odd = n % 2 == 1\n    \n    # List to hold the number of stones in each level\n    pile = []\n    \n    # Start the first level with n stones\n    current_stones = n\n    \n    for i in range(n):\n        pile.append(current_stones)\n        \n        # Calculate the next level\n        if is_odd:\n            current_stones += 2  # Next odd number\n        else:\n            current_stones += 2  # Next even number\n\n        # Even though both conditions add 2, this approach future-proofs for different logic if needed\n    \n        # Toggle the is_odd flag for next iteration if needed\n        # Not necessary here as per instructions, but keeping in mind scalability and maintainability\n    \n    return pile\n\n# If running within a web server or highly concurrent environment, \n# consider adding thread safety mechanisms or ensuring immutability if shared state is involved."}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    import re\n\n    # Split the input string into potential sentences based on delimiters '.', '?' and '!'\n    sentences = re.split(r'[.?!]', S)\n    \n    # Initialize the boredom counter\n    boredom_count = 0\n\n    # Iterate through each sentence to check if it starts with 'I'\n    for sentence in sentences:\n        # Strip leading and trailing whitespace\n        stripped_sentence = sentence.strip()\n        # Increment the count if the stripped sentence starts with 'I'\n        if stripped_sentence.startswith('I '):\n            boredom_count += 1\n    \n    return boredom_count\n\n# Test cases\nprint(is_bored(\"Hello world\"))  # Expected output: 0\nprint(is_bored(\"The sky is blue. The sun is shining. I love this weather\"))  # Expected output: 1\nprint(is_bored(\"I am here! Are you there? I couldn't see you.\"))  # Expected output: 2"}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n    \"\"\"\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    \"\"\"\n    \n    # If array is empty or has only one element, it's already sorted\n    if not arr or len(arr) == 1:\n        return True\n    \n    # Find the index where the array should split for it to be sorted\n    N = len(arr)\n    split_index = -1\n    \n    for i in range(N - 1):\n        if arr[i] > arr[i + 1]:\n            if split_index == -1:\n                split_index = i + 1\n            else:\n                # More than one place where the split occurs means it's not possible\n                return False\n    \n    if split_index == -1:\n        # Array is already sorted\n        return True\n    \n    # Check if the split array around the found split point is sorted\n    # The condition to be sorted with split_index is that arr[end of left part] <= arr[start of right part]\n    return arr[-1] <= arr[0]\n\n\n# Sample Test Cases\nprint(move_one_ball([3, 4, 5, 1, 2]))  # Expected output: True\nprint(move_one_ball([3, 5, 4, 1, 2]))  # Expected output: False"}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    \n    def is_palindrome(num):\n        \"\"\" Helper function to check if a number is a palindrome \"\"\"\n        str_num = str(num)\n        return str_num == str_num[::-1]\n\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate over the range from 1 to n inclusive\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)\n\n# Example usage:\n# print(even_odd_palindrome(3))  # Output: (1, 2)\n# print(even_odd_palindrome(12)) # Output: (4, 6)"}
{"task_id": "HumanEval/106", "completion": "import math\n\ndef f(n):\n    \"\"\"\n    Implement the function that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    \n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n    # Validate the input to be a positive integer\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    result = []\n    \n    for i in range(1, n+1):\n        # i is even (i.e., 2, 4, 6, ...) then append its factorial\n        if i % 2 == 0:\n            result.append(math.factorial(i))\n        else: # i is odd (i.e., 1, 3, 5, ...) then append the sum of numbers from 1 to i\n            result.append(sum(range(1, i+1)))\n\n    return result\n\n# The design decisions behind this implementation include:\n# - Using the range function starting from '1' and ending at 'n+1' to naturally account for indices starting from 1.\n# - Using the built-in math.factorial function for efficient and accurate factorial calculation which is robust for concurrency.\n# - Adding input validation to ensure the function only accepts positive integers, this avoids potential misuse and exceptions during runtime."}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    # This boolean function check for odd digits\n    def is_odd(digit):\n        return int(digit) % 2 != 0\n\n    result = []\n\n    # Iterate over each string in the input list\n    for s in lst:\n        # Count the number of odd digits in string 's'\n        odd_count = sum(1 for char in s if is_odd(char))\n\n        # Form the response string with embedded numbers\n        response = (f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} \"\n                    f\"of the {odd_count}nput.\")\n        \n        # Add the formatted string to result list\n        result.append(response)\n\n    return result\n\n# Example Usage\nif __name__ == \"__main__\":\n    print(odd_count(['1234567']))  # Output: [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    print(odd_count(['3', \"11111111\"]))  # Output: [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n                                          #          \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]"}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n    # This dictionary maps numbers to their corresponding word names\n    number_to_word = {1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n\n    # Filter the array to only contain numbers between 1 and 9 inclusive\n    filtered_numbers = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered numbers\n    sorted_numbers = sorted(filtered_numbers)\n    \n    # Reverse the sorted list\n    reversed_numbers = sorted_numbers[::-1]\n\n    # Replace each number by its corresponding word name using the dictionary\n    result = [number_to_word[num] for num in reversed_numbers]\n\n    return result\n\n# As an experienced software developer, your task is to complete the function based on its given signature and docstring.\n# Please consider the following:\n# - Ensure that your implementation is scalable, maintainable, and follows best practices.\n# - Use comments to explain your design decisions and the rationale behind them.\n# - If applicable, include error handling and input validation.\n# - Assume the function will be used in a highly concurrent environment (e.g., web server handling multiple requests).\n# - Output the final function as follows:\n\n# Example usage:\n# print(by_length([2, 1, 1, 4, 5, 8, 2, 3]))  \n# Output: ['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']\n\n# print(by_length([1, -1 , 55]))  \n# Output: ['One']"}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    \"\"\"\n    Given a string representing space-separated lowercase letters, return a dictionary\n    of the letter(s) with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n    \"\"\"\n    \n    # Edge case: if the input string is empty, return an empty dictionary.\n    if not test.strip():\n        return {}\n\n    from collections import Counter\n\n    # Create a counter dictionary to count occurrences of each letter.\n    counter = Counter(test.split())\n\n    # Determine the maximum count from the counter values.\n    max_count = max(counter.values())\n\n    # Create a dictionary of letters that have the maximum count.\n    result = {letter: count for letter, count in counter.items() if count == max_count}\n\n    return result\n\n# Example usage:\n# print(histogram('a b c'))  # Output: {'a': 1, 'b': 1, 'c': 1}\n# print(histogram('a b b a'))  # Output: {'a': 2, 'b': 2}\n# print(histogram('a b c a b'))  # Output: {'a': 2, 'b': 2}\n# print(histogram('b b b b a'))  # Output: {'b': 4}\n# print(histogram(''))  # Output: {}"}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n\n    # Define sets for vowels and consonants for quick lookup\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n\n    # Iterate from the second to the last but one character\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] in consonants and word[i + 1] in consonants:\n            return word[i]\n\n    return \"\"\n\n# The function is designed to iterate over the string from the right side, \n# checking if the current character is a vowel and is surrounded by consonants.\n# The vowel and consonant checks are optimized by using sets, providing O(1) look-up time.\n# Empty string is returned if no qualifying vowel is found."}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    \"\"\"\n    Task\n    We are given two strings s and c. You have to delete all the characters in s that are equal to any character in c,\n    then check if the result string is a palindrome.\n    A string is called a palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the palindrome check.\n\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd', False)\n    For s = \"abcdef\", c = \"b\", the result should be ('acdef', False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc', True)\n    \"\"\"\n    # Create a set of characters to be deleted for O(1) average time complexity lookup\n    chars_to_delete = set(c)\n    \n    # Build the resultant string by excluding characters found in chars_to_delete\n    result_string = ''.join(char for char in s if char not in chars_to_delete)\n    \n    # Check if the resultant string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Return the result string and the palindrome check result as a tuple\n    return (result_string, is_palindrome)\n\n# Example usage:\n# print(reverse_delete(\"abcde\", \"ae\"))  # Output: ('bcd', False)\n# print(reverse_delete(\"abcdef\", \"b\"))  # Output: ('acdef', False)\n# print(reverse_delete(\"abcdedcba\", \"ab\"))  # Output: ('cdedc', True)"}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    def sum_of_digits(n):\n        \"\"\"Helper function to calculate the sum of signed digits of a number\"\"\"\n        # Handle negative numbers by converting them to string, stripping '-', and processing digits\n        digits = str(n).replace('-', '')\n        return sum(int(d) for d in digits) + (-int(str(n)[0]) if n < 0 else 0)\n    \n    # Iterate through the array and count elements with sum of digits > 0\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n            \n    return count\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Output should be the same as the test cases described in the docstring\n    assert count_nums([]) == 0\n    assert count_nums([-1, 11, -11]) == 1\n    assert count_nums([1, 1, 2]) == 3\n    print(\"All tests passed!\")"}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    the number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n\n    # Filter out any negative values since those aren't within the \"non-negative\" integer specification\n    arr = [x for x in arr if x >= 0]\n\n    # Sort the array based on two dimensions:\n    # 1. Number of ones in their binary representation\n    # 2. Decimal value (for tiebreakers)\n    sorted_arr = sorted(arr, key=lambda x: (bin(x).count('1'), x))\n\n    return sorted_arr\n\n# Tests (should be in a separate test module or test function in practice)\nprint(sort_array([1, 5, 2, 3, 4]))  # Output: [1, 2, 3, 4, 5]\nprint(sort_array([-2, -3, -4, -5, -6]))  # Output: []\nprint(sort_array([1, 0, 2, 3, 4]))  # Output: [0, 1, 2, 3, 4]"}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    if not lst or len(lst) != 2:\n        return 'No'\n    \n    # Check both possible concatenation orders\n    combinations = [lst[0] + lst[1], lst[1] + lst[0]]\n    \n    def is_balanced(s):\n        balance = 0\n        \n        for ch in s:\n            if ch == '(':\n                balance += 1\n            else:\n                balance -= 1\n            \n            # If at any point balance goes negative, it means there are more closing brackets than opening ones.\n            if balance < 0:\n                return False\n        \n        # Finally, balance should be zero for the string to be balanced.\n        return balance == 0\n    \n    for combo in combinations:\n        if is_balanced(combo):\n            return 'Yes'\n    \n    return 'No'\n\n# Examples to validate the function\nassert match_parens(['()(', ')']) == 'Yes'\nassert match_parens([')', ')']) == 'No'\nassert match_parens(['(((', ')))']) == 'Yes'\nassert match_parens(['(', ')']) == 'Yes'"}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    # Input validation: Check if `nums` is a list and contains at least one integer.\n    if not isinstance(nums, list) or not all(isinstance(i, int) for i in nums):\n        raise ValueError(\"Input must be a list of integers\")\n\n    # Initialize variables to track the current subarray sum and the minimum sum found\n    current_sum = float('inf')\n    min_sum = float('inf')\n\n    for num in nums:\n        # Compare and take the minimum of the current number alone or the sum with the current subarray\n        current_sum = min(num, current_sum + num)\n        # Update the minimum sum if the current subarray sum is smaller\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum\n\n# Example usage:\n# print(minSubArraySum([2, 3, 4, 1, 2, 4]))  # Output: 1\n# print(minSubArraySum([-1, -2, -3]))        # Output: -6"}
{"task_id": "HumanEval/94", "completion": "def skjkasdkd(lst):\n    \"\"\"\n    You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n    \n    def is_prime(n):\n        \"\"\"Returns True if n is a prime number, else False.\"\"\"\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def sum_of_digits(n):\n        \"\"\"Returns the sum of the digits of the number n.\"\"\"\n        return sum(int(digit) for digit in str(n))\n\n    # Find the largest prime in the list\n    largest_prime = None\n    for num in lst:\n        if is_prime(num):\n            if largest_prime is None or num > largest_prime:\n                largest_prime = num\n\n    # If no prime number was found, return 0\n    if largest_prime is None:\n        return 0\n    \n    # Return the sum of the digits of the largest prime number\n    return sum_of_digits(largest_prime)\n\n# Output the final function as follows:\n# ```python\n# def skjkasdkd(lst):\n#     \"\"\"\n#     You are given a list of integers.\n#     You need to find the largest prime value and return the sum of its digits.\n# \n#     Examples:\n#     For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n#     For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n#     For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n#     For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n#     For lst = [0,81,12,3,1,21] the output should be 3\n#     For lst = [0,8,1,2,1,7] the output should be 7\n#     \"\"\"\n# \n#     def is_prime(n):\n#         \"\"\"Returns True if n is a prime number, else False.\"\"\"\n#         if n <= 1:\n#             return False\n#         if n <= 3:\n#             return True\n#         if n % 2 == 0 or n % 3 == 0:\n#             return False\n#         i = 5\n#         while i * i <= n:\n#             if n % i == 0 or n % (i + 2) == 0:\n#                 return False\n#             i += 6\n#         return True\n# \n#     def sum_of_digits(n):\n#         \"\"\"Returns the sum of the digits of the number n.\"\"\"\n#         return sum(int(digit) for digit in str(n))\n# \n#     # Find the largest prime in the list\n#     largest_prime = None\n#     for num in lst:\n#         if is_prime(num):\n#             if largest_prime is None or num > largest_prime:\n#                 largest_prime = num\n# \n#     # If no prime number was found, return 0\n#     if largest_prime is None:\n#         return 0\n#     \n#     # Return the sum of the digits of the largest prime number\n#     return sum_of_digits(largest_prime)\n# ```"}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n\n    # Edge case: Return None if the array is empty\n    if not arr:\n        return None\n\n    # Initialize the product of signs to 1 and the sum of magnitudes to 0\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    # Iterate over each element in the array\n    for num in arr:\n        if num > 0:\n            product_of_signs *= 1\n        elif num < 0:\n            product_of_signs *= -1\n        else:\n            product_of_signs *= 0\n        \n        sum_of_magnitudes += abs(num)\n\n    # Calculate and return the result\n    return sum_of_magnitudes * product_of_signs"}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Edge case: if k is 0, return an empty list\n    if k == 0:\n        return []\n\n    # Use Python's built-in heapq module to efficiently find the k largest elements\n    import heapq\n\n    # Find the k largest elements from arr\n    largest_k_elements = heapq.nlargest(k, arr)\n\n    # Sort the result before returning\n    return sorted(largest_k_elements)\n\n\n# Example test cases\nprint(maximum([-3, -4, 5], 3))  # Output: [-4, -3, 5]\nprint(maximum([4, -4, 4], 2))   # Output: [4, 4]\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))  # Output: [2]"}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n    import math\n    \n    # Count the total number of units of water in the entire grid\n    total_units_of_water = sum(sum(row) for row in grid)\n    \n    # The number of bucket operations needed is the total_units_of_water divided by the bucket capacity\n    # Use math.ceil to ensure we round up if there's a remainder\n    num_operations = math.ceil(total_units_of_water / capacity)\n    \n    return num_operations\n\n# Example usage:\n# Example 1\nprint(max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1))  # Output: 6\n# Example 2\nprint(max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2))  # Output: 5\n# Example 3\nprint(max_fill([[0,0,0], [0,0,0]], 5))  # Output: 0"}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n    \n    # First, check if the text contains whitespace\n    if \" \" in txt:\n        return txt.split()\n    \n    # Next, check if the text contains commas\n    if \",\" in txt:\n        return txt.split(',')\n    \n    # If no whitespaces or commas, count the number of specific lower-case letters\n    odd_order_count = 0\n    for char in txt:\n        if char.islower():\n            # Calculate 0-based order in the alphabet\n            order = ord(char) - ord('a')\n            if order % 2 != 0:\n                odd_order_count += 1\n    \n    return odd_order_count\n\n# Example usage:\n# print(split_words(\"Hello world!\")) # \u279e [\"Hello\", \"world!\"]\n# print(split_words(\"Hello,world!\")) # \u279e [\"Hello\", \"world!\"]\n# print(split_words(\"abcdef\"))       # \u279e 3"}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n\n    # Initialize the sum to zero\n    result_sum = 0\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # Check if the element has at most two digits\n        if -99 <= arr[i] <= 99:  # Considering negative numbers as well within two digits\n            result_sum += arr[i]\n    \n    return result_sum\n\n# Example usage:\n# print(add_elements([111,21,3,4000,5,6,7,8,9], 4))  # Output should be 24"}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    \"\"\"\n    Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    \n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    # Ensure the function will be scalable and maintainable.\n    \n    # Define the set of consonants for easy lookup.\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    # Split the string into words.\n    words = s.split()\n    \n    # Initialize the list that will hold the resulting words.\n    result = []\n\n    # Iterate over each word from the split string.\n    for word in words:\n        # Count the consonants in the current word.\n        consonant_count = sum(1 for char in word if char in consonants)\n        \n        # If the number of consonants matches n, add the word to the result list.\n        if consonant_count == n:\n            result.append(word)\n    \n    return result\n\n# Example Usage:\n# print(select_words(\"Mary had a little lamb\", 4)) ==> [\"little\"]\n# print(select_words(\"Mary had a little lamb\", 3)) ==> [\"Mary\", \"lamb\"]\n# print(select_words(\"simple white space\", 2)) ==> []\n# print(select_words(\"Hello world\", 4)) ==> [\"world\"]\n# print(select_words(\"Uncle sam\", 3)) ==> [\"Uncle\"]"}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n\n    # Initiate a set to track the odd numbers in the sequence\n    odd_numbers = set()\n\n    # Edge case handling: If input is 1, return [1]\n    if n == 1:\n        return [1]\n\n    # Generate the Collatz sequence until we reach 1\n    while n != 1:\n        if n % 2 != 0:      # If the number is odd, add it to the set\n            odd_numbers.add(n)\n        if n % 2 == 0:      # If the number is even\n            n //= 2\n        else:               # If the number is odd\n            n = 3 * n + 1\n    \n    # Always include 1 as it is part of the sequence\n    odd_numbers.add(1)\n\n    # Convert set to a sorted list before returning\n    return sorted(odd_numbers)\n\n# Test cases\nassert get_odd_collatz(5) == [1, 5]\nassert get_odd_collatz(1) == [1]\nassert get_odd_collatz(7) == [1, 7]"}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Args:\n    lst (List[int]): A non-empty list of integers.\n    \n    Returns:\n    int: The sum of all odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    \n    # Sum the odd elements on even indices ('0-based index', even positions are 0, 2, 4, ...)\n    return sum(value for index, value in enumerate(lst) if index % 2 == 0 and value % 2 != 0)\n\n# Testing the function:\n# Uncomment the lines below to test the function.\n# print(solution([5, 8, 7, 1]))  # Expected output: 12 (5 on index 0 + 7 on index 2)\n# print(solution([3, 3, 3, 3, 3]))  # Expected output: 9 (3 on index 0 + 3 on index 2 + 3 on index 4)\n# print(solution([30, 13, 24, 321]))  # Expected output: 0 (no odd numbers on even positions)"}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    \"\"\"\n    Calculate the first n + 1 numbers of the Tribonacci sequence.\n    \n    Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in the last couple centuries.\n    However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    \n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    \n    You are given a non-negative integer number n, you have to return a list of the first n + 1 numbers of the Tribonacci sequence.\n    \n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n\n    # Validation for non-negative integer input\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Memoization cache to store calculated Tribonacci values\n    cache = {1: 3}\n\n    def _tri_helper(num):\n        if num in cache:\n            return cache[num]\n        if num % 2 == 0:\n            cache[num] = 1 + num / 2\n        else:\n            cache[num] = _tri_helper(num - 1) + _tri_helper(num - 2) + _tri_helper(num + 1)\n        return cache[num]\n\n    # Storing the sequence up to n\n    sequence = []\n    for i in range(n + 1):\n        sequence.append(_tri_helper(i))\n    \n    return sequence"}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    n_str = str(n)\n    \n    # Initialize product to 1 since we'll be multiplying\n    product = 1\n    \n    # This flag will help us determine if at least one odd digit exists\n    has_odd = False\n    \n    for char in n_str:\n        digit = int(char)  # Convert character to digit\n        if digit % 2 != 0:  # Check if the digit is odd\n            product *= digit  # Multiply the product by the odd digit\n            has_odd = True    # Set the flag to true since we found an odd digit\n    \n    # If no odd digits were found, return 0\n    if not has_odd:\n        return 0\n    \n    # Return the product of odd digits\n    return product"}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n    \n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n\n    # Check if the list is sorted and count occurrences of each number\n    previous_number = -1\n    count_map = {}\n    \n    for number in lst:\n        # If the current number is less than the previous one, list is not sorted\n        if number < previous_number:\n            return False\n        previous_number = number\n        \n        # Count occurrences of the number\n        if number in count_map:\n            count_map[number] += 1\n            # If any number occurs more than twice, return False\n            if count_map[number] > 2:\n                return False\n        else:\n            count_map[number] = 1\n    \n    return True"}
{"task_id": "HumanEval/133", "completion": "import math\n\ndef sum_squares(lst):\n    \"\"\"\n    You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int (Ceiling) first.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \"\"\"\n    \n    # Use map to apply the ceiling function to each element in the list.\n    # Then use map again to apply the square operation to each element.\n    # Finally, sum up all the squared values.\n    \n    return sum(map(lambda x: math.ceil(x)**2, lst))\n\n# Below is the output of the final function\nprint(sum_squares([1, 2, 3]))  # Expected output is 14\nprint(sum_squares([1, 4, 9]))  # Expected output is 98\nprint(sum_squares([1, 3, 5, 7]))  # Expected output is 84\nprint(sum_squares([1.4, 4.2, 0]))  # Expected output is 29\nprint(sum_squares([-2.4, 1, 1]))  # Expected output is 6"}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n\n    # Iterate backward to find the largest index that violates the condition\n    for i in range(len(arr) - 1, 0, -1):\n        # Compare current element with the preceding one\n        if arr[i] < arr[i - 1]:\n            # Return the zero-based index\n            return i\n    \n    # If no such element is found, return -1\n    return -1"}
{"task_id": "HumanEval/127", "completion": "import math\n\ndef is_prime(num):\n    \"\"\"Helper function to determine if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1, interval2):\n    \"\"\"\n    Determine whether the length of the intersection of two intervals is a prime number.\n    \n    Args:\n    interval1: A tuple of two integers indicating the start and end of the first interval.\n    interval2: A tuple of two integers indicating the start and end of the second interval.\n    \n    Returns:\n    \"YES\" if the length of the intersection is a prime number, otherwise \"NO\".\n    \"\"\"\n    \n    # Extract the start and end points from the intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Determine the intersection interval\n    inter_start = max(start1, start2)\n    inter_end = min(end1, end2)\n    \n    # Check if there is an intersection\n    if inter_start > inter_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = inter_end - inter_start + 1\n    \n    # Determine if the length is a prime number\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Sample inputs and outputs\nprint(intersection((1, 2), (2, 3)))  # Output: \"NO\"\nprint(intersection((-1, 1), (0, 4)))  # Output: \"NO\"\nprint(intersection((-3, -1), (-5, 5)))  # Output: \"YES\""}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n    import sys\n    from collections import deque\n\n    N = len(grid)\n    direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    \n    def in_bounds(x, y):\n        return 0 <= x < N and 0 <= y < N\n    \n    # Initialize the minimum path with a sentinel value (higher than any possible path)\n    min_path = [sys.maxsize] * k \n\n    # DFS function to explore all possible paths from (x, y)\n    def dfs(x, y, path):\n        if len(path) == k:\n            nonlocal min_path\n            if path < min_path:\n                min_path = path[:]\n            return\n\n        for dx, dy in direction:\n            nx, ny = x + dx, y + dy\n            if in_bounds(nx, ny):\n                path.append(grid[nx][ny])\n                dfs(nx, ny, path)\n                path.pop()\n\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min_path"}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n    \n    # Initialize a stack to keep track of opening brackets\n    stack = []\n    \n    # Iterate over each character in the string\n    for char in string:\n        if char == '[':\n            # Push the character onto the stack if it is an opening bracket\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                # Pop the stack for a closing bracket\n                stack.pop()\n                # If the stack still contains elements after popping, it means there was nesting\n                if stack:\n                    return True\n            else:\n                # If the stack is empty when encountering a closing bracket, it's invalid\n                return False\n    \n    # If the loop completes and we haven't returned True yet, there is no nested structure\n    return False\n\n# Example usage:\nprint(is_nested('[[]]'))  # \u279e True\nprint(is_nested('[]]]]]]][[[[[]'))  # \u279e False\nprint(is_nested('[][]'))  # \u279e False\nprint(is_nested('[]'))  # \u279e False\nprint(is_nested('[[][]]'))  # \u279e True\nprint(is_nested('[[]][['))  # \u279e True"}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n\n    # Initialize variables to hold the largest negative integer and smallest positive integer\n    largest_neg = None\n    smallest_pos = None\n\n    # Iterate through each integer in the list\n    for num in lst:\n        if num < 0:\n            # If num is negative, update largest_neg if num is larger than the current largest_neg\n            if largest_neg is None or num > largest_neg:\n                largest_neg = num\n        elif num > 0:\n            # If num is positive, update smallest_pos if num is smaller than the current smallest_pos\n            if smallest_pos is None or num < smallest_pos:\n                smallest_pos = num\n\n    # Return the result as a tuple (largest_neg, smallest_pos)\n    return (largest_neg, smallest_pos)"}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n    \n    The smallest sum of 4 positive even numbers is 2 + 2 + 2 + 2 = 8. Therefore, the smallest number that can be\n    expressed as the sum of 4 positive even numbers is 8.\n    \n    Args:\n        n (int): The number to evaluate.\n        \n    Returns:\n        bool: True if `n` can be expressed as the sum of exactly 4 positive even numbers, False otherwise.\n\n    Example:\n        is_equal_to_sum_even(4) == False\n        is_equal_to_sum_even(6) == False\n        is_equal_to_sum_even(8) == True\n    \"\"\"\n\n    # The smallest number that can be expressed as the sum of 4 positive even numbers is 8\n    if n < 8:\n        return False\n\n    # When n >= 8, we need to check the following:\n    # If n is even, it can always be written as the sum of four positive even numbers.\n    # For example:\n    # n = 8  -> 2+2+2+2\n    # n = 10 -> 2+2+2+4\n    # n = 12 -> 2+2+4+4\n    # and so on...\n    return n % 2 == 0\n\n# Example usages\n# assert is_equal_to_sum_even(4) == False\n# assert is_equal_to_sum_even(6) == False\n# assert is_equal_to_sum_even(8) == True\n# assert is_equal_to_sum_even(10) == True\n# assert is_equal_to_sum_even(12) == True"}
{"task_id": "HumanEval/124", "completion": "import re\n\ndef valid_date(date):\n    \"\"\"\n    Validates a given date string and returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    Examples: \n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"\n    \n    # Regular expression to match the date format mm-dd-yyyy\n    date_pattern = re.compile(r'^(0[1-9]|1[0-2])-([0-2][0-9]|3[01])-(\\d{4})$')\n    \n    if not date:  # Rule 1: The date string is not empty\n        return False\n    \n    match = date_pattern.match(date)\n    if not match:  # Rule 4: The date should be in the format: mm-dd-yyyy\n        return False\n    \n    month = int(match.group(1))\n    day = int(match.group(2))\n    year = int(match.group(3))\n    \n    # Mapping of months to their respective maximum valid days\n    days_in_month = {\n        1: 31, 3: 31, 5: 31, 7: 31, 8: 31, 10: 31, 12: 31,\n        4: 30, 6: 30, 9: 30, 11: 30,\n        2: 29  # Rule 2: Considering February with max 29 days (not checking leap years for simplicity)\n    }\n    \n    if month < 1 or month > 12:  # Rule 3: The months should not be less than 1 or higher than 12\n        return False\n    \n    if day < 1 or day > days_in_month.get(month, 0):\n        return False\n    \n    return True"}
{"task_id": "HumanEval/139", "completion": "import math\n\ndef special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer greater than 0.\")\n\n    # Calculate the Brazilian factorial\n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n\n    return result\n\n# Unit tests to validate the implementation\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/144", "completion": "from fractions import Fraction\n\ndef simplify(x, n):\n    \"\"\"\n    Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n    # Convert the string representations to Fraction objects for precise arithmetic\n    fraction_x = Fraction(x)\n    fraction_n = Fraction(n)\n    \n    # Perform multiplication of fractions\n    result = fraction_x * fraction_n\n    \n    # Check if the result is a whole number (i.e., denominator = 1)\n    return result.denominator == 1\n    \n# Testing the function with given examples\nprint(simplify(\"1/5\", \"5/1\"))  # Expected output: True\nprint(simplify(\"1/6\", \"2/1\"))  # Expected output: False\nprint(simplify(\"7/10\", \"10/2\"))  # Expected output: False"}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    \n    # To ensure the function is scalable and maintainable, we will follow these design decisions:\n    # 1. Iterate once over the list to check index and apply the necessary modifications.\n    # 2. Accumulate the total sum during the iteration to avoid unnecessary auxiliary data structures.\n\n    total_sum = 0\n    \n    for idx, val in enumerate(lst):\n        if idx % 3 == 0:\n            # Index is a multiple of 3, square the value\n            total_sum += val ** 2\n        elif idx % 4 == 0:\n            # Index is a multiple of 4 and not a multiple of 3, cube the value\n            total_sum += val ** 3\n        else:\n            # Index is neither a multiple of 3 nor 4, add the value as is\n            total_sum += val\n    \n    return total_sum\n\n# Test cases\nprint(sum_squares([1, 2, 3]))            # 6\nprint(sum_squares([]))                   # 0\nprint(sum_squares([-1, -5, 2, -1, -5]))  # -126"}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n    '''\n\n    # Strip any trailing whitespace for accurate last character check\n    txt = txt.rstrip()\n    \n    # If the string is empty after rstrip(), return False\n    if not txt:\n        return False\n    \n    # Check if the last character is an alphabet letter\n    if txt[-1].isalpha():\n        # Split the string by spaces\n        words = txt.split()\n        \n        # Check if the last word (after removing any trailing spaces)\n        # is a single character and if that character is alphabetical.\n        if len(words[-1]) == 1:\n            return True\n    \n    return False\n\n# Example Usage:\n# print(check_if_last_char_is_a_letter(\"apple pie\"))  # \u279e False\n# print(check_if_last_char_is_a_letter(\"apple pi e\"))  # \u279e True\n# print(check_if_last_char_is_a_letter(\"apple pi e \")) # \u279e False\n# print(check_if_last_char_is_a_letter(\"\"))            # \u279e False"}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name):\n    \"\"\"\n    Check if the given file name is valid based on the specified rules.\n    \n    Parameters:\n    file_name (str): The name of the file to be checked.\n    \n    Returns:\n    str: 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    # Splitting the file name at the single dot\n    parts = file_name.split('.')\n    \n    # There should be exactly one dot in the file name\n    if len(parts) != 2:\n        return 'No'\n    \n    name_part, extension_part = parts\n    \n    # The substring before the dot should start with a letter and should not be empty\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    \n    # The substring after the dot should be one of 'txt', 'exe', 'dll'\n    valid_extensions = {'txt', 'exe', 'dll'}\n    if extension_part not in valid_extensions:\n        return 'No'\n    \n    # Count the number of digits in the file name\n    digit_count = sum(char.isdigit() for char in name_part)\n    \n    # There should not be more than three digits in the file's name\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'\n\n# Test cases\nprint(file_name_check(\"example.txt\"))  # => 'Yes'\nprint(file_name_check(\"1example.dll\"))  # => 'No' (the name should start with a latin alphabet letter)\nprint(file_name_check(\"ex4mple.exe\"))   # => 'Yes'\nprint(file_name_check(\"exa.mple.txt\"))  # => 'No' (more than one dot)\nprint(file_name_check(\"ex.mp3\"))        # => 'No' (invalid extension)\nprint(file_name_check(\"123example.txt\")) # => 'Yes'\nprint(file_name_check(\"1234example.txt\")) # => 'No' (more than three digits)"}
{"task_id": "HumanEval/143", "completion": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef words_in_sentence(sentence):\n    \"\"\"\n    Given a string representing a sentence, return a new string containing\n    words from the original sentence whose lengths are prime numbers,\n    in the same order.\n    \n    :param sentence: str, the input sentence.\n    :return: str, the words with prime lengths.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words whose length is a prime number\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    \n    # Join the filtered words back into a single string\n    return ' '.join(prime_length_words)\n\n# Example usage:\n# print(words_in_sentence(\"This is a test\"))  # Output: \"is\"\n# print(words_in_sentence(\"lets go for swimming\"))  # Output: \"go for\""}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n\n    # Helper function to calculate the sum of digits of a number\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n\n    # Sort the list according to the sum of digits\n    # Ties are broken by the original order in the list (stable sorting)\n    sorted_nums = sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))\n\n    return sorted_nums\n\n# Example usage:\n# print(order_by_points([1, 11, -1, -11, -12]))  # Output: [-1, -11, 1, -12, 11]\n# print(order_by_points([]))  # Output: []"}
{"task_id": "HumanEval/140", "completion": "import re\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n    \n    # Validate input\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Use regex to handle the transformation\n    # `sub` will handle different patterns to achieve our goal\n    text = re.sub(r' {2,}', '-', text)  # Replace 2 or more spaces with '-'\n    text = re.sub(r' ', '_', text)  # Replace single spaces with '_'\n    \n    return text\n\n# Example usage\nprint(fix_spaces(\"Example\"))          # -> \"Example\"\nprint(fix_spaces(\"Example 1\"))        # -> \"Example_1\"\nprint(fix_spaces(\" Example 2\"))       # -> \"_Example_2\"\nprint(fix_spaces(\" Example   3\"))     # -> \"_Example-3\"\nprint(fix_spaces(\"Example    4 \"))    # -> \"Example-4_\""}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n    \n    # Helper function to determine if both first and last digits of a number are odd\n    def is_odd_digit(digit):\n        return digit % 2 != 0\n\n    def valid_number(num):\n        # Make sure we work with the absolute value of the number\n        num_str = str(abs(num))\n        first_digit = int(num_str[0])\n        last_digit = int(num_str[-1])\n        \n        # Check if both digits are odd\n        return is_odd_digit(first_digit) and is_odd_digit(last_digit)\n\n    count = 0\n    \n    for num in nums:\n        # We only consider numbers greater than 10\n        if num > 10 and valid_number(num):\n            count += 1\n            \n    return count\n\n# Test cases\nprint(specialFilter([15, -73, 14, -15]))  # Outputs: 1\nprint(specialFilter([33, -2, -3, 45, 21, 109]))  # Outputs: 2"}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    \"\"\"Given an integer, return a tuple that has the number of even and odd digits respectively.\n    \n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n\n    # Convert the number to its absolute value to ignore any negative signs. We only need to count digits.\n    num = abs(num)\n    \n    # Initialize counters for even and odd digits.\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit of the number.\n    for digit in str(num):\n        # Convert the character to an integer.\n        digit = int(digit)\n        \n        # Check if the digit is even or odd and update the respective counter.\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Return the tuple with counts of even and odd digits.\n    return (even_count, odd_count)\n\n# Testing the function:\nprint(even_odd_count(-12))  # Expected output: (1, 1)\nprint(even_odd_count(123))  # Expected output: (1, 2)"}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    If the input list is empty, return 0.\n    '''\n\n    # Initialize sum to 0\n    sum_of_squares = 0\n\n    for num in lst:\n        # Check if the number is positive and an integer and odd\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            # Add the square of the number to the sum\n            sum_of_squares += num ** 2\n\n    return sum_of_squares\n\n# Examples to illustrate the function\nassert double_the_difference([1, 3, 2, 0]) == 10\nassert double_the_difference([-1, -2, 0]) == 0\nassert double_the_difference([9, -2]) == 81\nassert double_the_difference([0]) == 0\nassert double_the_difference([]) == 0"}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    \n    # Create the array 'a' based on the given formula.\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    # Count the occurrences of each modulo 3 residue.\n    count_mod = [0, 0, 0]\n    for num in a:\n        count_mod[num % 3] += 1\n    \n    # Calculate number of valid triples:\n    # A valid triple consists of either:\n    #   - all zeros \n    #   - one zero, one one, and one two\n    # Using combinations formula: C(n, k) = n! / (k! * (n - k)!)\n    \n    def combinations(n, k):\n        # If there are fewer than k items, it's not possible to form a combination.\n        if n < k:\n            return 0\n        # Calculate combinations iteratively to avoid large factorials.\n        result = 1\n        for i in range(k):\n            result = result * (n - i) // (i + 1)\n        return result\n    \n    # Count valid triples (a[i], a[j], a[k])\n    num_triples = 0\n    \n    # Case 1: All zeros\n    num_triples += combinations(count_mod[0], 3)\n    \n    # Case 2: One zero, one one, and one two\n    num_triples += count_mod[0] * count_mod[1] * count_mod[2]\n    \n    return num_triples\n\n# Example usage\nn = 5\nprint(get_max_triples(n))  # Output: 1"}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    \"\"\"\n    Determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match.\n    Return an array of the same length denoting how far off each guess was.\n    If they have guessed correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    example:\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n    \n    # Ensure both inputs are lists of equal length\n    if not isinstance(game, list) or not isinstance(guess, list):\n        raise TypeError(\"Both game and guess should be lists.\")\n    if len(game) != len(guess):\n        raise ValueError(\"Both lists should have the same length.\")\n    \n    distance = []\n    \n    for actual, predicted in zip(game, guess):\n        # Calculate the difference or 0 if they match\n        distance.append(0 if actual == predicted else abs(actual - predicted))\n        \n    return distance"}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n    \"\"\" \n    Accepts a list of strings and returns the word with the maximum number\n    of unique characters. If multiple strings have the same number of \n    unique characters, return the one which comes first in lexicographical order.\n\n    Args:\n        words (list): A list of strings.\n        \n    Returns:\n        str: The word with the maximum number of unique characters.\n    \"\"\"\n    \n    # Handling an empty input list case\n    if not words:\n        return \"\"\n    \n    # Initialize variables to store the word with maximum unique characters\n    max_unique_count = 0\n    result_word = \"\"\n    \n    for word in words:\n        # Use a set to find unique characters in each word\n        unique_chars = set(word)\n        unique_count = len(unique_chars)\n        \n        # Check if we found a word with more unique characters\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            result_word = word\n        # If counts are equal, pick the lexicographically smaller word\n        elif unique_count == max_unique_count and word < result_word:\n            result_word = word\n\n    return result_word\n\n# Example usage\nprint(find_max([\"name\", \"of\", \"string\"]))  # Output: \"string\"\nprint(find_max([\"name\", \"enam\", \"game\"]))  # Output: \"enam\"\nprint(find_max([\"aaaaaaa\", \"bb\", \"cc\"]))   # Output: \"aaaaaaa\""}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(a, b):\n    \"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word.\n    \n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    Args:\n    a (str): The first word.\n    b (str): The second word.\n\n    Returns:\n    bool: True if the second word or any of its rotations is a substring in the first word, otherwise False.\n    \"\"\"\n    if not a or not b:\n        return False\n\n    # Generate all rotations of b\n    b_rotations = [b[i:] + b[:i] for i in range(len(b))]\n\n    # Check if any rotation of b is a substring of a\n    for rotation in b_rotations:\n        if rotation in a:\n            return True\n    \n    return False\n\n# Example usage:\n# print(cycpattern_check(\"abcd\", \"abd\")) # False\n# print(cycpattern_check(\"hello\", \"ell\")) # True\n# print(cycpattern_check(\"whassup\", \"psus\")) # False\n# print(cycpattern_check(\"abab\", \"baa\")) # True\n# print(cycpattern_check(\"efef\", \"eeff\")) # False\n# print(cycpattern_check(\"himenss\", \"simen\")) # True"}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    # Map of Roman numerals from highest to lowest\n    roman_map = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n\n    # Check that the input number is within the valid range\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000\")\n\n    result = []\n\n    # Convert number to Roman numeral\n    for (arabic, roman) in roman_map:\n        count, number = divmod(number, arabic)\n        result.append(roman * count)\n\n    # Join the list into a string and return it in lowercase\n    return ''.join(result).lower()"}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    \n    def to_float(value):\n        \"\"\"\n        Converts a value to a float. Handles strings by replacing ',' with '.'.\n        Returns None if the value cannot be converted to a float.\n        \"\"\"\n        if isinstance(value, (int, float)):\n            return float(value)\n        if isinstance(value, str):\n            try:\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        return None\n    \n    def compare_values(val1, val2, raw_val1, raw_val2):\n        \"\"\"\n        Compares the raw values based on their float representation.\n        \"\"\"\n        if val1 > val2:\n            return raw_val1\n        elif val1 < val2:\n            return raw_val2\n        else:\n            return None\n    \n    # Convert both values to floats for comparison\n    val_a = to_float(a)\n    val_b = to_float(b)\n    \n    # If either value cannot be converted to float, raise an error\n    if val_a is None or val_b is None:\n        raise ValueError(\"One or both inputs cannot be converted to a float.\")\n    \n    return compare_values(val_a, val_b, a, b)\n\n# Example usages:\nprint(compare_one(1, 2.5))      # \u279e 2.5\nprint(compare_one(1, \"2,3\"))    # \u279e \"2,3\"\nprint(compare_one(\"5,1\", \"6\"))  # \u279e \"6\"\nprint(compare_one(\"1\", 1))      # \u279e None"}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    \"\"\"\n    You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n\n    # Check if the string contains any letters\n    contains_letter = any(char.isalpha() for char in s)\n    \n    # If the string contains no letters, reverse the string\n    if not contains_letter:\n        return s[::-1]\n    \n    # Otherwise, reverse the case of each letter in the string\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n\n# Example usage:\n# print(solve(\"1234\"))  # Output: \"4321\"\n# print(solve(\"ab\"))  # Output: \"AB\"\n# print(solve(\"#a@C\"))  # Output: \"#A@c\""}
{"task_id": "HumanEval/150", "completion": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while (i * i) <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n    \n    Args:\n    n (int): The number to check for primality.\n    x (any): The value to return if n is a prime number.\n    y (any): The value to return if n is not a prime number.\n    \n    Returns:\n    any: The value of x if n is a prime number, otherwise the value of y.\n    \n    Examples:\n    for x_or_y(7, 34, 12) -> 34\n    for x_or_y(15, 8, 5) -> 5\n    \"\"\"\n    # Validate input\n    if not isinstance(n, int):\n        raise ValueError(\"n must be an integer\")\n    \n    if is_prime(n):\n        return x\n    else:\n        return y\n\n# Example usages:\nprint(x_or_y(7, 34, 12))  # Output: 34\nprint(x_or_y(15, 8, 5))   # Output: 5"}
{"task_id": "HumanEval/149", "completion": "\ndef sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings as a parameter, deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order. The order of the list is ascending by the length of each word,\n    and if two words have the same length, it sorts the list alphabetically.\n\n    Parameters:\n    lst (list): A list of strings.\n\n    Returns:\n    list: A list of strings sorted by the specified rules.\n    \"\"\"\n\n    # Validate that the input is a list\n    if not isinstance(lst, list):\n        raise ValueError(\"Input must be a list\")\n\n    # Filter out the strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort by length and alphabetically within the same length\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n\n    return sorted_words\n\n\n# Example test cases to validate the implementation\nassert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"], \"Test case 1 failed\"\nassert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"], \"Test case 2 failed\"\nassert sorted_list_sum([\"abcd\", \"bcde\", \"a\", \"aabc\"]) == [\"aabc\", \"abcd\", \"bcde\"], \"Test case 3 failed\"\nassert sorted_list_sum([]) == [], \"Test case 4 failed\"\nassert sorted_list_sum([\"a\", \"b\", \"c\", \"d\", \"ef\", \"fg\", \"gh\"]) == [\"ef\", \"fg\", \"gh\"], \"Test case 5 failed\"\n\nprint(\"All test cases passed!\")\n"}
{"task_id": "HumanEval/157", "completion": "import math\n\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degrees.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    \n    # Validate input to ensure sides are positive numbers\n    if not all(isinstance(x, (int, float)) and x > 0 for x in [a, b, c]):\n        raise ValueError(\"All sides must be positive numbers\")\n    \n    # Sort the sides so that the largest side (hypotenuse) is last\n    sides = sorted([a, b, c])\n    \n    # Check if the sum of the squares of the two smaller sides is equal to the square of the largest side\n    return math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2)\n\n# Example Usage:\n# print(right_angle_triangle(3, 4, 5))  # True\n# print(right_angle_triangle(1, 2, 3))  # False"}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n    def extension_strength(ext):\n        CAP = sum(1 for char in ext if char.isupper())\n        SM = sum(1 for char in ext if char.islower())\n        return CAP - SM\n\n    if not isinstance(class_name, str) or not isinstance(extensions, list):\n        raise TypeError(\"Invalid input types. class_name should be a string and extensions should be a list of strings.\")\n\n    strongest_extension = max(extensions, key=extension_strength)\n    \n    return f\"{class_name}.{strongest_extension}\"\n\n# This implementation:\n# - Defines a helper function `extension_strength` to calculate the strength of an extension based on the number of uppercase and lowercase letters.\n# - Validates input types to ensure the function receives the expected parameters.\n# - Uses Python's `max` function with a custom key to determine the extension with the highest strength value.\n# - Handles the case where multiple extensions might have the same strength by choosing the first one as max preserves the first occurrence of multiple winners."}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebraic \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"\n    # Check for the basic constraint to avoid malformed inputs\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The length of operator list must be equal to the length of operand list minus one.\")\n    \n    # Initialize the result with the first operand\n    result = operand[0]\n    \n    # Iterate over the operators and corresponding operands to build and evaluate the expression\n    for i, op in enumerate(operator):\n        next_operand = operand[i + 1]\n        \n        if op == '+':\n            result += next_operand\n        elif op == '-':\n            result -= next_operand\n        elif op == '*':\n            result *= next_operand\n        elif op == '//':\n            if next_operand == 0:\n                raise ZeroDivisionError(\"Cannot divide by zero in floor division.\")\n            result //= next_operand\n        elif op == '**':\n            result **= next_operand\n        else:\n            raise ValueError(f\"Unsupported operator: {op}\")\n    \n    return result\n\n# Example usage:\n# operators = ['+', '*', '-']\n# operands = [2, 3, 4, 5]\n# print(do_algebra(operators, operands))  # Output should be 9"}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    \n    # Calculate the actual number of carrots the rabbit can eat\n    can_eat = min(need, remaining)\n    \n    # Update the total number of eaten carrots\n    total_eaten = number + can_eat\n    \n    # Calculate the remaining carrots after eating\n    remaining_carrots = remaining - can_eat\n    \n    # Return the result as an array [total eaten carrots, remaining carrots]\n    return [total_eaten, remaining_carrots]\n\n# Examples to validate the implementation\n# print(eat(5, 6, 10))  # Expected output: [11, 4]\n# print(eat(4, 8, 9))   # Expected output: [12, 1]\n# print(eat(1, 10, 10)) # Expected output: [11, 0]\n# print(eat(2, 11, 5))  # Expected output: [7, 0]"}
{"task_id": "HumanEval/162", "completion": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    # Check if the input text is an empty string; return None if it is\n    if text == \"\":\n        return None\n\n    # Initialize the MD5 hash object\n    md5_hasher = hashlib.md5()\n\n    # Update the hash object with the given text encoded as bytes\n    md5_hasher.update(text.encode('utf-8'))\n\n    # Obtain the hexadecimal representation of the hash\n    md5_hash = md5_hasher.hexdigest()\n\n    # Return the resulting MD5 hash\n    return md5_hash\n\n# Test examples\nif __name__ == \"__main__\":\n    print(string_to_md5('Hello world'))  # Output should be '3e25960a79dbc69b674cd4ec67a72c62'\n    print(string_to_md5(''))             # Output should be None"}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n\n    # List of planets in order from closest to the Sun to farthest\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\n    # Dictionary to easily access the index of planets\n    planet_indices = {planet: index for index, planet in enumerate(planets)}\n\n    # Input validation: check if both planet1 and planet2 are in the planet list\n    if planet1 not in planet_indices or planet2 not in planet_indices:\n        return ()\n\n    # Get the indices of the two planets\n    index1 = planet_indices[planet1]\n    index2 = planet_indices[planet2]\n\n    # Identify start and end index for the range\n    start = min(index1, index2)\n    end = max(index1, index2)\n\n    # Extract planets between the two given planets\n    planets_between = planets[start + 1:end]\n\n    return tuple(planets_between)\n\n# Output the final function as requested"}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \n    :param a: First positive integer (start of range)\n    :param b: Second positive integer (end of range)\n    :return: List of even digits in ascending order\n    \"\"\"\n    \n    # Ensure that a and b are positive integers\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        raise ValueError(\"Both a and b need to be positive integers.\")\n    \n    # Determine the range boundaries\n    start, end = min(a, b), max(a, b)\n    \n    # Generate the even digits in the range [start, end]\n    even_digits = [num for num in range(start, end + 1) if num % 2 == 0]\n    \n    return even_digits\n\n# Test cases\nprint(generate_integers(2, 8))  # Expected output: [2, 4, 6, 8]\nprint(generate_integers(8, 2))  # Expected output: [2, 4, 6, 8]\nprint(generate_integers(10, 14))  # Expected output: []"}
